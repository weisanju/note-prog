<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title></title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="index.html">我的笔记库</a></li><li class="chapter-item expanded affix "><li class="part-title"></li><li class="chapter-item expanded "><div><strong aria-hidden="true">1.</strong> C++</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="1.C++/C++与C的区别.html"><strong aria-hidden="true">1.1.</strong> C++与C的区别</a></li><li class="chapter-item expanded "><a href="1.C++/C++面向对象.html"><strong aria-hidden="true">1.2.</strong> C++面向对象</a></li><li class="chapter-item expanded "><a href="1.C++/泛型编程.html"><strong aria-hidden="true">1.3.</strong> 泛型编程</a></li><li class="chapter-item expanded "><a href="1.C++/cmake/index.html"><strong aria-hidden="true">1.4.</strong> cmake</a></li></ol></li><li class="chapter-item expanded "><a href="2.LUA/index.html"><strong aria-hidden="true">2.</strong> LUA</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="2.LUA/基本语法.html"><strong aria-hidden="true">2.1.</strong> 基本语法</a></li><li class="chapter-item expanded "><a href="2.LUA/高级语法.html"><strong aria-hidden="true">2.2.</strong> 高级语法</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">3.</strong> rust</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="3.rust/1常见编程概念.html"><strong aria-hidden="true">3.1.</strong> 1常见编程概念</a></li><li class="chapter-item expanded "><a href="3.rust/2所有权.html"><strong aria-hidden="true">3.2.</strong> 2所有权</a></li><li class="chapter-item expanded "><a href="3.rust/ConstantsAndVariables.html"><strong aria-hidden="true">3.3.</strong> ConstantsAndVariables</a></li><li class="chapter-item expanded "><a href="3.rust/Rust中的Sizedness.html"><strong aria-hidden="true">3.4.</strong> Rust中的Sizedness</a></li><li class="chapter-item expanded "><a href="3.rust/Rust库API设计文档规范.html"><strong aria-hidden="true">3.5.</strong> Rust库API设计文档规范</a></li><li class="chapter-item expanded "><a href="3.rust/const类型与函数.html"><strong aria-hidden="true">3.6.</strong> const类型与函数</a></li><li class="chapter-item expanded "><a href="3.rust/newType模式.html"><strong aria-hidden="true">3.7.</strong> newType模式</a></li><li class="chapter-item expanded "><a href="3.rust/rust执行shell命令.html"><strong aria-hidden="true">3.8.</strong> rust执行shell命令</a></li><li class="chapter-item expanded "><a href="3.rust/rust指针.html"><strong aria-hidden="true">3.9.</strong> rust指针</a></li><li class="chapter-item expanded "><a href="3.rust/rust面向对象特性.html"><strong aria-hidden="true">3.10.</strong> rust面向对象特性</a></li><li class="chapter-item expanded "><a href="3.rust/依赖管理.html"><strong aria-hidden="true">3.11.</strong> 依赖管理</a></li><li class="chapter-item expanded "><a href="3.rust/函数式编程.html"><strong aria-hidden="true">3.12.</strong> 函数式编程</a></li><li class="chapter-item expanded "><a href="3.rust/宏.html"><strong aria-hidden="true">3.13.</strong> 宏</a></li><li class="chapter-item expanded "><a href="3.rust/常见集合.html"><strong aria-hidden="true">3.14.</strong> 常见集合</a></li><li class="chapter-item expanded "><a href="3.rust/模式匹配.html"><strong aria-hidden="true">3.15.</strong> 模式匹配</a></li><li class="chapter-item expanded "><a href="3.rust/泛型与trait.html"><strong aria-hidden="true">3.16.</strong> 泛型与trait</a></li><li class="chapter-item expanded "><a href="3.rust/结构体.html"><strong aria-hidden="true">3.17.</strong> 结构体</a></li><li class="chapter-item expanded "><a href="3.rust/迭代与闭包.html"><strong aria-hidden="true">3.18.</strong> 迭代与闭包</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">3.19.</strong> rfcs</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="3.rust/rfcs/0195_associated-items.html"><strong aria-hidden="true">3.19.1.</strong> 0195_associated-items</a></li><li class="chapter-item expanded "><a href="3.rust/rfcs/0911-const-fn.html"><strong aria-hidden="true">3.19.2.</strong> 0911-const-fn</a></li></ol></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.</strong> groovy</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="4.groovy/RuntimeAndCompile-timeMetaprogramming.html"><strong aria-hidden="true">4.1.</strong> RuntimeAndCompile-timeMetaprogramming</a></li><li class="chapter-item expanded "><a href="4.groovy/基础语法.html"><strong aria-hidden="true">4.2.</strong> 基础语法</a></li><li class="chapter-item expanded "><a href="4.groovy/开发工具类.html"><strong aria-hidden="true">4.3.</strong> 开发工具类</a></li><li class="chapter-item expanded "><a href="4.groovy/操作符.html"><strong aria-hidden="true">4.4.</strong> 操作符</a></li><li class="chapter-item expanded "><a href="4.groovy/编程结构.html"><strong aria-hidden="true">4.5.</strong> 编程结构</a></li></ol></li><li class="chapter-item expanded "><a href="5.typescript/index.html"><strong aria-hidden="true">5.</strong> typescript</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="5.typescript/1.基础类型.html"><strong aria-hidden="true">5.1.</strong> 基础类型</a></li><li class="chapter-item expanded "><a href="5.typescript/2.变量声明.html"><strong aria-hidden="true">5.2.</strong> 变量声明</a></li><li class="chapter-item expanded "><a href="5.typescript/3.接口.html"><strong aria-hidden="true">5.3.</strong> 接口</a></li><li class="chapter-item expanded "><a href="5.typescript/4.模块.html"><strong aria-hidden="true">5.4.</strong> 模块</a></li><li class="chapter-item expanded "><a href="5.typescript/jtest测试框架/index.html"><strong aria-hidden="true">5.5.</strong> jtest测试框架</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="5.typescript/jtest测试框架/Except.html"><strong aria-hidden="true">5.5.1.</strong> Except</a></li><li class="chapter-item expanded "><a href="5.typescript/jtest测试框架/Globals.html"><strong aria-hidden="true">5.5.2.</strong> Globals</a></li><li class="chapter-item expanded "><a href="5.typescript/jtest测试框架/Hook顺序.html"><strong aria-hidden="true">5.5.3.</strong> Hook顺序</a></li></ol></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title"></h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="我的笔记库"><a class="header" href="#我的笔记库">我的笔记库</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="c对-c-的加强"><a class="header" href="#c对-c-的加强">C++对 C 的加强</a></h1>
<h2 id="变量与常量"><a class="header" href="#变量与常量">变量与常量</a></h2>
<ul>
<li>
<p>register 关键字在 C++中失效了,只是为了兼容C语言</p>
</li>
<li>
<p>C 语言可以同时声明多个同名变量,指向同一个地址空间,C++编译不通过</p>
</li>
<li>
<p>C 语言中的 const 关键字只是在编译器限制 变量不可变</p>
<p>①C++对于 const 作了加强,当碰见常量声明时,在符号表中放入常量,编译过程中若发现使用常量则直接以符号表中的值替换</p>
<p>②C++编译器不一定给常量分配空间,  只有对 const 使用了 extern 或者&amp;操作符, 时才会分配空间但是不会使用这个存储空间的值 </p>
<p>③C++ 常量跟宏的区别, 作用域的区别</p>
</li>
</ul>
<p><strong>宏的作用域 是整个文件</strong>,这样会导致权限无法限定, (可以通过 undefined 来限定) </p>
<pre><code class="language-c++">#define a 3
#undefine a
</code></pre>
<h2 id="struct-为新类型"><a class="header" href="#struct-为新类型"><code>struct</code> 为新类型</a></h2>
<ul>
<li>
<p>C++的类型: struct 类型</p>
</li>
<li>
<p>C 语言的 struct 类型 ,编译器认为只是变量的集合, 而不是新类型, C++是新类型</p>
</li>
</ul>
<pre><code class="language-c++">struct Student{
	const char * name;
	int age;
}
//C++
int main(){
	Student s1 = {&quot;sdff&quot;,30};
	Student s2 = {&quot;sdff&quot;,31};
}
//C
{
    struct Student s1 = {};
}
</code></pre>
<h2 id="函数默认参数与默认返回值"><a class="header" href="#函数默认参数与默认返回值">函数默认参数与默认返回值</a></h2>
<ul>
<li>C 语言中的默认类型 f(i); </li>
<li>默认为整数参数,返回值默认为整数</li>
<li>在 C++中不支持</li>
</ul>
<h2 id="cbool类型"><a class="header" href="#cbool类型">c++bool类型</a></h2>
<ul>
<li>
<p>C++中的 bool 类型 取值 是 <code>true</code> <code>false</code> ,</p>
</li>
<li>
<p>理论上只占用 一个字节,如果多个 bool 类型定义在一起,<em>可能会被放到 同一个字节中(依据编译器的不同)</em> </p>
</li>
<li>
<p>给 C++中的 bool 类型赋值 整数时,非 0 为 true,0 为 false,(兼容C语言)</p>
</li>
</ul>
<h2 id="c中的三目运算符"><a class="header" href="#c中的三目运算符">C++中的三目运算符</a></h2>
<ul>
<li>
<p>可以作为左值使用</p>
<p>三目运算符的返回值 如果返回的时一个变量,则可以当做左值使用,如果可能的返回值里面有一个是常量,则不能作为左值使用</p>
</li>
</ul>
<h2 id="c中的引用"><a class="header" href="#c中的引用">C++中的引用</a></h2>
<p><strong>变量</strong></p>
<ul>
<li><code>变量</code> 一段连续内存空间的别名</li>
<li>程序通过变量来申请存储空间</li>
<li>通过变量可以使用存储空间</li>
</ul>
<p>**引用 **</p>
<p><strong>是已经定义变量的别名</strong>(<code>引用 必须用其他的变量初始化</code>)</p>
<ol>
<li>语法 Type&amp; name=varname;</li>
<li>引用 可读性 好</li>
<li>引用作为函数参数</li>
<li>const int &amp;a 引用,const 引用只是让变量 拥有只读属性</li>
<li>const 引用进行初始化 时,C++编译器会为常量值 分配空间,并将引用名作为这段空间的别名, 跟 C 语言中的 只读变量一样</li>
<li>引用有自己的空间吗? 引用的 本质上是 C 语言中的 常指针 Type &amp; name -&gt; Type * const name 为了实用性,而做出的细节隐藏</li>
<li>引用作为函数返回值 时 不能 作为左值使用, 当引用是静态全局变量时 可以</li>
<li>无法建立引用数组</li>
</ol>
<h2 id="内联函数"><a class="header" href="#内联函数">内联函数</a></h2>
<ol>
<li>
<p>内联函数 必须与函数定义结合在一起</p>
<ol>
<li>
<p><code>inline int func(int a){return a&lt;b?:a:b;}</code> 直接 对其他调用它的函数 进行 直接 插入替换</p>
</li>
<li>
<p>C++不一定响应函数的内联 请求,如果 请求不通过,则 退化成普通函数,</p>
</li>
<li>
<p>内联函数没有普通函数 调用的开销,编译器还是会进行类型检查</p>
</li>
<li>
<p>宏是由 预处理器进行简单的替换的,而 内联函数 是 由编译器进行的</p>
</li>
<li>
<p>强制 内联编译 inline int func(int a) **attribute_((always_inline)); g++ -S 编译成汇编代码 **</p>
</li>
<li>
<p>C++内联 编译的 限制 :</p>
<ol>
<li>
<p>不能存在任何形式的循环语句</p>
</li>
<li>
<p>不能存在过多的条件判断</p>
</li>
<li>
<p>函数体不能过于庞大,一般比超过五句</p>
</li>
<li>
<p>不能对函数进行取址操作</p>
</li>
<li>
<p>函数内联声明必须在调用语句之前</p>
</li>
</ol>
</li>
</ol>
</li>
<li>
<p>C++中的 符号表 ,是 C++编译器 在编译代码 时 自己使用的 在处理内联请求 时,会把 内联函数放到 符号表中,当有地方调用它时,会进行类型检查,返回值检查</p>
</li>
<li>
<p>函数默认参数</p>
<ol>
<li>int mul(x=0); 函数参数默认值</li>
<li>一旦函数参数开始使用 默认值,其后的参数必须也使用默认值</li>
</ol>
</li>
<li>
<p>C++的函数占位参数,</p>
<ol>
<li><code>int func(int a,int b,int)</code> 无法使用函数占位参数</li>
<li><code>int func(int a,int b,int=0)</code></li>
</ol>
</li>
<li>
<p>C++中的重载</p>
<ol>
<li>函数名相同,定义不同的函数参数</li>
<li>函数重载,跟默认参数 会发生二义性, 编译不通过</li>
<li>函数重载的编译方法精确匹配实参, 默认参数匹配, 默认类型转发匹配,同时进行,不能存在二义性</li>
<li>函数重载 与函数指针 在用函数名称 跟函数指针 赋值时 选择与函数指针类型参数列表篇一致 的候选者</li>
</ol>
</li>
<li>
<p>C,与 C++的相互调用</p>
<ol>
<li>
<p>C 语言的编译器 兼容 C 语言的编译器</p>
</li>
<li>
<p>C++ 优先使用 C++的编译方式, extern 强制让 C++对代码进行 C 方式编译</p>
</li>
<li>
<p><code>extern &quot;C&quot;{ #include &quot;add.h&quot; }</code> 告诉 g++ 编译器, 这个头文件里的文件都是 C 语言编译的</p>
</li>
<li>
<p>内置宏</p>
<pre><code class="language-c++">#ifdef  __cplusplus
extern &quot;C&quot;{       #endif      #ifdef __cplusplus       }
#endif
</code></pre>
</li>
<li>
<p>C++ 编译器不能以 C 的方式 编译重载</p>
</li>
</ol>
</li>
<li>
<p>动态内存申请:(新增)</p>
<ol>
<li>变量 Type * pointe=new Type;</li>
<li>数组申请 Type * pointer =new Type[N];</li>
<li>delete pointer 释放内存,delete [ ] pointer</li>
<li>int * pi=new int(1) 申请空间时初始化,内存空间</li>
</ol>
</li>
<li>
<p>C++在中的命名空间</p>
<ol>
<li>
<p>C 语言中所有的全局标识符共享同一个作用域,标识符之间可能会发生冲突</p>
</li>
<li>
<p>命名空间将全局作用域分成不同的部分,不同命名空间中的标识符,可以重名,命名空间可以相互嵌套,全局作用域 也叫默认命名空间</p>
</li>
<li>
<p>命名空间的定义</p>
<pre><code class="language-c++">namespace first{       int i=0;     }
namespace second{       int i=0;
                 namespace Internal{       int p=0;
}}
</code></pre>
</li>
<li>
<p>命名空间的使用</p>
<pre><code class="language-c++">using namespace First; //可以直接使用命名空间的所有定义变量
using Second::Internal::P;     //Second::i 使用second命名空间中的i
</code></pre>
</li>
</ol>
</li>
<li>
<p>强制类型转换</p>
<p>① 基本类型转换 <code>static_cast</code></p>
<pre><code>char c=static_cast&lt;char)(i);
char *c=static_cast&lt;char *)(i);  //错误 ,只能用于基本类型的转换,只是在编译器检查
</code></pre>
<p>②const_cast 去除变量的 const 属性</p>
<pre><code class="language-c++">const int &amp;j=1;
int &amp;k=const_cast&lt;int &amp;&gt;(j);
const int x=2;
int &amp;y= const_cast&lt;int&amp;&gt;(x) //这会发生x,y 地址相同,但是值不同
</code></pre>
<p>③reinterpret_cast 指针类型转换 和 整数跟指针类型间的强制转换</p>
<p>直接从二进制位进行复制,是一种及其不安全的转换</p>
<p>④volatile const int y=2 退化成只读变量, const int z = y 将变量赋值给 一个常量 会退化成 只读变量</p>
<p>⑤ 凡是不能在编译器确定的 常量,均退化成只读变量,</p>
<p>⑥ 常(只读)引用,在用相同类型初始化时,会引用 相同的变量, 如果 用不同类型的初始化时,会生成一个新的只读变量</p>
</li>
<li>
<p>操作引用就是操作变量本身</p>
</li>
<li>
<p>extern C 告诉 C++ 编译器 以 C 语言的方式编译 但只是以 C 语言的函数命名方式 编译的,函数体还是 按 C++的方式编译, c++为了重载,函数名经过编译之后 会加上参数信息,因而编译后的函数名与源码中不同 C 语言的编译方式不允许函数重载</p>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="类定义"><a class="header" href="#类定义">类定义</a></h1>
<pre><code class="language-c++">class Test   {
    private: int i;int j;int k;
    public: Test(){ i=j=k=0; } //构造函数
}
</code></pre>
<h1 id="类实现"><a class="header" href="#类实现">类实现</a></h1>
<pre><code class="language-c++">class Array {
private:
    int length;
    int *data;
public:
    Array(int length) {
        std::cout &lt;&lt; &quot;initailizer&quot;&lt;&lt;std::endl;
        data = new int[length];
        this-&gt;length = 0;
    }
    void setData(int val);
    int getData(int index);
};

int Array::getData(int index) {
    return data[index];
}
void Array::setData(int val) {
    data[length++] = val;
}

</code></pre>
<h1 id="无参与拷贝构造"><a class="header" href="#无参与拷贝构造">无参与拷贝构造</a></h1>
<pre><code class="language-c++">//两个特殊的构造函数
无参构造,跟拷贝构造 :简单的对成员变量进行复制
// C++默认提供,这两个
    public:
        Test(){ printf(&quot;Test()\n&quot;)}
        Test(const Test &amp;obj){ printf(&quot;Test(const Test &amp;obj)&quot;)}
//一旦自己写了 以上构造函数之一的话,编译器就会不提供
</code></pre>
<h1 id="成员变量"><a class="header" href="#成员变量">成员变量</a></h1>
<ol>
<li>
<p>可以定义静态成员变量和静态成员函数</p>
</li>
<li>
<p>静态成员属于整个类,不需要实例化</p>
</li>
<li>
<p>可以通过类名直接访问 public 静态成员</p>
</li>
<li>
<p>可以通过对象名访问 public 静态成员</p>
</li>
<li>
<p>静态成员函数可以直接访问静态成员变量</p>
</li>
<li>
<p>使用静态成员</p>
<p>1.分配空间在外部 int Test::cI=0;</p>
<p>2.使用通过类名: Test::SetI(5)</p>
</li>
<li>
<p>从命名空将的角度看,类的静态成员只是类这个命名空间中的全局变量,和全局函数,不同之处是 类可以对静态成员进行访问权限的控制,而命名空间不行</p>
</li>
<li>
<p>静态成员会进行 默认初始化 0</p>
</li>
<li>
<p>静态成员可以用来统计 该类 实例化了多少个成员变量</p>
</li>
</ol>
<h1 id="成员函数与成员变量的空间"><a class="header" href="#成员函数与成员变量的空间">成员函数与成员变量的空间</a></h1>
<ul>
<li>
<p>静态成员变量在全局数据区中存放着,不在类的空间</p>
</li>
<li>
<p>普通成员变量:存储与对象中,与 struct 变量有相同的内存布局和直接对齐方式</p>
</li>
<li>
<p>成员函数是 存储于代码段中</p>
</li>
<li>
<p>C++中的 class 从面向对象理论出发,将变量与函数集定义在一起, 在计算机内部,程序依然由 数据段和代码段组成</p>
</li>
</ul>
<h1 id="cclass-内部处理"><a class="header" href="#cclass-内部处理">C++Class 内部处理</a></h1>
<p><img src="https://i.loli.net/2021/01/02/clemQG6JXf2TzrD.png" alt="20210102102643" /></p>
<p>C++标准库涵盖 C库的功能 &lt;name.h&gt; 头文件对应 C++中的 <code>&lt;cname&gt;</code></p>
<p>C++标准库预定义了多数常用的数据结构</p>
<p><code>bitset deque list map queue set stack vector</code></p>
<h1 id="友元类"><a class="header" href="#友元类">友元类</a></h1>
<p>private声明使得类的成员不能被外部访问,但是通过friend 关键字可以例外的开放权限</p>
<h1 id="操作符重载"><a class="header" href="#操作符重载">操作符重载</a></h1>
<p>什么时候 用全局 ,什么时候 用 成员函数  来 重载操作符</p>
<pre><code class="language-c++">Array &amp; Array::operator= (const Array &amp;obj){
 	delete [] mspace;
 	mlength = obj.length;
 	mspace = new int[mlength];
 	for(int i=0;i&lt;mlength;i++){
 		mspace[i] = obj.mspace[i];
 	}
}


// C++中通过一个占位参数来区分前置运算符和 后置运算
Complex operator++ (int) // obj++;
{
    Complex ret = *this;
    a++;
    b++;
    return ret;
}

Complex opeator++(){ // ++obj
    ++a;
    ++b;
    return *this;
}


//重载左操作符
ostream&amp; operator&lt;&lt; (ostream&amp;out,const Complex&amp;c){
    out&lt;&lt;c.a&lt;&lt;&quot; + &quot;&lt;&lt;c.b&lt;&lt;&quot;i&quot;;
    return out;
}
</code></pre>
<p><strong>不要重载 &amp;&amp; || 操作符 , 因为会 违背 内定义的 短路法则</strong></p>
<p><strong>为了支持 链式调用, 返回其自身的引用</strong></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="c中的泛型编程"><a class="header" href="#c中的泛型编程">C++中的泛型编程</a></h1>
<blockquote>
<p>函数模板是 C++中的泛型编程支持</p>
</blockquote>
<h1 id="函数模板函数泛型"><a class="header" href="#函数模板函数泛型">函数模板（函数泛型）</a></h1>
<h2 id="语法"><a class="header" href="#语法">语法</a></h2>
<pre><code class="language-c++">template &lt;typename T&gt;
void swap(T &amp;a,T &amp;b){
	T t = a;
	a = b;
	b = t;
}


template &lt;typename T，typename T1,typename T2&gt;
</code></pre>
<h2 id="函数模板的应用"><a class="header" href="#函数模板的应用">函数模板的应用</a></h2>
<p><strong>自动类型推导调用</strong></p>
<pre><code class="language-c++">int a=1;
int b=2;
swap(a,b);
</code></pre>
<p><strong>具体类型显示调用</strong></p>
<pre><code class="language-c++">float fa =1;
float fb =4;
swap&lt;float&gt;(fa,fb)
</code></pre>
<h2 id="c函数模板的原理"><a class="header" href="#c函数模板的原理">C++函数模板的原理</a></h2>
<ul>
<li>编译器从函数模板通过具体类型 产生不通的函数</li>
<li>编译器会对函数模板进行两次编译
<ul>
<li>在申明的地方对模板代码本身进行编译</li>
<li>在调用的地方对参数替换后的代码进行编译</li>
</ul>
</li>
</ul>
<h2 id="函数模板与函数重载冲突"><a class="header" href="#函数模板与函数重载冲突">函数模板与函数重载冲突</a></h2>
<ul>
<li>c++编译器优先考虑普通函数</li>
<li>会从 普通函数与 模板函数中 选取一个<strong>匹配度更好的</strong></li>
<li>可以通过空模板实参列表的语法 限定编译器只通过模板匹配</li>
<li><strong>函数模板不能自动类型转换</strong></li>
<li>返回值类型不能自动推导
<ul>
<li>不完美的解决方案- 返回值的泛型声明放第一位，其他的就可以让编译器自动推导</li>
</ul>
</li>
</ul>
<pre><code class="language-c++">//声明
int max(int a,int b);

template&lt;typename T&gt;
T max(T a ,T b){}

//调用
max(a,b);//调用普通函数
Max&lt;&gt;(a,b)//调用模板函数

float fa = 3;
float fb = 4;
max(fa,fb) //这种情况下，会调用函数模板，因为float到int类型，会导致精度损失
</code></pre>
<h1 id="类模板"><a class="header" href="#类模板">类模板</a></h1>
<h2 id="类模板-1"><a class="header" href="#类模板-1">类模板</a></h2>
<ul>
<li>提供一种 特殊的类 以相同的行为 处理不同的类型</li>
<li>在类申明前 使用 <em>template</em> 进行标识</li>
</ul>
<h2 id="语法-1"><a class="header" href="#语法-1">语法</a></h2>
<pre><code class="language-c++">template&lt;typename T&gt;
class operator{
	public:
		T add(T a,T b){
			return a+b;
		}
		T minus(T a,T b){
			return a-b;
		}
}
</code></pre>
<ul>
<li>泛型类型 T 可用于申明成员变量和 成员函数</li>
<li>编译器对 类模板的处理方式 和 函数模板相同
<ul>
<li>从类模板 通过具体 类型产生 不通的类</li>
<li>编译器在 申明的地方对类模板进行编译</li>
<li>编译器 在 使用的地方对泛型替换后的 代码进行编译</li>
</ul>
</li>
</ul>
<h2 id="使用"><a class="header" href="#使用">使用</a></h2>
<p><strong>使用具体类型定义对象</strong></p>
<ul>
<li><code>Operator&lt;int&gt; op1</code></li>
<li><code>Operator&lt;double&gt; op1</code></li>
</ul>
<p><strong>工程实践中</strong></p>
<p>一般会把类模板的定义直接放到头文件中，或者放到 <em>.hpp</em>头文件中，使用的时候 include hpp 文件</p>
<h2 id="类模板的特化"><a class="header" href="#类模板的特化">类模板的特化</a></h2>
<p><strong>类模板定义</strong></p>
<pre><code class="language-c++">template&lt;typename T&gt;
class Test{
	T test(T v){
		count&lt;&lt;&quot;T test(T v)&quot;&lt;&lt;endl;
		count&lt;&lt; sizeof(T)&lt;&lt;endl;
	}
}
</code></pre>
<p><strong>类模板特化</strong></p>
<pre><code class="language-c++">template&lt;&gt;
class Test&lt;int&gt;{
	public:
		int test(int v){
			count&lt;&lt;&quot;int test(int v)&quot;&lt;&lt;endl;
			count&lt;&lt;&quot;sizeof(int) =&quot; &lt;&lt;sizeof(int)&lt;&lt;endl;
		}
}
</code></pre>
<p><strong>局部特化</strong></p>
<blockquote>
<p>编译器会考虑 最具体的 特化模板，如果遇到两个局部特化的模板，则编译器报错</p>
</blockquote>
<pre><code class="language-c++">template&lt;typename T1,typename T2&gt;
class Test{
	public void(T1 t1,T2 t2){
		count&lt;&lt;t1+t2&lt;&lt;endl;
	}
}

//模板特化，特化的是模板，（更加具体化）
template&lt;typename T&gt;
class Test&lt;T,T&gt;{
	public void(T t1,T t2){
		count&lt;&lt;t1+t2&lt;&lt;endl;
	}
}

//具体类型特化
template&lt;typename T&gt;
class Test&lt;int,T&gt;{
	public void(int t1,T t2){
		count&lt;&lt;t1+t2&lt;&lt;endl;
	}
}
</code></pre>
<h1 id="非类型模板参数"><a class="header" href="#非类型模板参数">非类型模板参数</a></h1>
<blockquote>
<p>函数模板和类模板的模板参数可以是普通数值</p>
</blockquote>
<ul>
<li>变量不能作为模板参数</li>
<li>浮点数和类对象不能作为模板参数</li>
<li>全局指针不能作为模板参数</li>
</ul>
<h2 id="实例"><a class="header" href="#实例">实例</a></h2>
<pre><code class="language-c++">//定义
template&lt;typename T,int N&gt;
void func(){
	T array[N] = {0};
	for(int i=0;i&lt;N;i++){
		array[i] = i+1;
		count&lt;&lt;array[i]&lt;&lt;endl;
	}
}
//使用
int main(int argc,char *argv[]){
    func&lt;int,5&gt;();
	func&lt;float,10&gt;();
}
</code></pre>
<h2 id="递归编译"><a class="header" href="#递归编译">递归编译</a></h2>
<pre><code class="language-c++">template&lt;int N&gt;
class Sum{
	public: static const int VALUE = Sum&lt;N-1&gt;::VALUE+N;
}

template&lt;&gt;
class Sum&lt;1&gt;{
	public: static const int VALUE = 1;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="源文件划分"><a class="header" href="#源文件划分">源文件划分</a></h1>
<p>cmake语言 将工程源文件划分为</p>
<ul>
<li><a href="https://cmake.org/cmake/help/latest/manual/cmake-language.7.html#directories">Directories</a> (<code>CMakeLists.txt</code>)</li>
<li><a href="https://cmake.org/cmake/help/latest/manual/cmake-language.7.html#scripts">Scripts</a> (<code>&lt;script&gt;.cmake</code>)</li>
<li><a href="https://cmake.org/cmake/help/latest/manual/cmake-language.7.html#modules">Modules</a> (<code>&lt;module&gt;.cmake</code>)</li>
</ul>
<h2 id="directories"><a class="header" href="#directories">Directories</a></h2>
<ul>
<li><code>CMakeLists.txt</code> 位于目录顶层, 是工程的入口, 最终会被解析成 构建树</li>
<li>这个文件中 可以 添加  <code>entire build specification</code>   也可以添加子目录 <code>add_subdirectory()</code>,.子目录也会产生构建树</li>
<li>每个被添加的子目录必须包括 一个  <code>CMakeLists.txt</code> 的入口点文件 </li>
</ul>
<h2 id="scripts"><a class="header" href="#scripts">Scripts</a></h2>
<ul>
<li>
<p>独立 .<em>cmake</em> 源文件 </p>
</li>
<li>
<p>按照<em>Cmake</em>语法执行脚本 通过 <code>-P选项</code></p>
</li>
</ul>
<h2 id="modules"><a class="header" href="#modules">Modules</a></h2>
<ul>
<li>
<p>在 <code>Scripts</code>  <code>Directories</code> 中可以使用 <code>include()</code> 命令,</p>
</li>
<li>
<p>导入<code>&lt;module&gt;</code>.cmake 脚本命令</p>
</li>
</ul>
<h1 id="语法-2"><a class="header" href="#语法-2">语法</a></h1>
<h2 id="sourcefile"><a class="header" href="#sourcefile">SourceFile</a></h2>
<pre><code>file         ::=  file_element*
file_element ::=  command_invocation line_ending |
                  (bracket_comment|space)* line_ending
line_ending  ::=  line_comment? newline
space        ::=  &lt;match '[ \t]+'&gt;
newline      ::=  &lt;match '\n'&gt;
</code></pre>
<h2 id="命令调用"><a class="header" href="#命令调用">命令调用</a></h2>
<p><strong>Command Invocations</strong></p>
<pre><code>command_invocation  ::=  space* identifier space* '(' arguments ')'
identifier          ::=  &lt;match '[A-Za-z_][A-Za-z0-9_]*'&gt;
arguments           ::=  argument? separated_arguments*
separated_arguments ::=  separation+ argument? |
                         separation* '(' arguments ')'
separation          ::=  space | line_ending
</code></pre>
<p><strong>Command Arguments</strong></p>
<pre><code>argument ::=  bracket_argument | quoted_argument | unquoted_argument
</code></pre>
<h2 id="参数形式"><a class="header" href="#参数形式">参数形式</a></h2>
<p><strong>Bracket Argument</strong></p>
<pre><code>bracket_argument ::=  bracket_open bracket_content bracket_close
bracket_open     ::=  '[' '='* '['
bracket_content  ::=  &lt;any text not containing a bracket_close with
                       the same number of '=' as the bracket_open&gt;
bracket_close    ::=  ']' '='* ']'
</code></pre>
<p><strong>Quoted Argument</strong></p>
<pre><code>quoted_argument     ::=  '&quot;' quoted_element* '&quot;'
quoted_element      ::=  &lt;any character except '\' or '&quot;'&gt; |
                         escape_sequence |
                         quoted_continuation
quoted_continuation ::=  '\' newline
</code></pre>
<p><strong>Unquoted Argument</strong></p>
<pre><code>unquoted_argument ::=  unquoted_element+ | unquoted_legacy
unquoted_element  ::=  &lt;any character except whitespace or one of '()#&quot;\'&gt; |
                       escape_sequence
unquoted_legacy   ::=  &lt;see note in text&gt;
</code></pre>
<p>例子</p>
<pre><code>foreach(arg
    NoSpace
    Escaped\ Space
    This;Divides;Into;Five;Arguments
    Escaped\;Semicolon
    )
  message(&quot;${arg}&quot;)
endforeach()
</code></pre>
<p><strong>Escape Sequences</strong></p>
<pre><code>escape_sequence  ::=  escape_identity | escape_encoded | escape_semicolon
escape_identity  ::=  '\' &lt;match '[^A-Za-z0-9;]'&gt;  //字符串本身
escape_encoded   ::=  '\t' | '\r' | '\n'  // tab,回车,换行
escape_semicolon ::=  '\;' //;
</code></pre>
<h2 id="变量引用"><a class="header" href="#变量引用">变量引用</a></h2>
<p><strong>Variable References</strong></p>
<ul>
<li>形如<code>${&lt;variable&gt;}</code>  是被解析为  <code>Quoted Argument</code>,<code>Unquoted Argument</code> </li>
<li>变量可以嵌套 从内而外. <code>${outer_${inner_variable}_variable}</code></li>
<li>详见 <a href="https://cmake.org/cmake/help/latest/manual/cmake-language.7.html#variables">Variables</a> 变量作用域以及 如何设置值</li>
<li>环境变量 形如  <code>$ENV{&lt;variable&gt;} </code>  详见<a href="https://cmake.org/cmake/help/latest/manual/cmake-language.7.html#environment-variables">Environment Variables</a></li>
<li>缓存变量 形如 <code>$CACHE{&lt;variable&gt;}</code>,详见 <a href="https://cmake.org/cmake/help/latest/variable/CACHE.html#variable:CACHE"><code>CACHE</code></a></li>
<li><code>if()</code> 命令 中的 变量 可以  <code>&lt;variable&gt;</code> instead of <code>${&lt;variable&gt;}</code>., environment and cache variables always need to be referenced as <code>$ENV{&lt;variable&gt;}</code> or <code>$CACHE{&lt;variable&gt;}</code>.</li>
</ul>
<h2 id="注释"><a class="header" href="#注释">注释</a></h2>
<p><strong>Bracket Comment</strong></p>
<pre><code>#[[This is a bracket comment.
It runs until the close bracket.]]
message(&quot;First Argument\n&quot; #[[Bracket Comment]] &quot;Second Argument&quot;)
</code></pre>
<p><strong>Line Comment</strong></p>
<pre><code># This is a line comment.
message(&quot;First Argument\n&quot; # This is a line comment :)
        &quot;Second Argument&quot;) # This is a line comment.
</code></pre>
<h2 id="控制流程"><a class="header" href="#控制流程">控制流程</a></h2>
<p><strong>条件块</strong></p>
<pre><code>if()/elseif()/else()/endif()
</code></pre>
<p><strong>LOOP</strong></p>
<pre><code>The foreach()/endforeach() and while()/endwhile() commands delimit code blocks to be executed in a loop. 
Inside such blocks the break() command may be used to terminate the loop early whereas the continue() command may be used to start with the next iteration immediately.
</code></pre>
<p><strong>命令定义</strong></p>
<p>The <a href="https://cmake.org/cmake/help/latest/command/macro.html#command:macro"><code>macro()</code></a>/<a href="https://cmake.org/cmake/help/latest/command/endmacro.html#command:endmacro"><code>endmacro()</code></a>, and <a href="https://cmake.org/cmake/help/latest/command/function.html#command:function"><code>function()</code></a>/<a href="https://cmake.org/cmake/help/latest/command/endfunction.html#command:endfunction"><code>endfunction()</code></a> </p>
<h2 id="变量"><a class="header" href="#变量">变量</a></h2>
<ul>
<li>变量是 Cmake的  基本存储单元</li>
<li>都是string类型</li>
<li><a href="https://cmake.org/cmake/help/latest/command/set.html#command:set"><code>set()</code></a> and <a href="https://cmake.org/cmake/help/latest/command/unset.html#command:unset"><code>unset()</code></a>  设置或取消变量</li>
<li>变量名大小写敏感,可以包含任何文本</li>
<li>变量有作用域  ,set,unset只在当前作用域</li>
</ul>
<p><strong>Function Scope</strong></p>
<p><em>function</em> 内部</p>
<p><strong>Directory Scope</strong></p>
<ul>
<li>整个  <code>CMakeLists.txt</code>文件中,也继承父级 作用域的 变量</li>
</ul>
<p><strong>Persistent Cache</strong></p>
<p>CMake stores a separate set of “cache” variables, or “cache entries”, whose values persist across multiple runs within a project build tree. Cache entries have an isolated binding scope modified only by explicit request, such as by the <code>CACHE</code> option of the <a href="https://cmake.org/cmake/help/latest/command/set.html#command:set"><code>set()</code></a> and <a href="https://cmake.org/cmake/help/latest/command/unset.html#command:unset"><code>unset()</code></a> commands.</p>
<p><strong>Cmake保留命令</strong></p>
<pre><code>CMake reserves identifiers that:
begin with CMAKE_ (upper-, lower-, or mixed-case), or
begin with _CMAKE_ (upper-, lower-, or mixed-case), or
begin with _ followed by the name of any
</code></pre>
<p><strong>Environment Variables</strong></p>
<p>与普通变量一样,除了以下几点</p>
<p>Scope</p>
<p>Environment variables have global scope in a CMake process. They are never cached.</p>
<p>References</p>
<p><a href="https://cmake.org/cmake/help/latest/manual/cmake-language.7.html#variable-references">Variable References</a> have the form <code>$ENV{&lt;variable&gt;}</code>.</p>
<h2 id="list"><a class="header" href="#list">list</a></h2>
<p>尽管所有值 存储为 string, 但在某些场合 也可以当作 <em>list</em></p>
<p>例如在  <code>Unquoted Argument</code> 的解析时, 参数以 ';'分隔</p>
<p>数组元素 作为string展示时 以 ';' 连接</p>
<pre><code>set(srcs a.c b.c c.c) # sets &quot;srcs&quot; to &quot;a.c;b.c;c.c&quot;
set(x a &quot;b;c&quot;) 
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="概述"><a class="header" href="#概述">概述</a></h1>
<p>Lua是一种用C语言编写的可扩展，轻量级的编程语言。它于1993年由Roberto Ierusalimschy，Luiz Henrique de Figueiredo和Waldemar Celes作为内部项目开始研发。</p>
<p>Lua从一开始就设计成一个可以与用C语言和其他传统语言编写的代码集成的软件。 这种集成带来许多好处。 Lua并没有尝试做C语言已经做过的事情，而是提供C语言不擅长的东西：与硬件的良好距离，动态结构，无冗余，易于测试和调试。 为此，Lua是具有安全的环境，自动内存管理以及用于处理动态大小的字符串和其他类型数据的良好工具。</p>
<h1 id="lua特征"><a class="header" href="#lua特征">Lua特征</a></h1>
<p>扩展</p>
<p>简单</p>
<p>高效</p>
<p>可移植</p>
<p>免费开放源码</p>
<h1 id="lua是如何实现的"><a class="header" href="#lua是如何实现的">Lua是如何实现的？</a></h1>
<p>Lua由两部分组成 -  Lua解释器部分和功能软件系统。 功能正常的软件系统是一个实际的计算机应用程序，可以解释用Lua编程语言编写的程序。 Lua解释器是用ANSI C编写的，因此它具有高度的可移植性，可以运行在高端网络服务器和小型设备的各种设备上。</p>
<p>Lua语言和解释器都是成熟，小巧，快速的。 它已经从其他编程语言和顶级软件标准发展而来。软件代码较小使它可以在内存较低的小型设备上运行。</p>
<h1 id="lua的一些用途"><a class="header" href="#lua的一些用途">Lua的一些用途</a></h1>
<p>游戏编程</p>
<p>独立应用程序中的脚本</p>
<p>在Web上编写脚本</p>
<p>MySQL Proxy和MySQL WorkBench等数据库的扩展和附加组件</p>
<p>安全系统，如入侵检测系统。</p>
<h1 id="lua开发环境配置"><a class="header" href="#lua开发环境配置">Lua开发环境配置</a></h1>
<pre><code class="language-shell">$ curl -R -O http://www.lua.org/ftp/lua-5.3.5.tar.gz
$ yum install readline-devel
$ tar zxf lua-5.3.5.tar.gz
$ cd lua-5.3.5
$ make linux test
</code></pre>
<h1 id="lua基础语法"><a class="header" href="#lua基础语法">Lua基础语法</a></h1>
<h2 id="交互式模式编程"><a class="header" href="#交互式模式编程">交互式模式编程</a></h2>
<pre><code>Lua提供了一种叫作交互模式的模式。 在此模式下，可以依次输入命令代码并获得即时结果。 这可以通过使用lua -i或lua命令在shell中调用。 输入此内容后，按Enter 键，将启动交互模式，如下所示
</code></pre>
<h2 id="默认模式编程"><a class="header" href="#默认模式编程">默认模式编程</a></h2>
<p>使用Lua文件名参数调用解释器开始执行文件并继续直到脚本完成。 脚本完成后，解释器不再处于活动状态。</p>
<pre><code class="language-lua">#!/usr/local/bin/lua
print(&quot;Hello, Welcome&quot;)
</code></pre>
<h2 id="luatoken标记"><a class="header" href="#luatoken标记">LuaToken标记</a></h2>
<p>Lua程序由各种标记组成，标记可以是<strong>关键字</strong>，<strong>标识符</strong>，<strong>常量</strong>，<strong>字符串文字</strong>或<strong>符号</strong>。 例如，以下Lua语句由三个标记组成 -</p>
<h2 id="注释-1"><a class="header" href="#注释-1">注释</a></h2>
<pre><code>--[[ my first program in Lua --]]
</code></pre>
<h2 id="标识符"><a class="header" href="#标识符">标识符</a></h2>
<p>Lua标识符是用于标识变量，函数或任何其他用户定义项的名称。 标识符以字母<code>A</code>到<code>Z</code>或<code>a</code>到<code>z</code>或下划线<code>_</code>开头，后跟零个或多个字母，下划线和数字(<code>0</code>到<code>9</code>)。</p>
<p>Lua不允许标识符中的标点符号，如<code>@</code>，<code>$</code>和<code>%</code>。 Lua是一种<strong>区分大小写</strong>的编程语言。</p>
<h2 id="关键字"><a class="header" href="#关键字">关键字</a></h2>
<p>以下列表显示了Lua中的一些保留字。 这些保留字不能用作常量或变量或任何其他标识符名称。</p>
<pre><code>and break do else elseif end false for function if in local nil not or repeat return then true until while
</code></pre>
<h2 id="lua空白符"><a class="header" href="#lua空白符">Lua空白符</a></h2>
<p>只包含空格(可能带有注释)的行称为空行，Lua解释器完全忽略它。</p>
<p>空白符是Lua用来描述空格，制表符，换行符和注释的术语。 空格符将语句的一部分与另一部分分开，并使解释器能够识别语句中的一个元素(如<code>int</code>结束)和下一个元素的开始位置。 因此，在以下声明中</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="变量-1"><a class="header" href="#变量-1">变量</a></h1>
<h2 id="简介"><a class="header" href="#简介">简介</a></h2>
<p>变量是程序可以操作的存储区域的名称。 它可以包含不同类型的值，包括函数和表。</p>
<p>变量的名称可以由字母，数字和下划线字符组成。 它必须以字母或下划线开头。 大写和小写字母是不同的，因为Lua区分大小写。Lua中有八种基本类型的值。</p>
<p>在Lua中，虽然没有可变数据类型，<strong>但根据变量的范围</strong>有三种类型。</p>
<ul>
<li><strong>全局变量</strong> - 所有变量都被视为全局变量，除非明确声明为局部变量。</li>
<li><strong>局部变量</strong> - 当为变量指定类型为<code>local</code>时，其范围受函数范围限制。</li>
<li><strong>表字段</strong> - 这是一种特殊类型的变量，可以保存除<code>nil</code>之外的任何内容，包括函数。</li>
</ul>
<h2 id="变量定义与申明"><a class="header" href="#变量定义与申明">变量定义与申明</a></h2>
<p>变量定义告诉解释器为变量创建存储的位置和数量。 变量定义具有可选类型，并包含该类型的一个或多个变量的列表，语法如下所示 -</p>
<pre><code class="language-lua">type variable_list;
type variable_list = value_list;

#分开赋值
local d , f = 5 ,10     --declaration of d and f as local variables. 
d , f = 5, 10;          --declaration of d and f as global variables.
#共同赋值
d, f = 10               --[[declaration of d and f as global variables. 
                           Here value of f is nil --]]
</code></pre>
<p>这里，type是可选的本地或全局类型，而variable_list可以包含一个或多个由逗号分隔的标识符名称。 这里显示了一些有效的声明 </p>
<pre><code>local    i, j
local    i
local    a,c
</code></pre>
<p><strong>对于没有初始化程序的定义：具有静态存储持续时间的变量使用<code>nil</code>隐式初始化。</strong></p>
<pre><code>-- Variable definition:
local a, b

-- Initialization
a = 10
b = 30

print(&quot;value of a:&quot;, a)

print(&quot;value of b:&quot;, b)

-- Swapping of variables
b, a = a, b

print(&quot;value of a:&quot;, a)

print(&quot;value of b:&quot;, b)

f = 70.0/3.0
print(&quot;value of f&quot;, f)
</code></pre>
<h2 id="lua-左值和右值"><a class="header" href="#lua-左值和右值">Lua 左值和右值</a></h2>
<p>Lua中有两种表达方式 - </p>
<ul>
<li><strong>左值</strong> - 引用内存位置的表达式称为“左值”表达式。 左值可以显示为赋值的左侧或右侧。</li>
<li><strong>右值</strong> - 术语右值是指存储在内存中某个地址的数据值。 右值是一个不能赋值的表达式，所以右值可能出现在右侧，但不会出现在赋值的左侧。</li>
</ul>
<h1 id="数据类型"><a class="header" href="#数据类型">数据类型</a></h1>
<p>Lua是一种动态类型语言，因此变量没有类型，只有值具有类型。 值可以存储在变量中，作为参数传递并作为结果返回。</p>
<p>在Lua中，虽然没有可变数据类型，但有值的类型。 值的数据类型列表如下。</p>
<p>在Lua中，虽然没有可变数据类型，但有值的类型。 值的数据类型列表如下。</p>
<table><thead><tr><th>编号</th><th>值类型</th><th>描述</th></tr></thead><tbody>
<tr><td>1</td><td><code>nil</code></td><td>用于区分值与某些数据或没有(<code>nil</code>)数据。</td></tr>
<tr><td>2</td><td><code>boolean</code></td><td>包括<code>true</code>和<code>false</code>作为值，通常用于条件检查。</td></tr>
<tr><td>3</td><td><code>number</code></td><td>表示实数(双精度浮点)数字。</td></tr>
<tr><td>4</td><td><code>string</code></td><td>表示字符数组。</td></tr>
<tr><td>5</td><td><code>function</code></td><td>表示用C语言或Lua编写的方法。</td></tr>
<tr><td>6</td><td><code>userdata</code></td><td>表示任意C语言数据。</td></tr>
<tr><td>7</td><td><code>thread</code></td><td>表示独立的执行线程，它用于实现协同程序。</td></tr>
<tr><td>8</td><td><code>table</code></td><td>表示普通数组，符号表，集合，记录，图形，树等，并实现关联数组。 它可以保存任何值(除了<code>nil</code>)。</td></tr>
</tbody></table>
<h2 id="类型函数"><a class="header" href="#类型函数">类型函数</a></h2>
<p>在Lua中，有一个名为<code>type</code>的函数能够确定变量的类型。 以下代码中给出了一些示例。</p>
<pre><code>print(type(&quot;What is my type&quot;))   --&gt; string
t = 10

print(type(5.8*t))               --&gt; number
print(type(true))                --&gt; boolean
print(type(print))               --&gt; function
print(type(nil))                 --&gt; nil
print(type(type(ABC)))           --&gt; string
</code></pre>
<p>默认情况下，在分配值或初始化之前，所有变量都将指向<code>nil</code>。 在Lua中，在条件检查的情况下，零和空字符串认为是：<code>true</code>。 因此，使用布尔运算时必须小心</p>
<h1 id="运算符"><a class="header" href="#运算符">运算符</a></h1>
<h2 id="概述-1"><a class="header" href="#概述-1">概述</a></h2>
<p>运算符是告诉解释器执行特定数学或逻辑操作的符号。 Lua语言内置运算符丰富，并提供以下类型的运算符 -</p>
<ul>
<li>算术运算符</li>
<li>关系运算符</li>
<li>逻辑运算符</li>
<li>其它运算符</li>
</ul>
<p>下表显示了Lua语言支持的所有算术运算符。 假设变量<code>A=10</code>，变量<code>B=20</code>，然后 - </p>
<h2 id="1-算术运算符"><a class="header" href="#1-算术运算符">1. 算术运算符</a></h2>
<table><thead><tr><th>运算符</th><th>描述</th><th>示例</th></tr></thead><tbody>
<tr><td><code>+</code></td><td>相加两个操作数</td><td><code>A + B = 30</code></td></tr>
<tr><td><code>-</code></td><td>从第一个减去第二个操作数</td><td><code>A - B = -10</code></td></tr>
<tr><td><code>*</code></td><td>将两个操作数相乘</td><td><code>A * B = 200</code></td></tr>
<tr><td><code>/</code></td><td>用除分子除以分子</td><td><code>B / A = 2</code></td></tr>
<tr><td><code>%</code></td><td>模数运算符，整数除法后的余数</td><td><code>B % A = 0</code></td></tr>
<tr><td><code>^</code></td><td>指数运算符取指数幂值</td><td><code>A^2 = 100</code></td></tr>
<tr><td><code>-</code></td><td>一元，取反</td><td><code>-A = -10</code></td></tr>
</tbody></table>
<h2 id="2-关系运算符"><a class="header" href="#2-关系运算符">2. 关系运算符</a></h2>
<p>下表显示了Lua语言支持的所有关系运算符。 假设变量<code>A=10</code>，变量<code>B=20</code>，然后 - </p>
<table><thead><tr><th>运算符</th><th>描述</th><th>示例</th></tr></thead><tbody>
<tr><td><code>==</code></td><td>检查两个操作数的值是否相等，如果相等，则条件变为真。</td><td><code>(A == B)</code>结果为<code>false</code></td></tr>
<tr><td><code>~=</code></td><td>检查两个操作数的值是否相等，如果值不相等则条件变为<code>true</code>。</td><td><code>(A ~= B)</code>结果为<code>true</code></td></tr>
<tr><td><code>&gt;</code></td><td>检查左操作数的值是否大于右操作数的值，如果是，则条件变为<code>true</code>。</td><td><code>(A &gt; B)</code>结果为<code>false</code></td></tr>
<tr><td><code>&lt;</code></td><td>检查左操作数的值是否小于右操作数的值，如果是，则条件变为<code>true</code>。</td><td><code>(A &lt; B)</code>结果为<code>true</code></td></tr>
<tr><td><code>&gt;=</code></td><td>检查左操作数的值是否大于或等于右操作数的值，如果是，则条件变为<code>true</code>。</td><td><code>(A &gt;= B)</code>结果为<code>false</code></td></tr>
<tr><td><code>&lt;=</code></td><td>检查左操作数的值是否小于或等于右操作数的值，如果是，则条件变为<code>true</code>。</td><td><code>(A &lt;= B)</code>结果为<code>true</code></td></tr>
</tbody></table>
<h2 id="3-逻辑运算符"><a class="header" href="#3-逻辑运算符">3. 逻辑运算符</a></h2>
<p>下表显示了Lua语言支持的所有逻辑运算符。 假设变量<code>A=true</code>，变量<code>B=false</code>，则 - </p>
<table><thead><tr><th>运算符</th><th>描述</th><th>示例</th></tr></thead><tbody>
<tr><td><code>and</code></td><td>逻辑与运算符。如果两个操作数都不为零，则条件成立。</td><td><code>(A and B)</code> 结果为<code>false</code></td></tr>
<tr><td><code>or</code></td><td>逻辑或运算符。 如果两个操作数中的任何一个不为零，则条件变为真。</td><td><code>(A or B)</code> 结果为<code>true</code></td></tr>
<tr><td><code>not</code></td><td>逻辑非运算符。用于反转其操作数的逻辑状态。 如果条件为真，则逻辑非运算符将为<code>false</code>。</td><td><code>!(A and B)</code>结果为<code>true</code></td></tr>
</tbody></table>
<h2 id="4-杂项运算符"><a class="header" href="#4-杂项运算符">4. 杂项运算符</a></h2>
<p>Lua语言支持的其他运算符包括连接和长度。</p>
<table><thead><tr><th>编号</th><th>描述</th><th>示例</th></tr></thead><tbody>
<tr><td><code>..</code></td><td>连接两个字符串</td><td>如果<code>a</code>为<code>Hello</code>，<code>b</code>为<code>World</code>，<code>a..b</code>将返回<code>Hello World</code>。</td></tr>
<tr><td><code>#</code></td><td>返回字符串或表长度的一元运算符。</td><td><code>#&quot;Hello&quot;</code> 将返回 <code>5</code></td></tr>
</tbody></table>
<h2 id="5-lua运算符优先级"><a class="header" href="#5-lua运算符优先级">5. Lua运算符优先级</a></h2>
<p>此处，具有最高优先级的运算符显示在表的顶部，具有最低优先级的运算符显示在底部。 在表达式中，将首先评估更高优先级的运算符。</p>
<table><thead><tr><th>类别</th><th>操作符</th><th>关联性</th></tr></thead><tbody>
<tr><td>一元</td><td><code>not</code> <code>#</code> <code>-</code></td><td>右到左</td></tr>
<tr><td>连接</td><td><code>..</code></td><td>右到左</td></tr>
<tr><td>乘法</td><td><code>*</code> <code>/</code> <code>%</code></td><td>左到右</td></tr>
<tr><td>加法</td><td><code>+</code> <code>-</code></td><td>左到右</td></tr>
<tr><td>关系</td><td><code>&lt;</code> <code>&gt;</code> <code>&lt;=</code> <code>&gt;=</code> <code>==</code> <code>~=</code></td><td>左到右</td></tr>
<tr><td>相等</td><td><code>==</code> <code>~=</code></td><td>左到右</td></tr>
<tr><td>逻辑与</td><td><code>and</code></td><td>左到右</td></tr>
<tr><td>逻辑或</td><td><code>or</code></td><td>左到右</td></tr>
</tbody></table>
<h1 id="流程控制"><a class="header" href="#流程控制">流程控制</a></h1>
<h2 id="循环"><a class="header" href="#循环">循环</a></h2>
<p>Lua提供以下类型的循环来处理循环需求。</p>
<table><thead><tr><th>编号</th><th>循环类型</th><th>描述</th></tr></thead><tbody>
<tr><td>1</td><td><a href="https://www.yiibai.com/lua/lua_while_loop.html">while循环</a></td><td>在给定条件为真时重复语句或语句组，它在执行循环体之前测试条件。</td></tr>
<tr><td>2</td><td><a href="https://www.yiibai.com/lua/lua_for_loop.html">for循环</a></td><td>多次执行一系列语句，并缩写管理循环变量的代码。</td></tr>
<tr><td>3</td><td><a href="https://www.yiibai.com/lua/lua_repeat_until_loop.html">repeat…unti循环</a></td><td>重复语句组的操作，直到满足<code>until</code>条件。</td></tr>
<tr><td>4</td><td><a href="https://www.yiibai.com/lua/lua_nested_loops.html">嵌套循环</a></td><td>可在任何循环中使用另一个或多个循环，如：<code>while</code>,<code>for</code>或<code>do..while</code>循环。</td></tr>
</tbody></table>
<p><strong>while循环</strong></p>
<pre><code>while(condition)
do
   statement(s)
end
</code></pre>
<p><strong>for循环</strong></p>
<pre><code>for init,max/min value, increment
do
   statement(s)
end

for i = 10,1,-1 
do 
   print(i) 
end
</code></pre>
<ul>
<li>
<p><code>init</code> 首先执行，只执行一次。 此步骤允许声明和初始化任何循环控制变量。</p>
</li>
<li>
<p>接下来执行<code>max/min</code>。 这是循环继续执行的最大值或最小值。 它在内部创建条件检查，以比较初始值和最大/最小值。</p>
</li>
<li>
<p>在执行<code>for</code>循环体之后，控制流会跳回到<code>increment/decrement</code>语句。此语句用于更新循环控制变量。</p>
</li>
<li>
<p>再次评估条件。 如果为真，则循环执行并且过程自身重复(循环体，然后递增步骤，然后再次调节)。 条件变为<code>false</code>后，<code>for</code>循环终止。</p>
</li>
</ul>
<p><strong>repeat</strong></p>
<pre><code>repeat
   statement(s)
until( condition )
</code></pre>
<h2 id="ifelse"><a class="header" href="#ifelse">ifelse</a></h2>
<pre><code>if(boolean_expression 1)
then
   --[ Executes when the boolean expression 1 is true --]

else if( boolean_expression 2)
   --[ Executes when the boolean expression 2 is true --]

else if( boolean_expression 3)
   --[ Executes when the boolean expression 3 is true --]
else 
   --[ executes when the none of the above condition is true --]
end
</code></pre>
<h1 id="函数"><a class="header" href="#函数">函数</a></h1>
<h2 id="函数声明"><a class="header" href="#函数声明">函数声明</a></h2>
<pre><code>optional_function_scope function function_name( argument1, argument2, argument3........, 
argumentn)

function_body

return result_params_comma_separated
end
</code></pre>
<p>Lua编程语言中的方法定义由方法头和方法体组成。以下是方法的所有部分 - </p>
<ul>
<li><strong>可选函数范围</strong> - 使用关键字<code>local</code>来限制函数的范围，或者忽略<code>scope</code>部分，这会变成一个全局函数。</li>
<li><strong>函数名称</strong> - 这是函数的实际名称。 函数名称和参数列表一起构成函数签名。</li>
<li><strong>参数</strong> - 参数就像一个占位符。 调用函数时，将值传递给参数。 该值称为实际参数或参数。 参数列表指的是方法的参数的类型，顺序和数量。 参数是可选的; 也就是说，方法的参数可有可无。</li>
<li><strong>函数主体</strong> - 方法体包含一组语句，用于定义方法的作用。</li>
<li><strong>返回</strong> - 在Lua中，可通过使用<code>return</code>关键字，后加逗号分隔返回值列表来返回多个值。</li>
</ul>
<pre><code>function max(num1, num2)

   if (num1 &gt; num2) then
      result = num1;
   else
      result = num2;
   end

   return result; 
end
</code></pre>
<h2 id="调用函数"><a class="header" href="#调用函数">调用函数</a></h2>
<pre><code>print(&quot;The maximum of the two numbers is &quot;,max(10,4))
print(&quot;The maximum of the two numbers is &quot;,max(5,6))
</code></pre>
<h2 id="分配和传递函数"><a class="header" href="#分配和传递函数">分配和传递函数</a></h2>
<pre><code>myprint = function(param)
   print(&quot;This is my print function -   ##&quot;,param,&quot;##&quot;)
end

function add(num1,num2,functionPrint)
   result = num1 + num2
   functionPrint(result)
end

myprint(10)
add(2,5,myprint)
</code></pre>
<h2 id="可变参数的函数"><a class="header" href="#可变参数的函数">可变参数的函数</a></h2>
<pre><code>function average(...)
   result = 0
   local arg = {...}
   for i,v in ipairs(arg) do
      result = result + v
   end
   return result/#arg
end

print(&quot;The average is&quot;,average(10,5,3,4,5,6))
</code></pre>
<h1 id="字符串"><a class="header" href="#字符串">字符串</a></h1>
<p>字符串是由一系列字符以及控制字符组成，如换页符。 字符串可以用三种形式初始化，包括 - </p>
<ul>
<li>单引号之间的字符</li>
<li>双引号之间的字符</li>
<li><code>[[</code>和<code>]]</code>之间的字符</li>
</ul>
<pre><code class="language-lua">string1 = &quot;Lua&quot;
print(&quot;&quot;String 1 is&quot;&quot;,string1)

string2 = 'Yiibai Tutorial'
print(&quot;String 2 is&quot;,string2)

string3 = [[&quot;Lua Tutorial&quot;]]
print(&quot;String 3 is&quot;,string3)
</code></pre>
<p><strong>转义</strong></p>
<p>转义序列及其用法列在下表中。</p>
<table><thead><tr><th>转义序列</th><th>用法</th></tr></thead><tbody>
<tr><td><code>\a</code></td><td>铃</td></tr>
<tr><td><code>\b</code></td><td>退格</td></tr>
<tr><td><code>\f</code></td><td>换页</td></tr>
<tr><td><code>\n</code></td><td>新行</td></tr>
<tr><td><code>\r</code></td><td>回车</td></tr>
<tr><td><code>\t</code></td><td>制表符</td></tr>
<tr><td><code>\v</code></td><td>垂直制表符</td></tr>
<tr><td><code>\\</code></td><td>反斜杠</td></tr>
<tr><td><code>&quot;</code></td><td>双引号</td></tr>
<tr><td><code>'</code></td><td>单引号</td></tr>
<tr><td><code>\[</code></td><td>左方括号</td></tr>
<tr><td><code>\]</code></td><td>右方括号</td></tr>
</tbody></table>
<h2 id="字符串操作"><a class="header" href="#字符串操作">字符串操作</a></h2>
<p>Lua支持字符串来操作字符串 - </p>
<table><thead><tr><th>编号</th><th>方法</th><th>作用</th></tr></thead><tbody>
<tr><td>1</td><td><code>string.upper(argument)</code></td><td>返回参数的大写表示。</td></tr>
<tr><td>2</td><td><code>string.lower(argument)</code></td><td>返回参数的小写表示。</td></tr>
<tr><td>3</td><td><code>string.gsub(mainString,findString,replaceString)</code></td><td>返回用<code>replaceString</code>替换<code>findString</code>后字符串。</td></tr>
<tr><td>4</td><td><code>string.find(mainString,findString, optionalStartIndex,optionalEndIndex)</code></td><td>返回<code>mainString</code>中<code>findString</code>的起始索引和结束索引找到字符串，如果未找到则返回<code>nil</code>。</td></tr>
<tr><td>5</td><td><code>string.reverse(arg)</code></td><td>将传递的字符串<code>arg</code>反转后的字符串。</td></tr>
<tr><td>6</td><td><code>string.format(...)</code></td><td>返回格式化字符串。</td></tr>
<tr><td>7</td><td><code>string.char(arg)</code> 和 <code>string.byte(arg)</code></td><td>返回输入参数的内部数字和字符表示。</td></tr>
<tr><td>8</td><td><code>string.len(arg)</code></td><td>返回传递字符串<code>arg</code>的长度。</td></tr>
<tr><td>9</td><td><code>string.rep(string, n))</code></td><td>通过重复相同的字符串<code>n</code>次返回一个字符串。</td></tr>
<tr><td>10</td><td><code>..</code></td><td>此运算符连接两个字符串。</td></tr>
</tbody></table>
<pre><code>string = &quot;Lua Tutorial&quot;

-- replacing strings
newstring = string.gsub(string,&quot;Tutorial&quot;,&quot;Language&quot;)
print(&quot;The new string is &quot;..newstring)

string = &quot;Lua Tutorial&quot;

-- replacing strings
print(string.find(string,&quot;Tutorial&quot;))
reversedString = string.reverse(string)
print(&quot;The new string is&quot;,reversedString)
</code></pre>
<h4 id="格式化字符串"><a class="header" href="#格式化字符串">格式化字符串</a></h4>
<pre><code>string1 = &quot;Lua&quot;
string2 = &quot;Tutorial&quot;

number1 = 10
number2 = 20

-- Basic string formatting
print(string.format(&quot;Basic formatting %s %s&quot;,string1,string2))

-- Date formatting
date = 2; month = 1; year = 2014
print(string.format(&quot;Date formatting %02d/%02d/%03d&quot;, date, month, year))

-- Decimal formatting
print(string.format(&quot;%.4f&quot;,1/3))
</code></pre>
<h4 id="字符和字节表示"><a class="header" href="#字符和字节表示">字符和字节表示</a></h4>
<pre><code>-- Byte conversion

-- First character
print(string.byte(&quot;Lua&quot;))

-- Third character
print(string.byte(&quot;Lua&quot;,3))

-- first character from last
print(string.byte(&quot;Lua&quot;,-1))

-- Second character
print(string.byte(&quot;Lua&quot;,2))

-- Second character from last
print(string.byte(&quot;Lua&quot;,-2))

-- Internal Numeric ASCII Conversion
print(string.char(97))
</code></pre>
<h4 id="其他常用函数"><a class="header" href="#其他常用函数">其他常用函数</a></h4>
<pre><code>string1 = &quot;Lua&quot;
string2 = &quot;Tutorial&quot;

-- String Concatenations using ..
print(&quot;Concatenated string&quot;,string1..string2)

-- Length of string
print(&quot;Length of string1 is &quot;,string.len(string1))

-- Repeating strings
repeatedString = string.rep(string1,3)
print(repeatedString)
</code></pre>
<h1 id="数组"><a class="header" href="#数组">数组</a></h1>
<h2 id="一维数组"><a class="header" href="#一维数组">一维数组</a></h2>
<pre><code class="language-lua">array = {&quot;Lua&quot;, &quot;Tutorial&quot;}

for i = 0, 2 do
   print(array[i])
end

array = {}

for i= -2, 2 do
   array[i] = i *2
end

for i = -2,2 do
   print(array[i])
end
</code></pre>
<h2 id="多维数组"><a class="header" href="#多维数组">多维数组</a></h2>
<p>多维数组有两种方式实现。它们分别如下 - </p>
<ul>
<li>数组的数组</li>
<li>通过操纵一维数组的索引</li>
</ul>
<pre><code class="language-lua">-- 初始化数组
array = {}

for i=1,3 do
   array[i] = {}

   for j=1,3 do
      array[i][j] = i*j
   end

end

-- 访问数组

for i=1,3 do

   for j=1,3 do
      print(array[i][j])
   end

end
</code></pre>
<p>下面使用操作索引显示多维数组的示例。</p>
<pre><code class="language-lua">-- 初始化数组

array = {}

maxRows = 3
maxColumns = 3

for row=1,maxRows do

   for col=1,maxColumns do
      array[row*maxColumns +col] = row*col
   end

end

-- 访问数组

for row=1,maxRows do

   for col=1,maxColumns do
      print(array[row*maxColumns +col])
   end

end
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="迭代器"><a class="header" href="#迭代器">迭代器</a></h1>
<h2 id="迭代器泛型"><a class="header" href="#迭代器泛型">迭代器泛型</a></h2>
<p>迭代器泛型提供集合中每个元素的键值对。 下面给出一个简单的例子。</p>
<pre><code class="language-lua">array = {&quot;Lua&quot;, &quot;Tutorial&quot;}

for key,value in ipairs(array) 
do
   print(key, value)
end


####输出
1  Lua
2  Tutorial
</code></pre>
<p>上面的例子使用了Lua提供的默认<code>ipairs</code>迭代器函数。</p>
<p>在Lua中，使用函数来表示迭代器。 基于这些迭代器函数中的状态维护，有两种主要类型 - </p>
<ul>
<li>无状态迭代器</li>
<li>有状态迭代器</li>
</ul>
<h2 id="无状态迭代器"><a class="header" href="#无状态迭代器">无状态迭代器</a></h2>
<pre><code class="language-lua">//迭代次数，初始值
function square(iteratorMaxCount,currentNumber)
//如果次数 小于给定最大次数
   if currentNumber&lt;iteratorMaxCount
   then
      currentNumber = currentNumber+1 //改变 currentNumber
      return currentNumber, currentNumber*currentNumber //返回当前值，以及控制值
   end

end

for i,n in square,3,0
do
   print(i,n)
end
</code></pre>
<pre><code class="language-lua">function square(iteratorMaxCount,currentNumber)

   if currentNumber&lt;iteratorMaxCount
   then
      currentNumber = currentNumber+1
      return currentNumber, currentNumber*currentNumber
   end

end

function squares(iteratorMaxCount)
   return square,iteratorMaxCount,0
end  

for i,n in squares(3)
do 
   print(i,n)
end
</code></pre>
<h2 id="有状态迭代器"><a class="header" href="#有状态迭代器">有状态迭代器</a></h2>
<pre><code class="language-lua">array = {&quot;Lua&quot;, &quot;Tutorial&quot;}

function elementIterator (collection)

   local index = 0
   local count = #collection

   -- The closure function is returned

   return function ()
      index = index + 1

      if index &lt;= count
      then
         -- return the current element of the iterator
         return collection[index]
      end

   end

end

for element in elementIterator(array)
do
   print(element)
end
</code></pre>
<p>可使用闭包创建函数迭代器，如上所示，它可以为迭代整个集合的每个时间返回多个元素。</p>
<h1 id="表"><a class="header" href="#表">表</a></h1>
<p>表是Lua中唯一可用的数据结构，使用表可以创建不同的类型，如数组和字典。 </p>
<p>Lua使用关联数组，不仅可使用数字编制索引，还可以使用除<code>nil</code>之外的字符串编制索引。 </p>
<p>表没有固定的大小，可以根据需要增长大小。</p>
<h2 id="表示和用法"><a class="header" href="#表示和用法">表示和用法</a></h2>
<p>表称为对象，它既不是值也不是变量。 Lua使用构造函数表达式<code>{}</code>来创建一个空表</p>
<pre><code>--sample table initialization
mytable = {}

--simple table value assignment
mytable[1]= &quot;Lua&quot;

--removing reference
mytable = nil

-- lua garbage collection will take care of releasing memory
</code></pre>
<pre><code class="language-lua">-- Simple empty table
mytable = {}
print(&quot;Type of mytable is &quot;,type(mytable))

mytable[1]= &quot;Lua&quot;
mytable[&quot;wow&quot;] = &quot;Tutorial&quot;

print(&quot;mytable Element at index 1 is &quot;, mytable[1])
print(&quot;mytable Element at index wow is &quot;, mytable[&quot;wow&quot;])

-- alternatetable and mytable refers to same table
alternatetable = mytable

print(&quot;alternatetable Element at index 1 is &quot;, alternatetable[1])
print(&quot;mytable Element at index wow is &quot;, alternatetable[&quot;wow&quot;])

alternatetable[&quot;wow&quot;] = &quot;I changed it&quot;

print(&quot;mytable Element at index wow is &quot;, mytable[&quot;wow&quot;])

-- only variable released and and not table
alternatetable = nil
print(&quot;alternatetable is &quot;, alternatetable)

-- mytable is still accessible
print(&quot;mytable Element at index wow is &quot;, mytable[&quot;wow&quot;])

mytable = nil
print(&quot;mytable is &quot;, mytable)
</code></pre>
<h2 id="表操作"><a class="header" href="#表操作">表操作</a></h2>
<p>下面是用于表操作的内置函数，它们列在下表格中。</p>
<table><thead><tr><th>编号</th><th>方法</th><th>作用</th></tr></thead><tbody>
<tr><td>1</td><td><code>table.concat (table [, sep [, i [, j]]])</code></td><td>根据给定的参数连接表中的字符串。详细信息请参见示例。</td></tr>
<tr><td>2</td><td><code>table.insert (table, [pos,] value)</code></td><td>在指定位置的表中插入值。</td></tr>
<tr><td>3</td><td><code>table.maxn (table)</code></td><td>返回最大的数字索引。</td></tr>
<tr><td>4</td><td><code>table.remove (table [, pos])</code></td><td>从表中删除值。</td></tr>
<tr><td>5</td><td><code>table.sort (table [, comp])</code></td><td>根据可选的比较器参数对表进行排序。</td></tr>
</tbody></table>
<h3 id="表连接"><a class="header" href="#表连接">表连接</a></h3>
<pre><code>fruits = {&quot;banana&quot;,&quot;orange&quot;,&quot;apple&quot;}

-- returns concatenated string of table
print(&quot;Concatenated string &quot;,table.concat(fruits))

--concatenate with a character
print(&quot;Concatenated string &quot;,table.concat(fruits,&quot;, &quot;))

--concatenate fruits based on index
print(&quot;Concatenated string &quot;,table.concat(fruits,&quot;, &quot;, 2,3))
</code></pre>
<h3 id="插入和删除"><a class="header" href="#插入和删除">插入和删除</a></h3>
<pre><code>fruits = {&quot;banana&quot;,&quot;orange&quot;,&quot;apple&quot;}

-- insert a fruit at the end
table.insert(fruits,&quot;mango&quot;)
print(&quot;Fruit at index 4 is &quot;,fruits[4])

--insert fruit at index 2
table.insert(fruits,2,&quot;grapes&quot;)
print(&quot;Fruit at index 2 is &quot;,fruits[2])

print(&quot;The maximum elements in table is&quot;,table.maxn(fruits))

print(&quot;The last element is&quot;,fruits[5])

table.remove(fruits)
print(&quot;The previous last element is&quot;,fruits[5])
</code></pre>
<h3 id="排序表"><a class="header" href="#排序表">排序表</a></h3>
<pre><code>fruits = {&quot;banana&quot;,&quot;orange&quot;,&quot;apple&quot;,&quot;grapes&quot;}

for k,v in ipairs(fruits) do
   print(k,v)
end

table.sort(fruits)
print(&quot;sorted table&quot;)

for k,v in ipairs(fruits) do
   print(k,v)
end
</code></pre>
<h1 id="模块"><a class="header" href="#模块">模块</a></h1>
<p>模块是一个可以使用<code>require</code>加载的库，并且只有一个包含表的全局名称。 模块可以包含许多功能和变量。 所有这些函数和变量都包含在表中，表充当命名空间。 此外，一个良好的模块有必要的子句，以在使用<code>require</code>语句时返回此表</p>
<h2 id="lua模块的特色"><a class="header" href="#lua模块的特色">Lua模块的特色</a></h2>
<pre><code class="language-lua">-- Assuming we have a module printFormatter
-- Also printFormatter has a funtion simpleFormat(arg)
-- Method 1
require &quot;printFormatter&quot;
printFormatter.simpleFormat(&quot;test&quot;)

-- Method 2
local formatter = require &quot;printFormatter&quot;
formatter.simpleFormat(&quot;test&quot;)

-- Method 3
require &quot;printFormatter&quot;
local formatterFunction = printFormatter.simpleFormat
formatterFunction(&quot;test&quot;)		
</code></pre>
<h2 id="require函数"><a class="header" href="#require函数">require函数</a></h2>
<p>Lua提供了一个名为<code>require</code>的高级函数来加载所有必需的模块。 它保持尽可能简单，以避免有太多关于模块的信息来加载。 <code>require</code>函数只是将模块假定为一块代码，它定义了一些值，实际上是包含函数或表。</p>
<pre><code class="language-lua">local mymath =  {}

function mymath.add(a,b)
   print(a+b)
end

function mymath.sub(a,b)
   print(a-b)
end

function mymath.mul(a,b)
   print(a*b)
end

function mymath.div(a,b)
   print(a/b)
end

return mymath
</code></pre>
<p>为了在另一个文件(例如，<code>moduletutorial.lua</code>)中访问此Lua模块</p>
<pre><code class="language-lua">mymathmodule = require(&quot;mymath&quot;)
mymathmodule.add(10,20)
mymathmodule.sub(30,20)
mymathmodule.mul(10,20)
mymathmodule.div(30,20)
</code></pre>
<p>要运行此代码，需要将两个Lua文件放在同一目录中，或者，可以将模块文件放在包路径中，它需要额外的设置</p>
<p><strong>注意事项</strong></p>
<ul>
<li>将运行的模块和文件放在同一目录中。</li>
<li>模块名称及其文件名应相同。</li>
<li>使用<code>require</code>函数返回模块，因此模块最好如上所示实现，尽管可以在其他地方找到其他类型的实现。</li>
</ul>
<h1 id="元表"><a class="header" href="#元表">元表</a></h1>
<p>元表(<code>metatable</code>)是一个表，它是使用键集和相关元方法来修改附加到的表的行为。 这些元方法是强大的Lua功能，可实现如下功能 - </p>
<ul>
<li>在表上更改/添加功能到操作符。</li>
<li>使用元表中的<code>__index</code>在表中没有键时查找元表。</li>
<li>类似于操作符的重载</li>
</ul>
<p>在处理元表时有两种重要的方法，包括 - </p>
<ul>
<li><code>setmetatable(table，metatable)</code> - 此方法用于为表设置元表。</li>
<li><code>getmetatable(table)</code> - 此方法用于获取表的元表。</li>
</ul>
<pre><code class="language-lua">mytable = {}
mymetatable = {}
setmetatable(mytable,mymetatable)
-- 等价于
mytable = setmetatable({},{})

</code></pre>
<h1 id="协同程序"><a class="header" href="#协同程序">协同程序</a></h1>
<p>协同程序本质上是协作的，它允许两种或多种方法以受控方式执行。 使用协同程序，在任何给定时间，只有一个协同程序运行，并且此运行协程仅在显式请求暂停时暂停执行。</p>
<p>上述定义可能看起来含糊不清。 假设有两种方法，一种是主程序方法，另一种是协程。 当使用<code>resume</code>函数调用一个协程时，它会开始执行，当调用<code>yield</code>函数时，它会暂停执行。 同样的协同程序可以继续执行另一个恢复函数调用，协同程序就会暂停。 该过程可以持续到协程执行结束。</p>
<h2 id="协同程序函数"><a class="header" href="#协同程序函数">协同程序函数</a></h2>
<p>下表列出了Lua中协程的所有可用函数及其相应的用法。</p>
<table><thead><tr><th>编号</th><th>方法</th><th>作用或目的</th></tr></thead><tbody>
<tr><td>1</td><td><code>coroutine.create (f)</code></td><td>使用函数<code>f</code>创建一个新的协同程序，并返回<code>thread</code>类型的对象。</td></tr>
<tr><td>2</td><td><code>coroutine.resume (co [, val1, ...])</code></td><td>恢复协程<code>co</code>并传递参数(如果有的话)。它返回操作状态和可选的其他返回值。</td></tr>
<tr><td>3</td><td><code>coroutine.running ()</code></td><td>如果在主线程中调用，则返回正在运行的协同程序或<code>nil</code>。</td></tr>
<tr><td>4</td><td><code>coroutine.status (co)</code></td><td>根据协同程序的状态返回<code>running</code>，<code>normal</code>，<code>suspended</code>或<code>dead</code>中的一个值。</td></tr>
<tr><td>5</td><td><code>coroutine.wrap (f)</code></td><td>与<code>coroutine.create</code>一样，<code>coroutine.wrap</code>函数也会创建一个协同程序，但它不会返回协同程序本身，而是返回一个函数，当调用它时，它会恢复协同程序。</td></tr>
<tr><td>6</td><td><code>coroutine.yield (...)</code></td><td>暂停正在运行的协同程序。 传递给此方法的参数充当<code>resume</code>函数的附加返回值。</td></tr>
</tbody></table>
<ul>
<li>value1`,value2的值由 第一次传递决定</li>
<li><em>coroutine.yield(value1+1,value2+1)</em> 负责将两个参数传递出去</li>
<li><em>coroutine.yield</em> 返回值 是由后续的 <em>resume</em> 调用决定</li>
</ul>
<pre><code class="language-lua">co = coroutine.create(function (value1,value2)
   local tempvar3 = 10
   print(&quot;coroutine section 1&quot;, value1, value2, tempvar3)

   local tempvar1 = coroutine.yield(value1+1,value2+1)
   tempvar3 = tempvar3 + value1
   print(&quot;coroutine section 2&quot;,tempvar1 ,tempvar2, tempvar3)

   local tempvar1, tempvar2= coroutine.yield(value1+value2, value1-value2)
   tempvar3 = tempvar3 + value1
   print(&quot;coroutine section 3&quot;,tempvar1,tempvar2, tempvar3)
   return value2, &quot;end&quot;

end)

print(&quot;main&quot;, coroutine.resume(co, 3, 2))
print(&quot;main&quot;, coroutine.resume(co, 12,14))
print(&quot;main&quot;, coroutine.resume(co, 5, 6))
print(&quot;main&quot;, coroutine.resume(co, 10, 20))
</code></pre>
<pre><code>coroutine section 1    3    2    10
main    true    4    3
coroutine section 2    12    nil    13
main    true    5    1
coroutine section 3    5    6    16
main    true    2    end
main    false    cannot resume dead coroutine
</code></pre>
<pre><code class="language-lua">function getNumber()
   local function getNumberHelper()
      co = coroutine.create(function ()
      coroutine.yield(1)
      coroutine.yield(2)
      coroutine.yield(3)
      coroutine.yield(4)
      coroutine.yield(5)
      end)
      return co
   end

   if(numberHelper) then
      status, number = coroutine.resume(numberHelper);

      if coroutine.status(numberHelper) == &quot;dead&quot; then
         numberHelper = getNumberHelper()
         status, number = coroutine.resume(numberHelper);
      end

      return number
   else
      numberHelper = getNumberHelper()
      status, number = coroutine.resume(numberHelper);
      return number
   end

end

for index = 1, 10 do
   print(index, getNumber())
end
</code></pre>
<h1 id="文件操作"><a class="header" href="#文件操作">文件操作</a></h1>
<pre><code>file = io.open (filename [, mode])
</code></pre>
<p>下表列出了各种文件模式 - </p>
<table><thead><tr><th>编号</th><th>模式</th><th>描述</th></tr></thead><tbody>
<tr><td>1</td><td><code>r</code></td><td>只读模式，是打开现有文件的默认模式。</td></tr>
<tr><td>2</td><td><code>w</code></td><td>写入启用模式，覆盖现有文件或创建新文件。</td></tr>
<tr><td>3</td><td><code>a</code></td><td>附加模式，用于打开现有文件或创建新文件以进行追加。</td></tr>
<tr><td>4</td><td><code>r+</code></td><td>现有文件的读写模式。</td></tr>
<tr><td>5</td><td><code>w+</code></td><td>如果文件存在或创建具有读写权限的新文件，则删除所有现有数据。</td></tr>
<tr><td>6</td><td><code>a+</code></td><td>启用了读取模式的追加模式可打开现有文件或创建新文件。</td></tr>
</tbody></table>
<h2 id="隐式文件描述符"><a class="header" href="#隐式文件描述符">隐式文件描述符</a></h2>
<pre><code class="language-lua">-- Opens a file in read
file = io.open(&quot;test.lua&quot;, &quot;r&quot;)

-- sets the default input file as test.lua
io.input(file)

-- prints the first line of the file
print(io.read())

-- closes the open file
io.close(file)

-- Opens a file in append mode
file = io.open(&quot;test.lua&quot;, &quot;a&quot;)

-- sets the default output file as test.lua
io.output(file)

-- appends a word test to the last line of the file
io.write(&quot;-- End of the test.lua file&quot;)

-- closes the open file
io.close(file)
</code></pre>
<p>在上面的示例中，可以使用<code>io.&quot;x&quot;</code>方法查看隐式描述符如何与文件系统一起使用。 上面的示例使用不带可选参数的<code>io.read()</code>方法。可选参数可以是以面中的任何一个。</p>
<table><thead><tr><th>编号</th><th>模式</th><th>描述</th></tr></thead><tbody>
<tr><td>1</td><td><code>*n</code></td><td>从当前文件位置读取并返回一个数字(如果存在于文件位置或返回<code>nil</code>)。</td></tr>
<tr><td>2</td><td><code>*a</code></td><td>从当前文件位置返回文件的所有内容。</td></tr>
<tr><td>3</td><td><code>*l</code></td><td>从当前文件位置读取行，并将文件位置移动到下一行。</td></tr>
<tr><td>4</td><td><code>number</code></td><td>读取函数中指定的字节数。</td></tr>
</tbody></table>
<p>其他常见的<strong>I/O</strong>方法包括，</p>
<ul>
<li><code>io.tmpfile()</code> - 返回一个临时文件，用于读取和写入，当程序退出，将删除该文件。</li>
<li><code>io.type(file)</code> - 根据输入文件返回文件，关闭文件或<code>nil</code>。</li>
<li><code>io.flush()</code> - 清除默认输出缓冲区。</li>
<li><code>io.lines(可选文件名)</code> - 提供循环迭代器的通用循环迭代器，循环遍历文件并最终关闭文件，以防提供文件名或使用默认文件而不在循环结束时关闭。</li>
</ul>
<h2 id="显式文件描述符"><a class="header" href="#显式文件描述符">显式文件描述符</a></h2>
<p>显式文件描述符经常使用，它允许一次操作多个文件。 这些函数与隐式文件描述符非常相似。 在这里，使用<code>file：function_name</code>，而不是<code>io.function_name</code>。 下面显示了以下相同隐式文件描述符示例的显式文件描述符版本示例</p>
<pre><code class="language-lua">-- Opens a file in read mode
file = io.open(&quot;test.lua&quot;, &quot;r&quot;)

-- prints the first line of the file
print(file:read())

-- closes the opened file
file:close()

-- Opens a file in append mode
file = io.open(&quot;test.lua&quot;, &quot;a&quot;)

-- appends a word test to the last line of the file
file:write(&quot;--test&quot;)

-- closes the open file
file:close()
</code></pre>
<h2 id="其他常见的文件方法"><a class="header" href="#其他常见的文件方法">其他常见的文件方法</a></h2>
<p><code>file:seek(optional whence, optional offset)</code> - 参数是<code>set</code>，<code>cur</code>或<code>end</code>。 使用文件开头的更新文件位置设置新文件指针。 在此函数中，偏移量为零。 如果第一个参数是<code>set</code>，则从文件的开头测量偏移量; 从文件中的当前位置开始，如果它是<code>cur</code>; 或者从文件的末尾开始，则它是<code>end</code>。 默认参数值为<code>cur</code>和<code>0</code>，因此可以通过不带参数调用此函数来获取当前文件位置。</p>
<p><code>file:flush()</code> − 清除默认输出缓冲区。</p>
<p><code>io.lines(optional file name)</code> - 提供循环迭代器的通用循环迭代器，循环遍历文件并最终关闭文件</p>
<pre><code class="language-lua">-- Opens a file in read
file = io.open(&quot;test.lua&quot;, &quot;r&quot;)

file:seek(&quot;end&quot;,-25)
print(file:read(&quot;*a&quot;))

-- closes the opened file
file:close()
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="变量-2"><a class="header" href="#变量-2">变量</a></h1>
<h2 id="变量语法"><a class="header" href="#变量语法">变量语法</a></h2>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 自动类型推断语法
let x = 5;

//完整语法 ,指定数据类型
let y: f32 = 3.0; // f32
<span class="boring">}
</span></code></pre></pre>
<h2 id="变量与可变性"><a class="header" href="#变量与可变性">变量与可变性</a></h2>
<ul>
<li>在<em>Rust</em> 中 变量默认是不可改变的（immutable）</li>
<li>不能对不可变变量 x 二次赋值</li>
<li>使用 <em>mut</em> 声明可变变量 <em>let mut x = 5;</em></li>
</ul>
<h2 id="变量和常量"><a class="header" href="#变量和常量">变量和常量</a></h2>
<ul>
<li>常量是绑定到一个名称的不允许改变的值</li>
<li>常量不光默认不能变，它总是不能变。</li>
<li>声明常量使用 <code>const</code> 关键字而不是 <code>let</code>，并且 <em>必须</em> 注明值的类型</li>
<li>常量只能被设置为常量表达式，而不能是函数调用的结果，或任何其他只能在运行时计算出的值。</li>
<li>example: <em>const MAX_POINTS: u32 = 100_000;</em></li>
</ul>
<h2 id="隐藏shadowing"><a class="header" href="#隐藏shadowing">隐藏（Shadowing）</a></h2>
<ul>
<li>我们可以定义一个与之前变量同名的新变量，而新变量会 <strong>隐藏</strong> 之前的变量</li>
<li>这意味着使用这个变量时会看到第二个值。可以用相同变量名称来隐藏一个变量，以及重复使用 <code>let</code> 关键字来多次隐藏，</li>
<li>隐藏使我们不必使用不同的名字</li>
<li>example</li>
</ul>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let x = 5;

    let x = x + 1;

    let x = x * 2;

    println!(&quot;The value of x is: {}&quot;, x);
}
</code></pre></pre>
<h1 id="数据类型-1"><a class="header" href="#数据类型-1">数据类型</a></h1>
<blockquote>
<p>在 Rust 中，每一个值都属于某一个 <strong>数据类型</strong>（<em>data type</em>），两类数据类型子集：标量（scalar）和复合（compound）。</p>
</blockquote>
<p><strong>Rust 是 静态类型（<em>statically typed</em>）语言</strong></p>
<p>也就是说在编译时就必须知道所有变量的类型。根据值及其使用方式，编译器通常可以推断出我们想要用的类型。当多种类型均有可能时</p>
<p>必须增加类型注解 <code>let guess: u32 = &quot;42&quot;.parse().expect(&quot;Not a number!&quot;);</code></p>
<h2 id="标量类型"><a class="header" href="#标量类型">标量类型</a></h2>
<p>Rust 有四种基本的标量类型：<em>整型</em>、<em>浮点型</em>、<em>布尔类型</em> <em>字符类型</em></p>
<h3 id="整型"><a class="header" href="#整型">整型</a></h3>
<table><thead><tr><th>长度</th><th>有符号</th><th>无符号</th></tr></thead><tbody>
<tr><td>8-bit</td><td><code>i8</code></td><td><code>u8</code></td></tr>
<tr><td>16-bit</td><td><code>i16</code></td><td><code>u16</code></td></tr>
<tr><td>32-bit</td><td><code>i32</code></td><td><code>u32</code></td></tr>
<tr><td>64-bit</td><td><code>i64</code></td><td><code>u64</code></td></tr>
<tr><td>128-bit</td><td><code>i128</code></td><td><code>u128</code></td></tr>
<tr><td>arch</td><td><code>isize</code></td><td><code>usize</code></td></tr>
</tbody></table>
<p><code>isize</code> 和 <code>usize</code> 类型依赖运行程序的计算机架构：64 位架构上它们是 64 位的， 32 位架构上它们是 32 位的。</p>
<h3 id="整型字面量"><a class="header" href="#整型字面量">整型字面量</a></h3>
<table><thead><tr><th>数字字面值</th><th>例子</th></tr></thead><tbody>
<tr><td>Decimal (十进制)</td><td><code>98_222</code></td></tr>
<tr><td>Hex (十六进制)</td><td><code>0xff</code></td></tr>
<tr><td>Octal (八进制)</td><td><code>0o77</code></td></tr>
<tr><td>Binary (二进制)</td><td><code>0b1111_0000</code></td></tr>
<tr><td>Byte (单字节字符)(仅限于<code>u8</code>)</td><td><code>b'A'</code></td></tr>
</tbody></table>
<p>Rust 数字类型默认是 <code>i32</code>：它通常是最快的，甚至在 64 位系统上也是。<code>isize</code> 或 <code>usize</code> 主要作为某些集合的索引。</p>
<h3 id="整型溢出"><a class="header" href="#整型溢出">整型溢出</a></h3>
<p>比方说有一个 <code>u8</code> ，它可以存放从零到 <code>255</code> 的值。那么当你将其修改为 <code>256</code> 时会发生什么呢？这被称为 “整型溢出”（“integer overflow” ），关于这一行为 Rust 有一些有趣的规则。当在 debug 模式编译时，Rust 检查这类问题并使程序 <em>panic</em>，这个术语被 Rust 用来表明程序因错误而退出。第九章 <a href="https://kaisery.github.io/trpl-zh-cn/ch09-01-unrecoverable-errors-with-panic.html">“<code>panic!</code> 与不可恢复的错误”</a> 部分会详细介绍 panic。</p>
<p>在 release 构建中，Rust 不检测溢出，相反会进行一种被称为二进制补码包装（<em>two’s complement wrapping</em>）的操作。简而言之，<code>256</code> 变成 <code>0</code>，<code>257</code> 变成 <code>1</code>，依此类推。依赖整型溢出被认为是一种错误，即便可能出现这种行为。如果你确实需要这种行为，标准库中有一个类型显式提供此功能，<a href="https://kaisery.github.io/std/num/struct.Wrapping.html"><code>Wrapping</code></a>。</p>
<h3 id="浮点"><a class="header" href="#浮点">浮点</a></h3>
<p>两个原生的 <strong>浮点数</strong>（<em>floating-point numbers</em>）类型，它们是带小数点的数字。Rust 的浮点数类型是 <code>f32</code> 和 <code>f64</code>，分别占 32 位和 64 位。默认类型是 <code>f64</code>，因为在现代 CPU 中，它与 <code>f32</code> 速度几乎一样，不过精度更高。</p>
<h3 id="布尔类型"><a class="header" href="#布尔类型">布尔类型</a></h3>
<pre><code> let f: bool = false; // 显式指定类型注解
</code></pre>
<h3 id="字符类型"><a class="header" href="#字符类型">字符类型</a></h3>
<pre><code>fn main() {
    let c = 'z';
    let z = 'ℤ';
    let heart_eyed_cat = '😻';
}
</code></pre>
<p>Rust 的 <code>char</code> 类型的<strong>大小为四个字节</strong>(four bytes)，并代表了一个 Unicode 标量值（Unicode Scalar Value），这意味着它可以比 ASCII 表示更多内容。在 Rust 中，拼音字母（Accented letters），中文、日文、韩文等字符，emoji（绘文字）以及零长度的空白字符都是有效的 <code>char</code> 值。Unicode 标量值包含从 <code>U+0000</code> 到 <code>U+D7FF</code> 和 <code>U+E000</code> 到 <code>U+10FFFF</code> 在内的值。</p>
<h2 id="复合类型"><a class="header" href="#复合类型">复合类型</a></h2>
<blockquote>
<p>可以将多个值组合成一个类型。Rust 有两个原生的复合类型：元组（tuple）和数组（array）。</p>
</blockquote>
<h3 id="元组类型"><a class="header" href="#元组类型">元组类型</a></h3>
<ul>
<li>元组长度固定：一旦声明，其长度不会增大或缩小。</li>
<li>圆括号中的逗号分隔的值列表来创建一个元组</li>
<li>元组中的每一个位置都有一个类型，而且这些不同值的类型也不必是相同的</li>
</ul>
<p><strong>元组解构取值</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let tup = (500, 6.4, 1);

    let (x, y, z) = tup;

    println!(&quot;The value of y is: {}&quot;, y);
<span class="boring">}
</span></code></pre></pre>
<p><code>.</code> 号取值</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 也可以使用点号（.）后跟值的索引来直接访问它们
 let x: (i32, f64, u8) = (500, 6.4, 1);

    let five_hundred = x.0;

    let six_point_four = x.1;

    let one = x.2;
<span class="boring">}
</span></code></pre></pre>
<h3 id="数组类型"><a class="header" href="#数组类型">数组类型</a></h3>
<blockquote>
<p>数组中的每个元素的类型必须相同</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let a = [1, 2, 3, 4, 5];
let a: [i32; 5] = [1, 2, 3, 4, 5];
// let a = [elea-value; array-length]
let a = [3; 5];
<span class="boring">}
</span></code></pre></pre>
<h1 id="函数-1"><a class="header" href="#函数-1">函数</a></h1>
<ul>
<li><code>main</code> 函数，它是很多程序的入口点</li>
<li><code>fn</code> 关键字，它用来声明新函数</li>
<li>Rust 代码中的函数和变量名使用 <em>snake case</em> 规范风格。在 snake case 中，所有字母都是小写并使用下划线分隔单词。这是一个包含函数定义示例的程序：</li>
</ul>
<h3 id="函数参数"><a class="header" href="#函数参数">函数参数</a></h3>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn another_function(x: i32, y: i32) {
    println!(&quot;The value of x is: {}&quot;, x);
    println!(&quot;The value of y is: {}&quot;, y);
}
<span class="boring">}
</span></code></pre></pre>
<h3 id="包含语句和表达式的函数体"><a class="header" href="#包含语句和表达式的函数体">包含语句和表达式的函数体</a></h3>
<ul>
<li>
<p>语句不返回值</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span> let x = (let y = 6);
<span class="boring">}
</span></code></pre></pre>
</li>
<li>
<p>表达式会计算出一些值  <code>并且你将编写的大部分 Rust 代码是由表达式组成的</code>。</p>
<ul>
<li>
<p>考虑一个简单的数学运算，比如 <code>5 + 6</code>，这是一个表达式并计算出值 <code>11</code>。</p>
</li>
<li>
<p>表达式可以是语句的一部分：在示例 3-1 中，语句 <code>let y = 6;</code> 中的 <code>6</code> 是一个表达式，它计算出的值是 <code>6</code>。</p>
</li>
<li>
<p>函数调用是一个表达式。</p>
</li>
<li>
<p>宏调用是一个表达式。</p>
</li>
<li>
<p>我们用来创建新作用域的大括号（代码块），<code>{}</code>，也是一个表达式，例如：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span> let y = {
        let x = 3;
        x + 1
    };
<span class="boring">}
</span></code></pre></pre>
</li>
</ul>
</li>
</ul>
<h3 id="函数返回值"><a class="header" href="#函数返回值">函数返回值</a></h3>
<pre><pre class="playground"><code class="language-rust">fn five() -&gt; i32 {
    5
}
fn main() {
    let x = five();
    println!(&quot;The value of x is: {}&quot;, x);
}
</code></pre></pre>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>//x+1 因为加上了分号 从表达式 变成了 语句
fn plus_one(x: i32) -&gt; i32 {
    x + 1;
}
如果函数没有返回值,则 使用空元组 () 返回
<span class="boring">}
</span></code></pre></pre>
<h1 id="控制流"><a class="header" href="#控制流">控制流</a></h1>
<h2 id="if"><a class="header" href="#if">if</a></h2>
<blockquote>
<p>表达式 <strong>必须</strong> 是 <code>bool</code> 值</p>
</blockquote>
<pre><code>    if number &lt; 5 {
        println!(&quot;condition was true&quot;);
    } else {
        println!(&quot;condition was false&quot;);
    }
</code></pre>
<h3 id="if同时也是一个表达式"><a class="header" href="#if同时也是一个表达式">if同时也是一个表达式</a></h3>
<blockquote>
<p><code>if</code> 和 <code>else</code> 分支的值类型必须相同</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let number = if condition {
        5
    } else {
        6
    };

//error_example
  let condition = true;

    let number = if condition {
        5
    } else {
        &quot;six&quot;
    };
<span class="boring">}
</span></code></pre></pre>
<h2 id="循环-1"><a class="header" href="#循环-1">循环</a></h2>
<h3 id="loop"><a class="header" href="#loop"><em>Loop</em></a></h3>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span>
<span class="boring">fn main() {
</span>loop {
        println!(&quot;again!&quot;);
    }

//循环返回,loop也是一个表达式
 let result = loop {
        counter += 1;

        if counter == 10 {
            break counter * 2;
        }
    };


<span class="boring">}
</span></code></pre></pre>
<h3 id="while"><a class="header" href="#while"><em>while</em></a></h3>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span> let mut number = 3;

    while number != 0 {
        println!(&quot;{}!&quot;, number);

        number = number - 1;
    }
<span class="boring">}
</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>  let a = [10, 20, 30, 40, 50];
    let mut index = 0;

    while index &lt; 5 {
        println!(&quot;the value is: {}&quot;, a[index]);

        index = index + 1;
    }
<span class="boring">}
</span></code></pre></pre>
<h3 id="for迭代"><a class="header" href="#for迭代">For迭代</a></h3>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let a = [10, 20, 30, 40, 50];

    for element in a.iter() {
        println!(&quot;the value is: {}&quot;, element);
    }
}
</code></pre></pre>
<p><strong>反转</strong></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    for number in (1..4).rev() {
        println!(&quot;{}!&quot;, number);
    }
    println!(&quot;LIFTOFF!!!&quot;);
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="认识所有权"><a class="header" href="#认识所有权">认识所有权</a></h1>
<blockquote>
<p>所有权（系统）是 Rust 最为与众不同的特性，它让 Rust 无需垃圾回收（garbage collector）即可保障内存安全。因此，理解 Rust 中所有权如何工作是十分重要的。本章，我们将讲到所有权以及相关功能：借用、slice 以及 Rust 如何在内存中布局数据。</p>
</blockquote>
<p><strong>变量的所有权总是遵循相同的模式：将值赋给另一个变量时移动它</strong></p>
<h1 id="所有权"><a class="header" href="#所有权">所有权</a></h1>
<h2 id="规则"><a class="header" href="#规则"><strong>规则</strong></a></h2>
<ol>
<li>Rust 中的每一个值都有一个被称为其 <strong>所有者</strong>（<em>owner</em>）的变量。</li>
<li>值在任一时刻有且只有一个所有者。</li>
<li>当所有者（变量）离开作用域，这个值将被丢弃。</li>
</ol>
<h2 id="变量作用域"><a class="header" href="#变量作用域"><strong>变量作用域</strong></a></h2>
<blockquote>
<p>变量 <code>s</code> 绑定到了一个字符串字面值，这个字符串值是硬编码进程序代码中的。这个变量从声明的点开始直到当前 <strong>作用域</strong> 结束时都是有效的</p>
</blockquote>
<pre><code>{                      // s 在这里无效, 它尚未声明
    let s = &quot;hello&quot;;   // 从此处起，s 是有效的

    // 使用 s
}                      // 此作用域已结
</code></pre>
<h2 id="string类型"><a class="header" href="#string类型"><strong>String类型</strong></a></h2>
<pre><code>// 这两个冒号（::）是运算符，允许将特定的 from 函数置于 String 类型的命名空间（namespace）
let s = String::from(&quot;hello&quot;);
</code></pre>
<p>内存在拥有它的变量离开作用域后就被自动释放。下面是示例 4-1 中作用域例子的一个使用 <code>String</code> 而不是字符串字面值的版本：</p>
<p>这是一个将 <code>String</code> 需要的内存返回给操作系统的很自然的位置：当 <code>s</code> 离开作用域的时候。当变量离开作用域，Rust 为我们调用一个特殊的函数。这个函数叫做 <code>drop</code>，在这里 <code>String</code> 的作者可以放置释放内存的代码。<strong>Rust 在结尾的 <code>}</code> 处自动调用 <code>drop</code>。</strong></p>
<h2 id="变量与数据交互的方式"><a class="header" href="#变量与数据交互的方式">变量与数据交互的方式</a></h2>
<h3 id="移动"><a class="header" href="#移动">移动</a></h3>
<pre><code>//基础类型是 移动
let x = 5;
let y = x;
</code></pre>
<p>引用类型的<em>移动</em></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span>
<span class="boring">fn main() {
</span>let s1 = String::from(&quot;hello&quot;);
let s2 = s1; //赋值给s1之后s1不在有效,编译器禁止使用 s1
<span class="boring">}
</span></code></pre></pre>
<h3 id="克隆"><a class="header" href="#克隆">克隆</a></h3>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s1 = String::from(&quot;hello&quot;);
let s2 = s1.clone();

println!(&quot;s1 = {}, s2 = {}&quot;, s1, s2);
<span class="boring">}
</span></code></pre></pre>
<ul>
<li>
<p>Rust 有一个叫做 <code>Copy</code> trait 的特殊注解,可以用在类似整型这样的存储在栈上的类型上</p>
</li>
<li>
<p>如果一个类型拥有 <code>Copy</code> trait，一个旧的变量在将其赋值给其他变量后仍然可用</p>
</li>
<li>
<p>Rust 不允许自身或其任何部分实现了 <code>Drop</code> trait 的类型使用 <code>Copy</code> trait</p>
</li>
<li>
<p>要学习如何为你的类型增加 <code>Copy</code> 注解，请阅读附录 C 中的 <a href="https://kaisery.github.io/trpl-zh-cn/appendix-03-derivable-traits.html">“可派生的 trait”</a>。</p>
</li>
</ul>
<p>任何简单标量值的组合可以是 <code>Copy</code> 的，不需要分配内存或某种形式资源的类型是 <code>Copy</code> 的。如下是一些 <code>Copy</code> 的类型：</p>
<ul>
<li>所有整数类型，比如 <code>u32</code>。</li>
<li>布尔类型，<code>bool</code>，它的值是 <code>true</code> 和 <code>false</code>。</li>
<li>所有浮点数类型，比如 <code>f64</code>。</li>
<li>字符类型，<code>char</code>。</li>
<li>元组，当且仅当其包含的类型也都是 <code>Copy</code> 的时候。比如，<code>(i32, i32)</code> 是 <code>Copy</code> 的，但 <code>(i32, String)</code> 就不是。</li>
</ul>
<h2 id="所有权与函数"><a class="header" href="#所有权与函数">所有权与函数</a></h2>
<blockquote>
<p>将值传递给函数在语义上与给变量赋值相似。向函数传递值可能会移动或者复制，就像赋值语句一样。</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let s = String::from(&quot;hello&quot;);  // s 进入作用域

    takes_ownership(s);             // s 的值移动到函数里 ...
                                    // ... 所以到这里不再有效

    let x = 5;                      // x 进入作用域

    makes_copy(x);                  // x 应该移动函数里，
                                    // 但 i32 是 Copy 的，所以在后面可继续使用 x

} // 这里, x 先移出了作用域，然后是 s。但因为 s 的值已被移走，
  // 所以不会有特殊操作

fn takes_ownership(some_string: String) { // some_string 进入作用域
    println!(&quot;{}&quot;, some_string);
} // 这里，some_string 移出作用域并调用 `drop` 方法。占用的内存被释放

fn makes_copy(some_integer: i32) { // some_integer 进入作用域
    println!(&quot;{}&quot;, some_integer);
} // 这里，some_integer 移出作用域。不会有特殊操作

</code></pre></pre>
<h1 id="引用与借用"><a class="header" href="#引用与借用">引用与借用</a></h1>
<h2 id="引用与借用-1"><a class="header" href="#引用与借用-1">引用与借用</a></h2>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let s1 = String::from(&quot;hello&quot;);

    let len = calculate_length(&amp;s1);

    println!(&quot;The length of '{}' is {}.&quot;, s1, len);
}

fn calculate_length(s: &amp;String) -&gt; usize {
    s.len()
}
</code></pre></pre>
<p>其次，注意我们传递 <code>&amp;s1</code> 给 <code>calculate_length</code>，同时在函数定义中，我们获取 <code>&amp;String</code> 而不是 <code>String</code>。</p>
<p>与使用 <code>&amp;</code> 引用相反的操作是 <strong>解引用</strong>（<em>dereferencing</em>），它使用解引用运算符，<code>*</code>。我们将会在第八章遇到一些解引用运算符，并在第十五章详细讨论解引用。</p>
<p>同理，函数签名使用 <code>&amp;</code> 来表明参数 <code>s</code> 的类型是一个引用。让我们增加一些解释性的注释：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn calculate_length(s: &amp;String) -&gt; usize { // s 是对 String 的引用
    s.len()
} // 这里，s 离开了作用域。但因为它并不拥有引用值的所有权，
  // 所以什么也不会发生
<span class="boring">}
</span></code></pre></pre>
<p>我们将获取引用作为函数参数称为 <strong>借用</strong>（<em>borrowing</em>）。</p>
<pre><code>正如变量默认是不可变的，引用也一样。（默认）不允许修改引用的值
</code></pre>
<h2 id="可变引用"><a class="header" href="#可变引用"><strong>可变引用</strong></a></h2>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn change(some_string: &amp;mut String) {
    some_string.push_str(&quot;, world&quot;);
}
<span class="boring">}
</span></code></pre></pre>
<ul>
<li>当有可变引用时 只能存在一个,其他的都会失效,不可用</li>
</ul>
<h2 id="悬垂引用"><a class="header" href="#悬垂引用"><strong>悬垂引用</strong></a></h2>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>//报错 s已经被释放了
fn dangle() -&gt; &amp;String {
    let s = String::from(&quot;hello&quot;);

    &amp;s
}
//正确,所有权被移动出去，所以没有值被释放
fn no_dangle() -&gt; String {
    let s = String::from(&quot;hello&quot;);

    s
}
<span class="boring">}
</span></code></pre></pre>
<ul>
<li>在任意给定时间，<strong>要么</strong> 只能有一个可变引用，<strong>要么</strong> 只能有多个不可变引用。</li>
<li>引用必须总是有效的。</li>
</ul>
<h2 id="slice引用"><a class="header" href="#slice引用"><strong>slice引用</strong></a></h2>
<blockquote>
<p>slice 允许你引用集合中一段连续的元素序列，而不用引用整个集合。</p>
<p>拥有某值的不可变引用时，就不能再获取一个可变引用</p>
</blockquote>
<p><em>字符串slice</em></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span>
<span class="boring">fn main() {
</span>let s = String::from(&quot;hello world&quot;);
let hello = &amp;s[0..5];
let world = &amp;s[6..11];
<span class="boring">}
</span></code></pre></pre>
<p><strong>range 语法</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s = String::from(&quot;hello&quot;);

let slice = &amp;s[0..2];
let slice = &amp;s[..2];

let slice = &amp;s[0..len];
let slice = &amp;s[..];
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="constants-vs-variables"><a class="header" href="#constants-vs-variables">Constants v/s Variables</a></h2>
<ul>
<li>常量使用  const关键字 声明，变量使用 let关键字申明</li>
<li>变量得类型是可选的，常量的类型是必选的</li>
<li>let关键字申明的变量是默认 不可变的。也可以使用 mut关键字 使之可变，常量始终不可变</li>
<li>常量只能通过 constant expression设置。不能通过 函数调用、或者其他运行时 计算表达式</li>
<li>常量可以申明在 任何作用域</li>
<li>变量可以被重复定义，后定义的变量覆盖前面的定义，常量不可以</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="介绍"><a class="header" href="#介绍">介绍</a></h2>
<p>本文将会探讨 从  已知大小类型(<code>sized type</code>)、未知大小类型(<code>unsized type</code>)、在到 零大小类型(<code>zero type</code>)等各种类型的 sizedness，并同时对他们的优点 、缺点、痛点、以及解决方法进行评估</p>
<p><strong>以下是文中的术语表格</strong></p>
<table><thead><tr><th>术语</th><th>含义</th></tr></thead><tbody>
<tr><td>sizedness</td><td>不同大小类型的特性</td></tr>
<tr><td>sized type</td><td>编译期可以确定大小的类型</td></tr>
<tr><td>unsized type or DST</td><td>动态大小类型</td></tr>
<tr><td>?sized type</td><td>可能确定也可能不确定的大小类型</td></tr>
<tr><td>unsized coercion</td><td>从确定大小类型转换为 不确定大小类型</td></tr>
<tr><td>zst</td><td>零大小类型</td></tr>
<tr><td>width</td><td>指针的宽度的单位</td></tr>
<tr><td>thin point|single width point</td><td>1个宽度的指针</td></tr>
<tr><td>fat point | double-width point</td><td>2个宽度的指针</td></tr>
<tr><td>slice</td><td>数据的动态大小视图</td></tr>
</tbody></table>
<h2 id="sizedness"><a class="header" href="#sizedness">Sizedness</a></h2>
<ul>
<li>如果一个类型 的大小能在编译期确定，也称作 sizedType,那确定类型大小的类型就能在 栈上分配空间。数据的传递也就能通过 值传递或者引用传递的方式</li>
<li>如果一个类型的大小不能在编译期确定，也叫作，dst、动态类型大小。无法在栈上分配空间。数据的传递只能通过引用传递</li>
</ul>
<p>以下是一些 <strong>sized type</strong>或者 <strong>unsized type</strong></p>
<ul>
<li>基本类型</li>
<li>元祖类型</li>
<li>结构体类型</li>
<li>数组类型：固定数组类型、不固定数组类型</li>
<li>枚举类型</li>
<li>普通指针、字符串指针、数组指针</li>
<li>trait类型</li>
<li>自定义 unsized类型</li>
</ul>
<pre><pre class="playground"><code class="language-rust">use std::mem::size_of;

fn main() {
    // primitives
    assert_eq!(4, size_of::&lt;i32&gt;());
    assert_eq!(8, size_of::&lt;f64&gt;());

    // tuples
    assert_eq!(8, size_of::&lt;(i32, i32)&gt;());

    // arrays
    assert_eq!(0, size_of::&lt;[i32; 0]&gt;());
    assert_eq!(12, size_of::&lt;[i32; 3]&gt;());

    struct Point {
        x: i32,
        y: i32,
    }

    // structs
    assert_eq!(8, size_of::&lt;Point&gt;());

    // enums
    assert_eq!(8, size_of::&lt;Option&lt;i32&gt;&gt;());

    // get pointer width, will be
    // 4 bytes wide on 32-bit targets or
    // 8 bytes wide on 64-bit targets
    const WIDTH: usize = size_of::&lt;&amp;()&gt;();

    // pointers to sized types are 1 width
    assert_eq!(WIDTH, size_of::&lt;&amp;i32&gt;());
    assert_eq!(WIDTH, size_of::&lt;&amp;mut i32&gt;());
    assert_eq!(WIDTH, size_of::&lt;Box&lt;i32&gt;&gt;());
    assert_eq!(WIDTH, size_of::&lt;fn(i32) -&gt; i32&gt;());

    const DOUBLE_WIDTH: usize = 2 * WIDTH;

    // unsized struct
    struct Unsized {
        unsized_field: [i32],
    }

    // pointers to unsized types are 2 widths
    assert_eq!(DOUBLE_WIDTH, size_of::&lt;&amp;str&gt;()); // slice
    assert_eq!(DOUBLE_WIDTH, size_of::&lt;&amp;[i32]&gt;()); // slice
    assert_eq!(DOUBLE_WIDTH, size_of::&lt;&amp;dyn ToString&gt;()); // trait object
    assert_eq!(DOUBLE_WIDTH, size_of::&lt;Box&lt;dyn ToString&gt;&gt;()); // trait object
    assert_eq!(DOUBLE_WIDTH, size_of::&lt;&amp;Unsized&gt;()); // user-defined unsized type

    // unsized types
    size_of::&lt;str&gt;(); // compile error
    size_of::&lt;[i32]&gt;(); // compile error
    size_of::&lt;dyn ToString&gt;(); // compile error
    size_of::&lt;Unsized&gt;(); // compile error
}
</code></pre></pre>
<h2 id="protips"><a class="header" href="#protips">proTIPS</a></h2>
<ul>
<li>rust中 指向数组的动态大小视图 <code>dynamic sized view</code> 被称为 切片（<em>slice</em>）,&amp;str是字符串切片、&amp;[i32] 是数组切片</li>
<li>切片是双宽度的、因为它们存储了 指向 数组的 指针 和 数组中元素的个数</li>
<li>trait对象是 双宽度的，因为它们 存储了 指向 数据的指针 和 指向  vnode的指针</li>
<li>不确定大小的结构体是 双宽的。因为 它拥有 指针指向 结构体的指针 和 结构体大小的size</li>
<li>不确定大小的结构体 只能拥有 一个 不确定大小的 字段 且 只能是 结构体最后一个字段</li>
</ul>
<p><strong>总结</strong></p>
<ul>
<li>确定大小的 类型可以 分配在 栈上。可以通过值传递</li>
<li>不确定大小的类型不能分配在栈上，且必须通过 引用传递</li>
<li>不确定大小的类型是双宽度的，除了要记录 指针位置外，还需要记录 数据量大小、或者 vnodetable等</li>
</ul>
<h2 id="trait对象trait-objects"><a class="header" href="#trait对象trait-objects">Trait对象(Trait Objects)</a></h2>
<p>Traits默认是<code>?Sized</code>。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Trait: ?Sized {}


trait Trait where Self: ?Sized {}
<span class="boring">}
</span></code></pre></pre>
<ol>
<li>
<p>默认情况下，trait允许<code>self</code>可能是一个不确定大小类型(unsized type)</p>
</li>
<li>
<p>不确定大小类型无法 通过 值传递，所以没法以传值的方式 接收 或返回 <strong>self</strong> </p>
</li>
<li>
<p>但是是 可以编译，如果一旦为这个方法 提供默认的实现，或者实现其他的 都会编译错误</p>
</li>
<li>
<p>可以通过 引用传递方式 传递 <code>self</code></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Trait {
    fn method(&amp;self) {} // compiles
}

impl Trait for str {
    fn method(&amp;self) {} // compiles
}
<span class="boring">}
</span></code></pre></pre>
</li>
<li>
<p>可以有更细粒度和更精确的选择 来标记 单个方法 为 <code>Sized</code></p>
<pre><pre class="playground"><code class="language-rust">trait Trait {
    fn method(self) where Self: Sized {}
}

impl Trait for str {} // compiles!?

fn main() {
    &quot;str&quot;.method(); // compile error
}
</code></pre></pre>
</li>
</ol>
<h2 id="trait对象的限制trait-object-limitations"><a class="header" href="#trait对象的限制trait-object-limitations">Trait对象的限制(Trait Object Limitations)</a></h2>
<p>即使一个trait是对象安全的，仍然存在sizeness相关的边界情况，这些情况限制了什么类型可以转成trait对象以及多少种trait和什么样的trait可以通过一个trait对象来表示。</p>
<h3 id="不能把不确定大小类型unsized-type转成trait对象"><a class="header" href="#不能把不确定大小类型unsized-type转成trait对象">不能把不确定大小类型(unsized type)转成trait对象</a></h3>
<table><thead><tr><th>类型</th><th>指向数据的指针</th><th>数据长度</th><th>指向Vtable的指针</th><th>总长度</th></tr></thead><tbody>
<tr><td>&amp;String</td><td>有</td><td>没有</td><td>没有</td><td>1w</td></tr>
<tr><td>&amp;str</td><td>有</td><td>有</td><td>没有</td><td>2w</td></tr>
<tr><td>&amp;String as &amp; dyn ToString</td><td>有</td><td>没有</td><td>有</td><td>2w</td></tr>
<tr><td>&amp;str as &amp; &amp;dyn ToString</td><td>有</td><td>有</td><td>有</td><td>3w</td></tr>
</tbody></table>
<h3 id="不能创建多trait的对象cannot-create-multi-trait-objects"><a class="header" href="#不能创建多trait的对象cannot-create-multi-trait-objects">不能创建多Trait的对象(Cannot create Multi-Trait Objects)</a></h3>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Trait {}
trait Trait2 {}

fn function(t: &amp;(dyn Trait + Trait2)) {}
<span class="boring">}
</span></code></pre></pre>
<ul>
<li>一个trait对象指针是双宽度的:存储一个指向数据的指针、和指向vttable的指针</li>
<li>这里有 两个 Trait 就存在 指向 两个vtable的 指针  &amp;(dyn Trait+Trait2) 就是三宽度 ，rust最多支持 两个宽度的指针</li>
<li>像 Sync 与 Send 这样的 Trait不存在 方法，所以可以有多个</li>
<li>解决办法是，借助第三个 Trait实现 上述 两个 Trait,但是也会存在 无法自动向上转型</li>
</ul>
<pre><pre class="playground"><code class="language-rust">trait Trait {
    fn method(&amp;self) {}
}

trait Trait2 {
    fn method2(&amp;self) {}
}

trait Trait3: Trait + Trait2 {}

impl&lt;T: Trait + Trait2&gt; Trait3 for T {}

struct Struct;
impl Trait for Struct {}
impl Trait2 for Struct {}

fn takes_trait(t: &amp;dyn Trait) {}
fn takes_trait2(t: &amp;dyn Trait2) {}

fn main() {
    let t: &amp;dyn Trait3 = &amp;Struct;
    takes_trait(t); // compile error
    takes_trait2(t); // compile error
}
</code></pre></pre>
<ul>
<li>无法自动向上转型：只能显示向上转型</li>
</ul>
<pre><pre class="playground"><code class="language-rust">trait Trait {}
trait Trait2 {}

trait Trait3: Trait + Trait2 {
    fn as_trait(&amp;self) -&gt; &amp;dyn Trait;
    fn as_trait2(&amp;self) -&gt; &amp;dyn Trait2;
}

impl&lt;T: Trait + Trait2&gt; Trait3 for T {
    fn as_trait(&amp;self) -&gt; &amp;dyn Trait {
        self
    }
    fn as_trait2(&amp;self) -&gt; &amp;dyn Trait2 {
        self
    }
}

struct Struct;
impl Trait for Struct {}
impl Trait2 for Struct {}

fn takes_trait(t: &amp;dyn Trait) {}
fn takes_trait2(t: &amp;dyn Trait2) {}

fn main() {
    let t: &amp;dyn Trait3 = &amp;Struct;
    takes_trait(t.as_trait()); // compiles
    takes_trait2(t.as_trait2()); // compiles
}
</code></pre></pre>
<h3 id="关键点key-takeaway"><a class="header" href="#关键点key-takeaway">关键点(Key Takeaway)</a></h3>
<ul>
<li>Rust不支持超过2个宽度的指针，所以</li>
<li>我们不能够把不确定大小类型(unsized type)转换为trait对象</li>
<li>我们不能有多trait对象，但是我们可以通过把多个trait合并到一个trait里来解决</li>
</ul>
<h2 id="用户定义的不确定大小类型"><a class="header" href="#用户定义的不确定大小类型">用户定义的不确定大小类型</a></h2>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Unsized {
  unsized_field: [i32],
}
<span class="boring">}
</span></code></pre></pre>
<ul>
<li>可以给结构体 定义一个不确定大小的字段 来定义一个不确定大小的类型</li>
<li>不确定大小的结构体 只能有一个不确定大小字段</li>
<li>使用一个双宽度 最多只能 追踪 一个 不确定大小字段</li>
</ul>
<p>如何实例化该 不确定大小类型：</p>
<ul>
<li>
<p>尽管如此，根据定义，<code>Unsized</code>总是不确定大小的，没有办法构造一个它的确定性大小版本。</p>
</li>
<li>
<p>唯一的解决方法是把这个结构体变成泛型(generic)的，这样它就可以存在于确定性大小和不确定性大小的版本里。</p>
</li>
<li>
<p>申明一个该 确定 大小类型 </p>
</li>
<li>
<p>然后将其转化为 不确定大小类型</p>
</li>
</ul>
<pre><pre class="playground"><code class="language-rust">struct MaybeSized&lt;T: ?Sized&gt; {
    maybe_sized: T,
}

fn main() {
    // unsized coercion from MaybeSized&lt;[i32; 3]&gt; to MaybeSized&lt;[i32]&gt;
    let ms: &amp;MaybeSized&lt;[i32]&gt; = &amp;MaybeSized { maybe_sized: [1, 2, 3] };
}
</code></pre></pre>
<ul>
<li>用户 定义 不确定大小的类型，目前没有什么使用场景，是一个不成熟的特性</li>
<li><code>std::ffi::OsStr</code>和<code>std::path::Path</code>是标准库里的两个不确定大小结构体</li>
</ul>
<h2 id="零大小类型zero-sized-types"><a class="header" href="#零大小类型zero-sized-types">零大小类型(Zero-Sized Types)</a></h2>
<h3 id="单元类型unit-type"><a class="header" href="#单元类型unit-type">单元类型(Unit Type)</a></h3>
<p>最常见的ZST 是单元类型，也见空元祖</p>
<ul>
<li>
<p>所空块 {} 的计算结果为 <code>()</code> </p>
</li>
<li>
<p>所有以 分号结尾的 也返回 <code>()</code></p>
</li>
<li>
<p>没有明确返回类型的 也 返回 <code>()</code></p>
</li>
<li>
<p>所有 ()都相等</p>
</li>
<li>
<p>单元类型的 标准Trait实现</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::cmp::Ordering;

impl Default for () {
    fn default() {}
}

impl PartialEq for () {
    fn eq(&amp;self, _other: &amp;()) -&gt; bool {
        true
    }
    fn ne(&amp;self, _other: &amp;()) -&gt; bool {
        false
    }
}

impl Ord for () {
    fn cmp(&amp;self, _other: &amp;()) -&gt; Ordering {
        Ordering::Equal
    }
}
<span class="boring">}
</span></code></pre></pre>
</li>
<li>
<p>编译器理解<code>()</code>是零大小类型并且会优化和<code>()</code>实例有关的交互。例如:一个<code>Vec&lt;()&gt;</code>永远不会执行堆分配，从<code>Vec</code>里推进(push)和弹出(pop)<code>()</code>只是对它里面的<code>len</code>字段进行增加或减少。</p>
</li>
</ul>
<h3 id="用户定义的单元结构体user-defined-unit-structs"><a class="header" href="#用户定义的单元结构体user-defined-unit-structs">用户定义的单元结构体(User-Defined Unit Structs)</a></h3>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Struct;
<span class="boring">}
</span></code></pre></pre>
<p>单元结构比<code>()</code>更有用的一些属性:</p>
<ul>
<li>可以为单元结构体实现 <em>trait</em>，而 空元祖 由于 孤儿规则 阻止</li>
<li>单元结构体 可以赋予更有意义的名字</li>
<li>单元结构体 默认是非 copy类型的</li>
</ul>
<h3 id="never-type"><a class="header" href="#never-type">Never Type</a></h3>
<p>！：它被叫做never类型是因为它表示永远不会产生任何值的计算。</p>
<p>never类型不同于 <code>()</code> 它有一些有趣的属性</p>
<ul>
<li>! 可以被强制转化到任意类型</li>
<li>无法创建 ！ 类型的实例</li>
</ul>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// nice for quick prototyping
fn example&lt;T&gt;(t: &amp;[T]) -&gt; Vec&lt;T&gt; {
    unimplemented!() // ! coerced to Vec&lt;T&gt;
}

fn example2() -&gt; i32 {
    // we know this parse call will never fail
    match &quot;123&quot;.parse::&lt;i32&gt;() {
        Some(num) =&gt; num,
        None =&gt; unreachable!(), // ! coerced to i32
    }
}

fn example3(bool: someCondition) -&gt; &amp;'static str {
    if (!someCondition) {
        panic!() // ! coerced to &amp;str
    } else {
        &quot;str&quot;
    }
}
<span class="boring">}
</span></code></pre></pre>
<p><code>break</code>，<code>continue</code>，和<code>return</code>表达式也有<code>!</code>类型：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn example() -&gt; i32 {
    // we can set the type of x to anything here
    // since the block never evaluates to any value
    let x: String = {
        return 123 // ! coerced to String
    };
}

fn example2(nums: &amp;[i32]) -&gt; Vec&lt;i32&gt; {
    let mut filtered = Vec::new();
    for num in nums {
        filtered.push(
            if *num &lt; 0 {
                break // ! coerced to i32
            } else if *num % 2 == 0 {
                *num
            } else {
                continue // ! coerced to i32
            }
        );
    }
    filtered
}
<span class="boring">}
</span></code></pre></pre>
<p><code>!</code>的第二个有趣的属性让我们能够让我们在类型级别把特定的状态标记为不可能。让我们看看下面的函数:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn function() -&gt; Result&lt;Success, Error&gt;;
<span class="boring">}
</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>//永远也不会失败
fn function() -&gt; Result&lt;Success, !&gt;;
//永远也不会成功
fn function() -&gt; Result&lt;!, Error&gt;;
<span class="boring">}
</span></code></pre></pre>
<p><strong>keypoint</strong></p>
<ul>
<li><code>!</code>可以被强制转到到任何其他的类型</li>
<li>无法创建<code>!</code>的实例，我们可以使用这一点在类型级别把一个状态标记为不可能的</li>
</ul>
<h3 id="用户定义的伪never类型user-defined-pseudo-never-types"><a class="header" href="#用户定义的伪never类型user-defined-pseudo-never-types">用户定义的伪Never类型(User-Defined Pseudo Never Types)</a></h3>
<p>尽管定义一个<strong>能够强制转换到任意其他类型的类型是不可能的</strong></p>
<p>但是定义一个无法创建实例的类型是有可能的，例如一个没有任何variant的<code>enum</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Void {}
<span class="boring">}
</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Void {}

// example 1
impl FromStr for String {
    type Err = Void;
    fn from_str(s: &amp;str) -&gt; Result&lt;String, Self::Err&gt; {
        Ok(String::from(s))
    }
}

// example 2
fn run_server() -&gt; Result&lt;Void, ConnectionError&gt; {
    loop {
        let (request, response) = get_request()?;
        let result = request.process();
        response.send(result);
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>这是Rust标准库里使用的技术，因为<code>String</code>的<code>FromStr</code>实现里的<code>Err</code>类型是<code>std::convert::Infallible</code>， 其定义如下:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub enum Infallible {}
<span class="boring">}
</span></code></pre></pre>
<h3 id="phantomdata"><a class="header" href="#phantomdata">PhantomData</a></h3>
<p><code>PhantomData</code>是一个零大小标记结构体</p>
<p>如果不想实现 Send Sync 这项的自动 trait 要么使用 feature 的 !  功能</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span>#![feature(negative_impls)]

<span class="boring">fn main() {
</span>// this type is Send and Sync
struct Struct;

// opt-out of Send trait
impl !Send for Struct {}

// opt-out of Sync trait
impl !Sync for Struct {}
<span class="boring">}
</span></code></pre></pre>
<p>要么增加一个成员变量：是非 send或 sync的</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::rc::Rc;

// this type is not Send or Sync
struct Struct {
    // adds 8 bytes to every instance
    _not_send_or_sync: Rc&lt;()&gt;,
}
<span class="boring">}
</span></code></pre></pre>
<p>但是这增加了 trait的大小</p>
<p>针对上述的场景，可以使用 <em>PhantomData</em></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::rc::Rc;
use std::marker::PhantomData;

type NotSendOrSyncPhantom = PhantomData&lt;Rc&lt;()&gt;&gt;;

// this type is not Send or Sync
struct Struct {
    // adds no additional size to instances
    _not_send_or_sync: NotSendOrSyncPhantom,
}
<span class="boring">}
</span></code></pre></pre>
<p><strong>关键点(Key Takeaway)</strong></p>
<ul>
<li><code>PhantomData</code>是一个零大小标记结构体，可以用于标记一个包含结构体为拥有特定的属性</li>
</ul>
<h2 id="总结conclusion"><a class="header" href="#总结conclusion">总结(Conclusion)</a></h2>
<ul>
<li>只有确定大小类型(sized type)的实例才可以放到栈上，也就是，可以通过传值的方式传递</li>
<li>不确定大小类型(unsized tpe)的实例不能放到栈上而且必须通过传引用的方式传递</li>
<li>指向不确定大小类型(unsized tpe)的指针是双宽度的，因为除了保存指向数据的指针外，还需要额外的比特位来追踪数据的长度或者指向一个vtable</li>
<li><code>Sized</code>是一个&quot;自动(auto)&quot;标记trait</li>
<li>所有的泛型类型参数默认是被<code>Sized</code>自动约束</li>
<li>如果我们有一个泛型函数，它接收隐于指针后的类型<code>T</code>为参数，例如<code>&amp;T</code>，<code>Box&lt;T&gt;</code>，<code>Rc&lt;T&gt;</code>等，那么我们总是选择退出默认的<code>Sized</code>约束而选用<code>T:?Sized</code>约束</li>
<li>利用切片和Rust的自动类型强制转换能够让我们写出灵活的API</li>
<li>所有的trait默认都是<code>?Sized</code></li>
<li>对于<code>impl Trait for dyn Trait</code>，要求<code>Trait: ?Sized</code></li>
<li>我们可以在每个方法上要求<code>Self:Sized</code></li>
<li>由<code>Sized</code>约束的trait不能转为trait对象</li>
<li>Rust不支持超过2个宽度的指针，因此</li>
<li>我们不能把不确定大小类型转为trait对象</li>
<li>我们不能有多trait对象，但是我们可以通过把多个trait合并到一个trait里来解决这个问题</li>
<li>用户定义的不确定类型大小类型是个不成熟的特性，现在其局限性超过所能带来的益处</li>
<li>ZST的所有实例都相等</li>
<li>Rust编译器会去优化和ZST相关的交互</li>
<li><code>!</code>可以被强制转换为其他类型</li>
<li>无法创建一个<code>!</code>的实例，我们可以利用这一点在类型级别把特定状态标记为不可能</li>
<li><code>PhantomData</code>是一个零大小标记结构体，可以用于把一个包含结构体标记为含有特定属性</li>
</ul>
<p><a href="https://zhuanlan.zhihu.com/p/189353352">原文链接</a></p>
<h2 id="rust-dyn-关键字"><a class="header" href="#rust-dyn-关键字"><a href="https://www.cnblogs.com/johnnyzhao/p/15385113.html">Rust-dyn 关键字</a></a></h2>
<p><strong>dyn是trait对象类型的前缀</strong></p>
<p>dyn关键字用于强调相关trait的方法是动态分配的。要以这种方式使用trait，它必须是“对象安全”的。</p>
<p>与泛型参数或植入型特质不同，编译器不知道被传递的具体类型。也就是说，该类型已经被抹去</p>
<p>因此，一个dyn Trait引用包含两个指针</p>
<p>一个指针指向数据（例如，一个结构的实例）</p>
<p>另一个指针指向方法调用名称与函数指针的映射（被称为虚拟方法表各vtable）</p>
<p>impl trait 和 dyn trait 在Rust分别被称为静态分发和动态分发，即当代码涉及多态时，需要某种机制决定实际调动类型。</p>
<p>每当在堆上分配内存时，Rust都会尝试尽可能明确。因此，如果你的函数以这种方式返回指向堆的trait指针，则需要使用dyn关键字编写返回类型，如示例2:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn random_animal(random_number: f64) -&gt; Box&lt;dyn Animal&gt; {
    if random_number &lt; 0.5 {
        Box::new(Sheep {})
    } else {
        Box::new(Cow {})
    }
}
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="什么是优雅的-api"><a class="header" href="#什么是优雅的-api">什么是优雅的 API</a></h2>
<ul>
<li>
<p>方法名清晰易懂，以让调用了这个 API 的代码易于阅读。</p>
</li>
<li>
<p>有规律、可猜测的方法名在使用 API 时也很有用，可以减少阅读文档的需求。</p>
</li>
<li>
<p>每个 API 都有至少要有文档和一小段示例代码。</p>
</li>
<li>
<p>用户几乎不需要编写样板代码（boilerplate code）来使用这个 API，因为</p>
<ul>
<li>它广泛接受各种输入类型（当然类型转换是显式的）</li>
<li>并且也有足以应付大部分常用情况的一键 API</li>
</ul>
</li>
<li>
<p>充分利用类型来防止逻辑错误，但不会太妨碍使用。</p>
</li>
<li>
<p>返回有意义的错误，并且在文档中注明会导致 panic 的情况。</p>
</li>
</ul>
<h2 id="技术"><a class="header" href="#技术">技术</a></h2>
<blockquote>
<p>有一些 Rust RFC 描述了标准库的命名方案。你也应该遵循它们，以让用户能迅速上手使用你的库。</p>
</blockquote>
<ul>
<li>
<p>RFC 199 解释说应该使用 mut、move 或 ref 作为后缀，来根据参数的可变性区分方法。</p>
</li>
<li>
<p>RFC 344 定义了一些有意思的约定，比如：</p>
<ul>
<li>如何在方法名称中引用类型名称（如 &amp;mut [T] 变成 mut_slice、*mut T 变成 mut ptr），</li>
<li>如何命名返回迭代器的方法，</li>
<li>getter 方法应该被命名为 field_name 而 setter 方法应该被命名为 set_field_name，</li>
<li>如何命名 trait：“优先选择（及物）动词、名词，然后是形容词；避免语法后缀（如 able）”，而且“如果这个 trait 只有一个主要方法，可以考虑用方法名称来命名 trait 本身”，</li>
</ul>
</li>
<li>
<p>RFC 430 描述了一些通用的大小写约定（总结：CamelCase 用于类型级别，snake_case 用于变量级别）。</p>
</li>
<li>
<p>RFC 445 希望你为扩展 trait（extension trait）添加 Ext 后缀。</p>
</li>
</ul>
<p>除了 RFC 199 和 RFC 344 （见上）规定的以外，还有一些其他的关于如何选择方法名称的约定，目前还没有在 RFC 中提及。这些约定大部分都在旧的 <a href="https://doc.rust-lang.org/1.12.0/style/style/naming/conversions.html">Rust 风格指南</a>和 @llogiq 的文章 Rustic Bits 以及 <a href="https://github.com/Manishearth/rust-clippy">clippy</a> 的 wrong_self_convention 检测项中提到了。这里总结一下。</p>
<table><thead><tr><th>方法名称</th><th>参数</th><th>备注</th><th>举例</th></tr></thead><tbody>
<tr><td>new</td><td>无 self，通常 &gt;= 1 <sup class="footnote-reference"><a href="#1">1</a></sup></td><td>构造器，另参见 Default</td><td>Box::new、std::net::Ipv4Addr::new</td></tr>
<tr><td>with_...</td><td>无 self，&gt;= 1</td><td>其他构造器</td><td>Vec::with_capacity、regex::Regex::with_size_limit</td></tr>
<tr><td>from_...</td><td>1</td><td>参见转换 trait（conversion traits）</td><td>String::from_utf8_lossy</td></tr>
<tr><td>as_...</td><td>&amp;self</td><td>无开销的转换，返回数据的一个视图（view）</td><td>str::as_bytes、uuid::Uuid::as_bytes</td></tr>
<tr><td>to_...</td><td>&amp;self</td><td>昂贵的转换</td><td>str::to_string、std::path::Path::to_str</td></tr>
<tr><td>into_...</td><td>self（消耗）</td><td>可能昂贵的转换，参见 转换 trait（conversion traits）</td><td>std::fs::File::into_raw_fd</td></tr>
<tr><td>is_...</td><td>&amp;self（或无）</td><td>期望返回 bool</td><td>slice::is_empty、Result::is_ok、std::path::Path::is_file</td></tr>
<tr><td>has_...</td><td>&amp;self （或无）</td><td>期望返回 bool</td><td>regex_syntax::Expr::has_bytes</td></tr>
</tbody></table>
<h2 id="文档测试"><a class="header" href="#文档测试">文档测试</a></h2>
<p>编写带有示例代码的文档可以展示 API 的用法而且还能获得自动测试
详见第一版 TRPL（The Rust Programming Language）的[文档](详见第一版 TRPL（The Rust Programming Language）的文档一节。)一节。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// 使用魔法操作数字
///
/// # 示例
///
/// ```rust
/// assert_eq!(min( 0,   14),    0);
/// assert_eq!(min( 0, -127), -127);
/// assert_eq!(min(42,  666),   42);
/// ```(由于 hexo markdown 渲染辣鸡，此处加点文字避免被渲染为单独代码块）
fn min(lhs: i32, rhs: i32) -&gt; i32 {
	if lhs &lt; rhs { lhs } else { rhs }
}

<span class="boring">}
</span></code></pre></pre>
<p>你还可以使用 #![deny(missing_docs)] 来强制保证每个公开 API 都有文档。你可能也会对我的这篇提出了 <a href="https://deterministic.space/machine-readable-inline-markdown-code-cocumentation.html">Rust 文档格式化约定</a>的文章感兴趣。</p>
<h2 id="不要在-api-中使用-字符串类型"><a class="header" href="#不要在-api-中使用-字符串类型">不要在 API 中使用 “字符串类型”</a></h2>
<blockquote>
<p>尽量使用枚举</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust">enum Color { Red, Green, Blue, LightGoldenRodYellow }

fn color_me(input: &amp;str, color: Color) { /* ... */ }

fn main() {
    color_me(&quot;surprised&quot;, Color::Blue);
}
</code></pre></pre>
<h2 id="全是常量的模块"><a class="header" href="#全是常量的模块">全是常量的模块</a></h2>
<p>或者，如果你想表达更复杂的值的话，则可以定义一个新的 struct，然后定义一堆公共常量。然后把这些常量放到模块中，用户就可以使用与 enum 类似的语法来访问它们了。</p>
<pre><pre class="playground"><code class="language-rust">pub mod output_options {
    pub struct OutputOptions { /* ... */ }
    
    impl OutputOptions { fn new(/* ... */) -&gt; OutputOptions { /* ... */ } }
    
    pub const DEFAULT: OutputOptions = OutputOptions { /* ... */ };
    pub const SLIM: OutputOptions = OutputOptions { /* ... */ };
    pub const PRETTY: OutputOptions = OutputOptions { /* ... */ };
}

fn output(f: &amp;Foo, opts: OutputOptions) { /* ... */ }

fn main() {
    let foo = Foo::new();
    
    output(foo, output_options::PRETTY);
}
</code></pre></pre>
<h2 id="使用-fromstr-来解析字符串"><a class="header" href="#使用-fromstr-来解析字符串">使用 FromStr 来解析字符串</a></h2>
<p>在某些情况下，你的用户确实不得不使用字符串，比如：从环境变量中读取或者读取他们的用户的输入作为参数——也就是说，他们没办法在代码中编写（静态）字符串传递给你的 API（这个也是我们尝试阻止的）。这种情况下就需要使用 FromStr triat 了，它抽象了 “解析字符串到 Rust 数据类型” 的行为。</p>
<pre><pre class="playground"><code class="language-rust">// 选择 A: 你来解析
fn output_a(f: &amp;Foo, color: &amp;str) -&gt; Result&lt;Bar, ParseError&gt; {
    // 这里使用解析后的类型遮蔽掉了原来的 `color`
    let color: Color = try!(color.parse());

    f.to_bar(&amp;color)
}

// 选择 B: 用户来解析
fn output_b(f: &amp;Foo, color: &amp;Color) -&gt; Bar {
    f.to_bar(color)
}

fn main() {
    let foo = Foo::new();

    // 选择 A: 你来解析，用户来处理 API 错误
    output_a(foo, &quot;Green&quot;).expect(&quot;Error :(&quot;);

    // 选择 B: 用户传入有效类型，所以不需要处理错误
    output_b(foo, Color::Green);

    // 选择 B: 用户使用字符串，需要自己解析并处理错误
    output_b(foo, &quot;Green&quot;.parse().except(&quot;Parse error!&quot;));
}
</code></pre></pre>
<h2 id="错误处理"><a class="header" href="#错误处理">错误处理</a></h2>
<p>TRPL 中对于错误处理<a href="https://kaisery.gitbooks.io/rust-book-chinese/content/content/Error%20Handling%20%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86.html">有一章</a>写得很不错。</p>
<p>也有一些 crate 可以用来减少编写良好错误类型所需的样板代码，比如 <a href="https://crates.io/crates/quick-error">quick-error</a> 和 <a href="https://crates.io/crates/error-chain">error-chain</a>。</p>
<h2 id="公共类型别名"><a class="header" href="#公共类型别名">公共类型别名</a></h2>
<p>如果你的内部代码常常使用某个参数相同的泛型类型，此时可以使用类型别名。如果你想把这些类型公开给你的用户，你也应该把这些别名同样公开给用户（当然记得文档）。</p>
<p>一个常见情况是 E 为固定值的 <code>Result&lt;T, E&gt;</code> 类型。比如 <code>std::io::Result&lt;T&gt; 是 Result&lt;T, std::io::Error&gt;</code> 的别名，<code>std::fmt::Result 是 Result&lt;(), std::fmt::Error&gt; </code>的别名，<code>serde_json::error::Result&lt;T&gt; 是 Result&lt;T, serde_json::error::Error&gt;</code> 的别名。</p>
<h2 id="使用转换-trait"><a class="header" href="#使用转换-trait">使用转换 trait</a></h2>
<p>一个良好实践是永远也不要在参数中使用 &amp;String 和 &amp;Vec<T>，取而代之使用 &amp;str 和 &amp;[T]，后者允许传入更多类型。（基本上是所有能 deref 到字符串或切片（slice）的类型）</p>
<p>与其使用具体类型作为参数，不如使用拥有严格约束的泛型。这样做的缺点是文档的可读性会降低，因为它充满了大量复杂的泛型约束！</p>
<p>std::convert 为提供了一些方便的工具：</p>
<ul>
<li>AsMut：一个便宜的（低消耗）、可变引用到可变引用的转换。</li>
<li>AsRef：一个便宜的，引用到引用的转换。</li>
<li>From： 通过转换来构造自身</li>
<li>Into：一个消耗会自身的转换，可能会比较昂贵（高开销）。</li>
<li>TryFrom：尝试通过转换来构造自身</li>
<li>TryInto：尝试消耗自身转的换，可能会比较昂贵。</li>
</ul>
<p>你可能也会喜欢这篇关于<a href="https://ricardomartins.cc/2016/08/03/convenient_and_idiomatic_conversions_in_rust">如何在 Rust 中进行方便地道的转换的文章</a>.</p>
<h2 id="cow"><a class="header" href="#cow">Cow</a></h2>
<p>如果你需要处理很多不确定是否需要进行分配（allocate）的东西，你应该使用Cow&lt;'a, B&gt;，它可以让你抽象借用和拥有所有权的数据。</p>
<table><thead><tr><th>fn foo(p: PathBuf)</th><th>fn foo&lt;P: Into<PathBuf>&gt;(p: P)</th></tr></thead><tbody>
<tr><td>用户需要把数据转为 PathBuf</td><td>由库来调用 .into() 进行转换</td></tr>
<tr><td>用户进行分配</td><td>看不出：库可能进行分配</td></tr>
<tr><td>用户需要关心 PathBuf 是什么、如何创建</td><td>用户可以传递 String 、OsString，或者 PathBuf 都行</td></tr>
</tbody></table>
<h2 id="intooption_"><a class="header" href="#intooption_">Into&lt;Option&lt;_&gt;&gt;</a></h2>
<p><a href="https://github.com/rust-lang/rust/pull/34828">这个 PR</a> 添加了一个 <code>impl&lt;T&gt; From&lt;T&gt; for Option&lt;T&gt;</code>，在 Rust 1.12 中正式实装。寥寥几行代码赋予了你编写可以被直接调用而不需要写一大堆 Some(...) 的 API 的能力。</p>
<p><strong>之前</strong></p>
<pre><pre class="playground"><code class="language-rust">// 对于 API 作者来说很容易编写，文档也很易于阅读
fn foo(lorem: &amp;str, ipsum: Option&lt;i32&gt;, dolor: Option&lt;i32&gt;, sit: Option&lt;i32&gt;) {
    println!(&quot;{}&quot;, lorem);
}

fn main() {
    foo(&quot;bar&quot;, None, None, None);               // 看起来有些奇怪
    foo(&quot;bar&quot;, Some(42), None, None);           // 还好
    foo(&quot;bar&quot;, Some(42), Some(1337), Some(-1)); // 停！太多…… Some 了……
}
</code></pre></pre>
<p><strong>现在</strong></p>
<pre><pre class="playground"><code class="language-rust">// 对于 API 作者来说得多打点字
// （而且遗憾的是，每个参数都需要被单独指定——否则 Rust 只会根据第一个参数推断类型。
// 这种写法阅读来不是很方便，文档可能也没那么好看）
fn foo&lt;I, D, S&gt;(lorem: &amp;str, ipsum: I, dolor: D, sit: S) where
    I: Into&lt;Option&lt;i32&gt;&gt;,
    D: Into&lt;Option&lt;i32&gt;&gt;,
    S: Into&lt;Option&lt;i32&gt;&gt;,
{
    println!(&quot;{}&quot;, lorem);
}

fn main() {
    foo(&quot;bar&quot;, None, None, None); // 仍然奇怪
    foo(&quot;bar&quot;, 42, None, None);   // 不错
    foo(&quot;bar&quot;, 42, 1337, -1);     // Wow，棒棒！请务必这样编写 API！
}
</code></pre></pre>
<h2 id="关于可能较长的编译时间的说明"><a class="header" href="#关于可能较长的编译时间的说明">关于可能较长的编译时间的说明</a></h2>
<p>如果你有：</p>
<ul>
<li>很多类型参数（比如用于转换 trait）</li>
<li>用在一个很复杂/大型的函数上面</li>
<li>这个函数用得还很多</li>
</ul>
<p>然后 rustc 将会根据不同参数编译这个函数的大量排列组合（泛型函数的单态化），这会导致很长的编译时间。</p>
<p><a href="https://github.com/bluss">bluss</a> 在 <a href="https://www.reddit.com/r/rust/comments/556c0g/optional_arguments_in_rust_112/d8839pu?context=1">Reddit</a> 上提到可以使用 “去泛型” 技术来规避这个问题：你的（公共）泛型函数只简单地调用另一个（私有）非泛型函数，这样这个私有函数就只会被编译一次。</p>
<p>bluss 给的例子是 std::fs::OpenOptions::open 的实现（来自 Rust 1.12 的<a href="https://doc.rust-lang.org/1.12.0/src/std/up/src/libstd/fs.rs.html#599-604">源码</a>）和 image crate 的 <a href="https://github.com/PistonDevelopers/image/pull/518">这个PR</a>，它将 open 函数修改成了这个样子：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn open&lt;P&gt;(path: P) -&gt; ImageResult&lt;DynamicImage&gt; where P: AsRef&lt;Path&gt; {
    // 简单的包装函数，在调用 open_impl 之前去掉泛型
    open_impl(path.as_ref())
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="惰性"><a class="header" href="#惰性">惰性</a></h2>
<p>尽管 Rust 不能像 Haskell 一样对表达式进行惰性计算，但是你仍然可以使用一些技术来优雅地省略不必要的计算和分配。</p>
<h3 id="使用迭代器iterator"><a class="header" href="#使用迭代器iterator">使用迭代器（Iterator）</a></h3>
<p>标准库中最绝妙的构造之一是 Iterator，它是一个 trait，允许类似生成器的值迭代，而你只需要为此实现一个 next 方法<sup class="footnote-reference"><a href="#3">2</a></sup>。Rust 的迭代器是惰性的，你需要显式地调用一个消费函数才会开始迭代。只是编写 &quot;hello&quot;.chars().filter(char::is_white_space) 不会对数据进行任何操作，直到你对它调用像 .collect::<String>() 这样的方法。</p>
<h3 id="迭代器作为参数"><a class="header" href="#迭代器作为参数">迭代器作为参数</a></h3>
<p>使用迭代器作为输入可能会让你的 API 更加难以阅读（T: Iterator&lt;Item=Thingy&gt; vs &amp;[Thingy]），但是可以让用户避免内存分配。</p>
<p>不过，事实上，你可能也并不想接受一个宽泛的 Iterator：而是使用 IntoIterator 。这样你就可以得到一个通过调用 .into_iter() 就能轻松转换为迭代器的类型。判断哪些类型实现了 IntoIterator 也很简单——就如文档中所说的：</p>
<h3 id="类似-iterator-的-trait"><a class="header" href="#类似-iterator-的-trait">类似 Iterator 的 trait</a></h3>
<p>futures::Stream：如 futures 教程所说，类似 Iterator::next 返回 Option<a href="3.rust/Self::Item">Self::Item</a>，Stream::poll 返回一个 Option<a href="3.rust/Self::Item">Self::Item</a> 的异步结果（或者返回一个错误）。</p>
<h3 id="接受闭包"><a class="header" href="#接受闭包">接受闭包</a></h3>
<p>如果有一个可能比较昂贵的值（暂称为类型 Value），而且它并不会在所有的分支中都被使用到，这时可以考虑使用一个返回这个值的闭包（Fn() -&gt; Value）。</p>
<p>一个实际例子是 Result 中的 unwrap_or 和 unwrap_or_else：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let res: Result&lt;i32, &amp;str&gt; = Err(&quot;oh noes&quot;);
res.unwrap_or(42); // 立即返回 `42`

let res: Result&lt;i32, &amp;str&gt; = Err(&quot;oh noes&quot;);
res.unwrap_or_else(|msg| msg.len() as i32); // 将会在需要的时候调用闭包计算
<span class="boring">}
</span></code></pre></pre>
<h4 id="关于惰性的小技巧"><a class="header" href="#关于惰性的小技巧">关于惰性的小技巧</a></h4>
<p>让 Deref 完成所有的工作：为你的类型实现 Deref，让它来完成实际的计算逻辑。这个<a href="https://crates.io/crates/lazy">crate lazy</a>实现了一个能为你完成这件事情的宏（不过需要 unstable 特性）。</p>
<h2 id="提升易用性的-trait"><a class="header" href="#提升易用性的-trait">提升易用性的 trait</a></h2>
<p>这里列举了一些你应该试着为你的类型实现的 trait，它们可以让你的类型更加易用：</p>
<ul>
<li>实现或者派生（derive）“常用” 的 trait 比如 Debug、Hash、PartialEq、PartialOrd、Eq、Ord</li>
<li>实现或者派生Default，而不是编写一个不接受任何参数的 new 方法。</li>
<li>如果你正在为一个类型实现一个可以将它的数据作为 Iterator 返回的方法，你也应该考虑为这个类型实现IntoIterator。（仅有一种迭代数据的主要方式时，才建议这么做。 另请参见上面有关迭代器的部分。）</li>
<li>如果你的自定义数据类型和 std 中的基本类型 T 很相似，请考虑为它实现 Deref&lt;Target=T&gt;，不过请不要滥用——Deref 不是用来模拟继承的！</li>
<li>不要编写一个接受字符串作为参数然后返回一个实例的构造方法，请使用FromStr</li>
</ul>
<h2 id="为输入参数实现自定义-trait"><a class="header" href="#为输入参数实现自定义-trait">为输入参数实现自定义 trait</a></h2>
<p>例：str::find
<code>str::find&lt;P: Pattern&gt;(p: P) </code>接受一个Pattern作为输入，<code>char、str、FnMut(char) -&gt; bool </code>等类型都实现了这个 trait</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>&quot;Lorem ipsum&quot;.find('L');
&quot;Lorem ipsum&quot;.find(&quot;ipsum&quot;);
&quot;Lorem ipsum&quot;.find(char::is_whitespace);
<span class="boring">}
</span></code></pre></pre>
<h2 id="扩展-trait"><a class="header" href="#扩展-trait">扩展 trait</a></h2>
<p>尽量使用标准库中定义的类型和 trait，因为大部分 Rust 程序员都了解它们，它们经过了充分的测试并且有良好的文档。不过，由于 Rust 标准库倾向于提供有语义含义的类型<sup class="footnote-reference"><a href="#4">3</a></sup>，这些类型包含的方法可能对你的 API 来说还不够。幸运的是，Rust 的 “孤儿规则（orphan rules）” 赋予了为任何类型实现任何 trait 的能力——前提是类型和 trait 中的任意一个是在当前 crate 中定义的。</p>
<h2 id="装饰结果"><a class="header" href="#装饰结果">装饰结果</a></h2>
<p>如 <a href="https://twitter.com/Argorak">Florian</a> 在 <a href="http://yakshav.es/decorating-results/">“Decorating Results”</a> 中写到的，你可以使用这种方法来编写并实现 trait 来为内置类型如 Result 实现自己的方法。举例：</p>
<pre><pre class="playground"><code class="language-rust">pub trait GrandResultExt {
    fn party(self) -&gt; Self;
}

impl GrandResultExt for Result&lt;String, Box&lt;Error&gt;&gt; {
    fn party(self) -&gt; Result&lt;String, Box&lt;Error&gt;&gt; {
        if self.is_ok() {
          println!(&quot;Wooohoo! 🎉&quot;);
        }
        self
    }
}

// 用户代码
fn main() {
    let fortune = library_function()
        .method_returning_result()
        .party()
        .unwrap_or(&quot;Out of luck.&quot;.to_string());
}
</code></pre></pre>
<p>Florian 在 lazers 的真实代码中使用了这样的模式装饰了 BoxFuture（来自 futures crate）以让代码更加可读：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let my_database = client
    .find_database(&quot;might_not_exist&quot;)
    .or_create();

<span class="boring">}
</span></code></pre></pre>
<h2 id="扩展-trait-1"><a class="header" href="#扩展-trait-1">扩展 trait</a></h2>
<p>到目前为止，我们已经通过定义并实现自己的 trait 扩展了类型上的可用方法。但你还可以定义扩展其他 trait 的 trait（trait MyTrait: BufRead + Debug {}）。最突出的例子是 <a href="https://crates.io/crates/itertools">itertools</a> crate，它为 std 的迭代器添加了一大堆方法。</p>
<h2 id="建造者模式"><a class="header" href="#建造者模式">建造者模式</a></h2>
<p>通过将一堆小方法串联在一起你可以让复杂的 API 更加易于调用。这个和 Session Type 非常搭（稍后会提到）。derive_builder crate 可以用来为自定义的 struct 自动生成（简单的）Builder</p>
<p>例： std::fs::OpenOptions</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::fs::OpenOptions;
let file = OpenOptions::new().read(true).write(true).open(&quot;foo.txt&quot;);
<span class="boring">}
</span></code></pre></pre>
<h3 id="session-type"><a class="header" href="#session-type">Session Type</a></h3>
<p>你可以在类型系统中编码一个状态机。</p>
<ul>
<li>每个状态都有不同的类型。</li>
<li>每个状态类型都实现了不同的方法。</li>
<li>一些方法会消耗这个状态类型（获取所有权）并且返回另一个状态类型。</li>
</ul>
<p>这个技巧在 Rust 中工作地非常良好，因为你的方法可以将数据移动到新的类型中，并且保证在之后你就无法访问旧状态了。</p>
<p>这是一个关于邮寄包裹的小例子：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let p: OpenPackage = Package::new();
let p: OpenPackage = package.insert([stuff, padding, padding]);

let p: ClosedPackage = package.seal_up();

// let p: OpenPackage = package.insert([more_stuff]);
//~^ ERROR: No method named `insert` on `ClosedPackage`

let p: DeliveryTracking = package.send(address, postage);

<span class="boring">}
</span></code></pre></pre>
<p>一个很好的实际例子是 /u/ssokolow 在 <a href="https://www.reddit.com/r/rust/comments/568yvh/typesafe_unions_in_c_and_rust/d8hcwfs">/r/rust 的这个帖子 </a>中给出的：</p>
<p>Hyper 使用这个方法来在编译时保证，你不可能做出诸如 “在请求/响应主体已经开始后又来设置 HTTP 头” 这种经常在 PHP 网站上看到的事。（编译器可以捕获这个错误，因为在该状态下的连接上没有 “set header” 方法，并且由于过时引用会失效，所以被引用的一定是正确的状态。）</p>
<p><a href="http://hyper.rs/hyper/v0.9.10/hyper/server/index.html#an-aside-write-status">hyper::server 文档</a>中更详细地解释了这是如何实现的。另一个有趣的想法可以在<a href="https://github.com/skade/lazers/blob/96efff493be9312ffc70eac5a04b441952e089eb/lazers-replicator/src/lib.md#verify-peers"> lazers-replicator crate</a> 中找到：它使用 std::convert::From来在状态中转换。</p>
<h2 id="更多信息"><a class="header" href="#更多信息">更多信息：</a></h2>
<ul>
<li>文章 “Beyond Memory Safety With Types” 描述了这项技术如何被用来实现一个漂亮并且类型安全的 IMAP 协议。</li>
<li>论文 “Session types for Rust” (PDF)，作者 Thomas Bracht Laumann Jespersen, Philip Munksgaard, and Ken Friis Larsen (2015). DOI</li>
<li>Andrew Hobden 的帖子 <a href="https://hoverbear.org/2016/10/12/rust-state-machine-pattern/">“Pretty State Machine Patterns in Rust”</a> 展示了一些在 Rust 的类型系统中实现状态机的方法。</li>
</ul>
<h2 id="使用生命周期"><a class="header" href="#使用生命周期">使用生命周期</a></h2>
<p>在静态类型语言中，为你的 API 指定类型和 trait 约束是必不可少的，如前文所说的，它们可以帮助防止逻辑错误。此外，Rust 的类型系统还提供了另一个维度：你还可以描述你的数据的生命周期（并编写生命周期约束）。</p>
<p>这可以让你（作为开发者）更轻松地对待借用的数据（而不是使用开销更大的拥有所有权的数据）。尽可能地使用引用在 Rust 中是一个良好实践，因为高性能和 “零分配” 的库也是语言的卖点之一。</p>
<p>不过，你应该尽可能为此编写良好的文档，因为理解生命周期和处理引用对于你的库用户来说可能是个挑战，尤其是对于 Rust 新手来说。</p>
<p>由于某些原因（可能是比较简短），很多生命周期都被命名为 'a、'b或类似的无意义字符，不过如果你了解引用的生命周期对应的资源的话，你可以找到更好的名称。举例来说，如果你将文件读入到内存并且处理对这块内存的引用，可以将它的生命周期命名为 'file，或者如果你在处理一个 TCP 请求并且解析它的数据，则可以将生命周期命名为 'req。</p>
<h2 id="将析构代码放在-drop-中"><a class="header" href="#将析构代码放在-drop-中">将析构代码放在 drop 中</a></h2>
<p>Rust 的所有权规则不仅能用于内存：如果你的数据类型表示着外部资源（比如 TCP 连接），则在超出作用域时，你可以使用 Drop trait 关闭、释放或清理该资源。你可以像在其他语言中使用析构函数（或者 try ... catch ... finally）一样使用它。
实际的例子有：</p>
<ul>
<li>引用计数类型 Rc 和 Arc 使用 Drop 来减少引用计数（并且在计数归零的时候释放拥有的数据）。</li>
<li>MutexGuard 使用 Drop 来释放它对 Mutex 的锁。</li>
<li>diesel crate 用 Drop 来关闭数据库连接（比如 SQLite）。</li>
</ul>
<h2 id="案例学习"><a class="header" href="#案例学习">案例学习</a></h2>
<p>在 API 设计中使用了一些不错的技巧的 Rust 库：</p>
<ul>
<li>hyper：Session Type（见上文）</li>
<li>diesel：使用拥有复杂的关联类型的 trait 将 SQL 查询编码为类型</li>
<li>futures：高度抽象并且拥有良好文档的 crate</li>
</ul>
<h2 id="其他设计模式"><a class="header" href="#其他设计模式">其他设计模式</a></h2>
<p>我在这里介绍的是编写接口的设计模式，即面向用户的 API。虽然我认为其中的一些模式只适用于编写库，但许多模式也同样适用于编写通用应用程序的代码。</p>
<p>你可以在 <a href="https://github.com/rust-unofficial/patterns">Rust Design Patterns</a> 仓库中找到更多信息</p>
<p>Update 2017-04-27：这篇文章发布以来，Rust 库团队的 @brson 已经发布了一个相当全面的 <a href="https://github.com/brson/rust-api-guidelines">Rust API Guidelines</a> 文档，囊括了我的所有建议，并且内容更全面。</p>
<div class="footnote-definition" id="2"><sup class="footnote-definition-label">4</sup>
<p>在其他强类型语言中有一句口号 “making illegal states unrepresentable”。我第一次听说这个是在人们谈论 Haskell 的时候，这也是 F# for fun and profit 的<a href="http://fsharpforfunandprofit.com/posts/designing-with-types-making-illegal-states-unrepresentable/">这篇文章</a>的标题，和 Richard Feldman 在 elm-conf 2016 上的这篇演讲。</p>
</div>
<p><a href="https://rustcc.cn/article?id=67cd8a70-8f32-4984-bdd5-4a8c6c969775">本文链接</a></p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="const-typestraits-and-implementations-in-rust"><a class="header" href="#const-typestraits-and-implementations-in-rust">const types,traits and implementations in rust</a></h2>
<pre><code>Rust 允许以  const 和 const fn 的形式 的有限形式 编译时函数 执行
</code></pre>
<p>虽然最初，const似乎 是一个 合理的简单功能，但它最终提出了大量有趣而复杂得设计问题，
const fn  是一种非常受限的函数
：不允许带trait bound的泛型参数：这是因为需要考虑 const代码与 运行时代码 交互的问题</p>
<p>但是很难确定一个满足所有要求，又尽可能简约的设计，</p>
<h2 id="proposed-design"><a class="header" href="#proposed-design">Proposed design</a></h2>
<blockquote>
<p>建议设计</p>
</blockquote>
<ul>
<li>最要的概念是如何将 const函数 视为 运行时函数或转换为运行时函数</li>
<li>始终能够 在运行时调用 const函数</li>
</ul>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>const fn foo&lt;A: T&gt;(A) -&gt; A;
<span class="boring">}
</span></code></pre></pre>
<p>这个cost函数将会以如下方式解析</p>
<ul>
<li>在编译时调用 foo时，必须有一个 类型为A的const常量，且实现了trait T，且 实现 T for A 必须也是 const的实现</li>
<li>在运行时调 foo时，没有特殊要求</li>
</ul>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn bar&lt;A: T&gt;(A) -&gt; A;
<span class="boring">}
</span></code></pre></pre>
<ul>
<li>bar不能在编译时调用</li>
<li>在运行时调 foo时，没有特殊要求</li>
</ul>
<h2 id="const-implementations"><a class="header" href="#const-implementations">const implementations</a></h2>
<blockquote>
<p>cost实现</p>
</blockquote>
<ul>
<li>对于 trait T ，类型A的实现必须要满足：每个函数都必须是 const函数</li>
<li>如果视线中有一个不是 const函数，则该实现 不是 const实现</li>
<li>如果存在 默认方法，必须也得覆盖，除非默认方法本来就是 const</li>
</ul>
<h2 id="const-functions-with-generic-trait-bound-types"><a class="header" href="#const-functions-with-generic-trait-bound-types">const functions with generic trait bound types</a></h2>
<blockquote>
<p>具有泛型trait绑定类型的 const 函数</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>const fn baz&lt;A: T&gt;(A) -&gt; A;
<span class="boring">}
</span></code></pre></pre>
<p>只接受 tarit T的 const实现的 类型A</p>
<h2 id="explicitly-const-trait-bounds"><a class="header" href="#explicitly-const-trait-bounds">Explicitly-const trait bounds</a></h2>
<blockquote>
<p>显示const trait 绑定</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn baz&lt;A: const T&gt;(A) -&gt; A {
    // We can only call a `T` method of `A`
    // in a `const` variable declaration
    // if we know `A` `const`-implements `T`,
    // so the trait bound must explicitly
    // be `const`.
    const X: bool = &lt;A as T&gt;::choice();
    ...
}
<span class="boring">}
</span></code></pre></pre>
<p>如果 在函数内部 显示调用了 trait的方法。则必须声明为 impl T for A is const </p>
<h2 id="const-in-traits"><a class="header" href="#const-in-traits">const in traits</a></h2>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>//要求所有实现都必须 const实现 choice
trait T {
    const fn choice() -&gt; bool;
    ...
}
fn baz&lt;A: T&gt;(A) -&gt; A {
    // Now, `&lt;A: const T&gt;` is not needed, since
    // `choice` is always const in any implementation
    // of `T`.
    const X: bool = &lt;A as T&gt;::choice();
    ...
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="opting-out-of-const-trait-bounds-with-const"><a class="header" href="#opting-out-of-const-trait-bounds-with-const">Opting out of const trait bounds with ?const</a></h2>
<blockquote>
<p>选择性退出 const实现</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait T {
    const fn choice() -&gt; bool;

    fn validate(u8) -&gt; bool;
}

struct S;

impl T for S {
    const fn choice() -&gt; bool {
        ...
    }

    fn validate(u8) -&gt; bool {
        ...
    }
}

const fn bar&lt;A: T&gt;(A) -&gt; A {
    let x: bool = &lt;A as T&gt;::choice();
    ...
}
<span class="boring">}
</span></code></pre></pre>
<ul>
<li>如果某个函数 中只使用到了 某个 trait的某个 const函数</li>
<li>但是在函数申明时 必须要求 const 实现： trait实现里的所有方法都必须是 const</li>
<li>可以通过  显式 const trait bounds 选择退出 来放宽 此要求 ：<code>?const</code></li>
</ul>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>const fn bar_opt_ct&lt;A: ?const T&gt;(A) -&gt; A {
    let x: bool = &lt;A as T&gt;::choice();
    ...
}
<span class="boring">}
</span></code></pre></pre>
<ul>
<li>默认的  const fn  需要 const trait bounds ，而对于运行时没有要求</li>
<li>以 <code>?const</code> 为前缀的 trait bounds 不需要 const traits bounds 。在编译时、或者运行时</li>
</ul>
<h2 id="removal-of-the-const-keyword"><a class="header" href="#removal-of-the-const-keyword">Removal of the const keyword</a></h2>
<p>由于任何 const 函数都可以在运行时调用，因此它也必须是有效的非 const 函数（在适当的翻译之后）：这就是我们定义的直觉和动机。转换只是修改函数签名，而不更改正文。这种转换非常简单，只需从函数中删除 const 前缀并删除任何 ？const 边界即可。</p>
<h2 id="syntactic-sugar-for-const-on-traits-and-impls"><a class="header" href="#syntactic-sugar-for-const-on-traits-and-impls">Syntactic sugar for const on traits and impls</a></h2>
<blockquote>
<p>const 语法糖</p>
</blockquote>
<p>可以将 trait 申明为 const 或者 将 实现 声明为 trait</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>const trait V {
    fn foo(C) -&gt; D;
    fn bar(E) -&gt; F;
}
// ...desugars to...
trait V {
    const fn foo(C) -&gt; D;
    const fn bar(E) -&gt; F;
}

struct P;

const impl V for P {
    fn foo(C) -&gt; D;
    fn bar(E) -&gt; F;
}
// ...desugars to...
impl V for P {
    const fn foo(C) -&gt; D;
    const fn bar(E) -&gt; F;
}

<span class="boring">}
</span></code></pre></pre>
<p><a href="https://varkor.github.io/blog/2019/01/11/const-types-traits-and-implementations-in-Rust.html">参考文章</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="为了类型安全和抽象而使用-newtype-模式"><a class="header" href="#为了类型安全和抽象而使用-newtype-模式">为了类型安全和抽象而使用 newtype 模式</a></h1>
<h2 id="newtype的功能"><a class="header" href="#newtype的功能">newType的功能</a></h2>
<ul>
<li>
<p>使用newType替代 基本类型 可以确保某值不被混淆或者用来表示一个值的单元</p>
</li>
<li>
<p>抽象掉一些类型的实现细节</p>
<ul>
<li>封装类型可以暴露出与直接使用其内部私有类型时所不同的公有 API，以便限制其功能。</li>
<li>newtype 也可以隐藏其内部的泛型类型。</li>
</ul>
<p>例如，可以提供一个封装了 <code>HashMap&lt;i32, String&gt;</code> 的 <code>People</code> 类型，用来储存人名以及相应的 ID。使用 <code>People</code> 的代码只需与提供的公有 API 交互即可，比如向 <code>People</code> 集合增加名字字符串的方法，这样这些代码就无需知道在内部我们将一个 <code>i32</code> ID 赋予了这个名字了。newtype 模式是一种实现第十七章 <a href="https://kaisery.github.io/trpl-zh-cn/ch17-01-what-is-oo.html#encapsulation-that-hides-implementation-details">“封装隐藏了实现细节”</a> 部分所讨论的隐藏实现细节的封装的轻量级方法。</p>
</li>
</ul>
<h2 id="类型别名"><a class="header" href="#类型别名">类型别名</a></h2>
<h4 id="什么是类型别名"><a class="header" href="#什么是类型别名">什么是类型别名</a></h4>
<p>连同 newtype 模式，Rust 还提供了声明 <strong>类型别名</strong>（<em>type alias</em>）的能力，使用 <code>type</code> 关键字来给予现有类型另一个名字。例如，可以像这样创建 <code>i32</code> 的别名 <code>Kilometers</code>：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>type Kilometers = i32;
<span class="boring">}
</span></code></pre></pre>
<p>这意味着 <code>Kilometers</code> 是 <code>i32</code> 的 <strong>同义词</strong>（<em>synonym</em>）；不同于示例 19-23 中创建的 <code>Millimeters</code> 和 <code>Meters</code> 类型。<code>Kilometers</code> 不是一个新的、单独的类型。<strong><code>Kilometers</code> 类型的值将被完全当作 <code>i32</code> 类型值来对待</strong>：</p>
<h3 id="类型别名的使用"><a class="header" href="#类型别名的使用">类型别名的使用</a></h3>
<p>类型别名的主要用途是减少重复。例如，可能会有这样很长的类型：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let f: Box&lt;dyn Fn() + Send + 'static&gt; = Box::new(|| println!(&quot;hi&quot;));

fn takes_long_type(f: Box&lt;dyn Fn() + Send + 'static&gt;) {
    // --snip--
}

fn returns_long_type() -&gt; Box&lt;dyn Fn() + Send + 'static&gt; {
    // --snip--
}

//使用类型别名
type Thunk = Box&lt;dyn Fn() + Send + 'static&gt;;

let f: Thunk = Box::new(|| println!(&quot;hi&quot;));

fn takes_long_type(f: Thunk) {
    // --snip--
}

fn returns_long_type() -&gt; Thunk {
    // --snip--
}
<span class="boring">}
</span></code></pre></pre>
<h3 id="泛型化类型别名"><a class="header" href="#泛型化类型别名"><strong>泛型化类型别名</strong></a></h3>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>type Result&lt;T&gt; = std::result::Result&lt;T, std::io::Error&gt;;
<span class="boring">}
</span></code></pre></pre>
<h1 id="从不返回的-never-type"><a class="header" href="#从不返回的-never-type">从不返回的 never type</a></h1>
<ul>
<li>
<p>Rust 有一个叫做 <code>!</code> 的特殊类型。在类型理论术语中，它被称为 <em>empty type</em>，因为它没有值。我们更倾向于称之为 <em>never type</em>。</p>
</li>
<li>
<p>从不返回的函数被称为 发散函数（<em>diverging functions</em>）</p>
</li>
</ul>
<h2 id="continue返回-"><a class="header" href="#continue返回-">Continue返回 !</a></h2>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let guess: u32 = match guess.trim().parse() {
    Ok(num) =&gt; num,
    Err(_) =&gt; continue,
};
<span class="boring">}
</span></code></pre></pre>
<h2 id="panic返回"><a class="header" href="#panic返回">Panic返回!</a></h2>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;T&gt; Option&lt;T&gt; {
    pub fn unwrap(self) -&gt; T {
        match self {
            Some(val) =&gt; val,
            None =&gt; panic!(&quot;called `Option::unwrap()` on a `None` value&quot;),
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="loop返回"><a class="header" href="#loop返回">Loop返回!</a></h2>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>print!(&quot;forever &quot;);

loop {
    print!(&quot;and ever &quot;);
}
<span class="boring">}
</span></code></pre></pre>
<h1 id="动态大小类型和-sized-trait"><a class="header" href="#动态大小类型和-sized-trait">动态大小类型和 Sized trait</a></h1>
<p>因为 Rust 需要知道例如应该为特定类型的值分配多少空间这样的信息其类型系统的一个特定的角落可能令人迷惑：这就是 <strong>动态大小类型</strong>（<em>dynamically sized types</em>）的概念。这有时被称为 “DST” 或 “unsized types”，这些类型允许我们处理只有在运行时才知道大小的类型。</p>
<p>让我们深入研究一个贯穿本书都在使用的动态大小类型的细节：<code>str</code>。没错，不是 <code>&amp;str</code>，而是 <code>str</code> 本身。<code>str</code> 是一个 DST；直到运行时我们都不知道字符串有多长。因为直到运行时都不能知道大其小，也就意味着不能创建 <code>str</code> 类型的变量，也不能获取 <code>str</code> 类型的参数。考虑一下这些代码，他们不能工作：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s1: str = &quot;Hello there!&quot;;
let s2: str = &quot;How's it going?&quot;;
<span class="boring">}
</span></code></pre></pre>
<p>Rust 需要知道应该为特定类型的值分配多少内存，同时所有同一类型的值必须使用相同数量的内存。如果允许编写这样的代码，也就意味着这两个 <code>str</code> 需要占用完全相同大小的空间，不过它们有着不同的长度。这也就是为什么不可能创建一个存放动态大小类型的变量的原因。</p>
<p>那么该怎么办呢？你已经知道了这种问题的答案：<code>s1</code> 和 <code>s2</code> 的类型是 <code>&amp;str</code> 而不是 <code>str</code>。如果你回想第四章 <a href="https://kaisery.github.io/trpl-zh-cn/ch04-03-slices.html#string-slices">“字符串 slice”</a> 部分，slice 数据结储存了开始位置和 slice 的长度。</p>
<p>所以虽然 <code>&amp;T</code> 是一个储存了 <code>T</code> 所在的内存位置的单个值，<code>&amp;str</code> 则是 <strong>两个</strong> 值：<code>str</code> 的地址和其长度。这样，<code>&amp;str</code> 就有了一个在编译时可以知道的大小：它是 <code>usize</code> 长度的两倍。也就是说，我们总是知道 <code>&amp;str</code> 的大小，而无论其引用的字符串是多长。这里是 Rust 中动态大小类型的常规用法：他们有一些额外的元信息来储存动态信息的大小。这引出了动态大小类型的黄金规则：必须将动态大小类型的值置于某种指针之后。</p>
<p>可以将 <code>str</code> 与所有类型的指针结合：比如 <code>Box&lt;str&gt;</code> 或 <code>Rc&lt;str&gt;</code>。事实上，之前我们已经见过了，不过是另一个动态大小类型：trait。每一个 trait 都是一个可以通过 trait 名称来引用的动态大小类型。在第十七章 <a href="https://kaisery.github.io/trpl-zh-cn/ch17-02-trait-objects.html#using-trait-objects-that-allow-for-values-of-different-types">“为使用不同类型的值而设计的 trait 对象”</a> 部分，我们提到了为了将 trait 用于 trait 对象，必须将他们放入指针之后，比如 <code>&amp;dyn Trait</code> 或 <code>Box&lt;dyn Trait&gt;</code>（<code>Rc&lt;dyn Trait&gt;</code> 也可以）。</p>
<p>为了处理 DST，Rust 有一个特定的 trait 来决定一个类型的大小是否在编译时可知：这就是 <code>Sized</code> trait。这个 trait 自动为编译器在编译时就知道大小的类型实现。另外，<strong>Rust 隐式的为每一个泛型函数增加了 <code>Sized</code> bound</strong>。也就是说，对于如下泛型函数定义：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn generic&lt;T&gt;(t: T) {
    // --snip--
}
<span class="boring">}
</span></code></pre></pre>
<p>实际上被当作如下处理：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn generic&lt;T: Sized&gt;(t: T) {
    // --snip--
}
<span class="boring">}
</span></code></pre></pre>
<p>泛型函数默认只能用于在编译时已知大小的类型。然而可以使用如下特殊语法来放宽这个限制：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn generic&lt;T: ?Sized&gt;(t: &amp;T) {
    // --snip--
}
<span class="boring">}
</span></code></pre></pre>
<p><code>?Sized</code> trait bound 与 <code>Sized</code> 相对；也就是说，它可以读作 “<code>T</code> 可能是也可能不是 <code>Sized</code> 的”。这个语法只能用于 <code>Sized</code> ，而不能用于其他 trait。</p>
<p>另外注意我们将 <code>t</code> 参数的类型从 <code>T</code> 变为了 <code>&amp;T</code>：因为其类型可能不是 <code>Sized</code> 的，所以需要将其置于某种指针之后。在这个例子中选择了引用。</p>
<p><strong>例如</strong></p>
<p><strong>闭包的存储空间是动态的</strong></p>
<p><strong>通过指定包装返回闭包</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn returns_closure() -&gt; Box&lt;dyn Fn(i32) -&gt; i32&gt; {
    Box::new(|x| x + 1)
}
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="struct-stdprocesscommand"><a class="header" href="#struct-stdprocesscommand">Struct <a href="https://doc.rust-lang.org/std/index.html">std</a>::<a href="https://doc.rust-lang.org/std/process/index.html">process</a>::[Command]</a></h2>
<p>流程构建器，提供对应如何生成新流程的细粒度控制。</p>
<p>可以使用<code>Command::new(program)</code>生成默认配置，其中</p>
<ol>
<li>program 给出要执行的程序的路径。</li>
<li>其他构建器方法允许在生成之前更改配置 (例如，通过添加参数):</li>
<li>继承当前进程的环境</li>
<li>继承当前进程的工作目录</li>
<li>Inherit stdin/stdout/stderr for <a href="https://doc.rust-lang.org/std/process/struct.Command.html#method.spawn"><code>spawn</code></a> or <a href="https://doc.rust-lang.org/std/process/struct.Command.html#method.status"><code>status</code></a>, but create pipes for <a href="https://doc.rust-lang.org/std/process/struct.Command.html#method.output"><code>output</code></a></li>
</ol>
<pre><code>use std::process::Command;

let output = if cfg!(target_os = &quot;windows&quot;) {
    Command::new(&quot;cmd&quot;)
            .args([&quot;/C&quot;, &quot;echo hello&quot;])
            .output()
            .expect(&quot;failed to execute process&quot;)
} else {
    Command::new(&quot;sh&quot;)
            .arg(&quot;-c&quot;)
            .arg(&quot;echo hello&quot;)
            .output()
            .expect(&quot;failed to execute process&quot;)
};

let hello = output.stdout;
</code></pre>
<p><strong>命令可以重复使用以产生多个进程</strong></p>
<pre><code>use std::process::Command;

let mut echo_hello = Command::new(&quot;sh&quot;);
echo_hello.arg(&quot;-c&quot;)
          .arg(&quot;echo hello&quot;);
let hello_1 = echo_hello.output().expect(&quot;failed to execute process&quot;);
let hello_2 = echo_hello.output().expect(&quot;failed to execute process&quot;);
</code></pre>
<p><strong>生成进程后调用方法</strong></p>
<pre><code>use std::process::Command;

let mut list_dir = Command::new(&quot;ls&quot;);

// Execute `ls` in the current directory of the program.
list_dir.status().expect(&quot;process failed to execute&quot;);

println!();

// Change `ls` to execute in the root directory.
list_dir.current_dir(&quot;/&quot;);

// And then execute `ls` again but in the root directory.
list_dir.status().expect(&quot;process failed to execute&quot;);
</code></pre>
<pre><code>use std::process::Command;

Command::new(&quot;sh&quot;)
        .spawn()
        .expect(&quot;sh command failed to start&quot;);
</code></pre>
<h2 id="api"><a class="header" href="#api">API</a></h2>
<h3 id="new"><a class="header" href="#new">new</a></h3>
<pre><code>pub fn new&lt;S: AsRef&lt;OsStr&gt;&gt;(program: S) -&gt; Command
</code></pre>
<h3 id="arg"><a class="header" href="#arg">arg</a></h3>
<pre><code>.arg(&quot;-C /path/to/repo&quot;)

.arg(&quot;-C&quot;)
.arg(&quot;/path/to/repo&quot;)
</code></pre>
<h3 id="args"><a class="header" href="#args">args</a></h3>
<pre><code>use std::process::Command;

Command::new(&quot;ls&quot;)
        .args([&quot;-l&quot;, &quot;-a&quot;])
        .spawn()
        .expect(&quot;ls command failed to start&quot;);
</code></pre>
<h3 id="env"><a class="header" href="#env">env</a></h3>
<p>插入或者更新环境变量</p>
<pre><code>use std::process::Command;

Command::new(&quot;ls&quot;)
        .env(&quot;PATH&quot;, &quot;/bin&quot;)
        .spawn()
        .expect(&quot;ls command failed to start&quot;);
</code></pre>
<h3 id="envs"><a class="header" href="#envs">envs</a></h3>
<pre><code>use std::process::{Command, Stdio};
use std::env;
use std::collections::HashMap;

let filtered_env : HashMap&lt;String, String&gt; =
    env::vars().filter(|&amp;(ref k, _)|
        k == &quot;TERM&quot; || k == &quot;TZ&quot; || k == &quot;LANG&quot; || k == &quot;PATH&quot;
    ).collect();

Command::new(&quot;printenv&quot;)
        .stdin(Stdio::null())
        .stdout(Stdio::inherit())
        .env_clear()
        .envs(&amp;filtered_env)
        .spawn()
        .expect(&quot;printenv failed to start&quot;);
</code></pre>
<h3 id="env_remove"><a class="header" href="#env_remove">env_remove</a></h3>
<pre><code>use std::process::Command;

Command::new(&quot;ls&quot;)
        .env_remove(&quot;PATH&quot;)
        .spawn()
        .expect(&quot;ls command failed to start&quot;);
</code></pre>
<h3 id="env_clear"><a class="header" href="#env_clear">Env_clear</a></h3>
<pre><code>use std::process::Command;

Command::new(&quot;ls&quot;)
        .env_clear()
        .spawn()
        .expect(&quot;ls command failed to start&quot;);
</code></pre>
<h3 id="current_dir"><a class="header" href="#current_dir">current_dir</a></h3>
<pre><code>use std::process::Command;

Command::new(&quot;ls&quot;)
        .current_dir(&quot;/bin&quot;)
        .spawn()
        .expect(&quot;ls command failed to start&quot;);
</code></pre>
<h3 id="stdin"><a class="header" href="#stdin">stdin</a></h3>
<p>子进程的标准输入 (stdin) 句柄的配置。</p>
<pre><code>use std::process::{Command, Stdio};

Command::new(&quot;ls&quot;)
        .stdin(Stdio::null())
        .spawn()
        .expect(&quot;ls command failed to start&quot;);
</code></pre>
<h3 id="stdout"><a class="header" href="#stdout">stdout</a></h3>
<pre><code>use std::process::{Command, Stdio};

Command::new(&quot;ls&quot;)
        .stdout(Stdio::null())
        .spawn()
        .expect(&quot;ls command failed to start&quot;);
</code></pre>
<h3 id="stderr"><a class="header" href="#stderr">stderr</a></h3>
<pre><code>use std::process::{Command, Stdio};

Command::new(&quot;ls&quot;)
        .stderr(Stdio::null())
        .spawn()
        .expect(&quot;ls command failed to start&quot;);
</code></pre>
<h3 id="spawn"><a class="header" href="#spawn">spawn</a></h3>
<pre><code>use std::process::Command;

Command::new(&quot;ls&quot;)
        .spawn()
        .expect(&quot;ls command failed to start&quot;);
</code></pre>
<ol>
<li>
<p>将命令作为子进程执行，并返回一个句柄。</p>
</li>
<li>
<p>默认情况下，stdin、stdouts和stderr是从父级继承的。</p>
</li>
</ol>
<h3 id="output"><a class="header" href="#output">output</a></h3>
<p>将命令作为子进程执行，等待它完成并收集其所有输出。</p>
<p>默认情况下，stdot和stderr被捕获 (并用于提供结果输出)。Stdin不会从父级继承，并且子进程尝试从stdin流读取的任何尝试都会导致流立即关闭。</p>
<pre><code>use std::process::Command;
use std::io::{self, Write};
let output = Command::new(&quot;/bin/cat&quot;)
                     .arg(&quot;file.txt&quot;)
                     .output()
                     .expect(&quot;failed to execute process&quot;);

println!(&quot;status: {}&quot;, output.status);
io::stdout().write_all(&amp;output.stdout).unwrap();
io::stderr().write_all(&amp;output.stderr).unwrap();

assert!(output.status.success());
</code></pre>
<h3 id="status"><a class="header" href="#status">status</a></h3>
<ol>
<li>作为子进程执行命令，等待它完成并收集其状态。</li>
<li>默认情况下，stdin、stdouts和stderr是从父级继承的。</li>
</ol>
<pre><code>use std::process::Command;

let status = Command::new(&quot;/bin/cat&quot;)
                     .arg(&quot;file.txt&quot;)
                     .status()
                     .expect(&quot;failed to execute process&quot;);

println!(&quot;process finished with: {status}&quot;);

assert!(status.success());
</code></pre>
<h3 id="get_program"><a class="header" href="#get_program">get_program</a></h3>
<p>返回给程序路径。</p>
<pre><code>use std::process::Command;

let cmd = Command::new(&quot;echo&quot;);
assert_eq!(cmd.get_program(), &quot;echo&quot;);
</code></pre>
<h3 id="get_args"><a class="header" href="#get_args">get_args</a></h3>
<ol>
<li>返回参数迭代器</li>
<li>这不包括程序的路径作为第一个参数; 它只包括  <a href="https://doc.rust-lang.org/std/process/struct.Command.html#method.arg"><code>Command::arg</code></a>  指定的参数</li>
</ol>
<h3 id="get_envs"><a class="header" href="#get_envs">get_envs</a></h3>
<ol>
<li>返回设置子进程的迭代器</li>
<li>元素是(&amp;OsStr, Option&lt;&amp;OsStr&gt;)
<ol>
<li>其中第一个值是键，第二个值是值，</li>
<li>如果要显式删除环境变量，则该值为None。</li>
</ol>
</li>
<li>这仅包括使用 Command::env，Command::envs和Command::env_remove显式设置的环境变量。</li>
<li>它不包括将由子进程继承的环境变量。</li>
</ol>
<h3 id="get_current_dir"><a class="header" href="#get_current_dir">get_current_dir</a></h3>
<pre><code>use std::path::Path;
use std::process::Command;

let mut cmd = Command::new(&quot;ls&quot;);
assert_eq!(cmd.get_current_dir(), None);
cmd.current_dir(&quot;/bin&quot;);
assert_eq!(cmd.get_current_dir(), Some(Path::new(&quot;/bin&quot;)));
</code></pre>
<p><a href="https://doc.rust-lang.org/std/process/struct.Command.html">参考链接</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="智能指针简介"><a class="header" href="#智能指针简介">智能指针简介</a></h1>
<ol>
<li>
<p><strong>指针</strong> （<em>pointer</em>）是一个包含内存地址的变量</p>
</li>
<li>
<p>这个地址 &quot;引用&quot;，或  “指向”（points at）一些其他数据</p>
</li>
<li>
<p>Rust 中最常见的指针是 <strong>引用</strong>（<em>reference</em>）引用以 <code>&amp;</code> 符号为标志并借用了他们所指向的值</p>
</li>
<li>
<p>除了引用数据没有任何其他特殊功能。它们也没有任何额外开销，所以应用得最多。</p>
</li>
<li>
<p><strong>智能指针</strong>（<em>smart pointers</em>）是一类数据结构，他们的表现类似指针，但是拥有额外的元数据和功能</p>
</li>
<li>
<p>智能指针的概念并不为 Rust 所独有；其起源于 C++ 并存在于其他语言中</p>
</li>
<li>
<p>Rust 标准库中不同的智能指针提供了多于引用的额外功能</p>
</li>
<li>
<p>在 Rust 中，普通引用和智能指针的一个额外的区别是  <strong>引用是一类只借用数据的指针</strong>,智能指针 <strong>拥有</strong> 他们指向的数据。</p>
</li>
<li>
<p>实际上本书中已经出现过一些智能指针，比如第八章的 <code>String</code> 和 <code>Vec&lt;T&gt;</code>，虽然当时我们并不这么称呼它们。这些类型都属于智能指针因为它们拥有一些数据并允许你修改它们</p>
</li>
<li>
<p>它们也带有元数据（比如他们的容量）和额外的功能或保证（<code>String</code> 的数据总是有效的 UTF-8 编码）。</p>
</li>
<li>
<p>智能指针通常使用结构体实现。智能指针区别于常规结构体的显著特性在于其实现了 <code>Deref</code> 和 <code>Drop</code> trait</p>
</li>
<li>
<p><code>Deref</code> trait 允许智能指针结构体实例表现的像引用一样，这样就可以编写既用于引用、又用于智能指针的代码</p>
</li>
<li>
<p><code>Drop</code> trait 允许我们自定义当智能指针离开作用域时运行的代码。<strong>本章会讨论这些 trait 以及为什么对于智能指针来说他们很重要。</strong></p>
</li>
<li>
<p>常见的智能指针</p>
</li>
</ol>
<ul>
<li><code>Box&lt;T&gt;</code>，用于在堆上分配值</li>
<li><code>Rc&lt;T&gt;</code>，一个引用计数类型，其数据可以有多个所有者</li>
<li><code>Ref&lt;T&gt;</code> 和 <code>RefMut&lt;T&gt;</code>，通过 <code>RefCell&lt;T&gt;</code> 访问。（ <code>RefCell&lt;T&gt;</code> 是一个在运行时而不是在编译时执行借用规则的类型）。</li>
</ul>
<ol>
<li>另外我们会涉及 <strong>内部可变性</strong>（<em>interior mutability</em>）模式，这是不可变类型暴露出改变其内部值的 API</li>
<li><strong>引用循环</strong>（<em>reference cycles</em>）会如何泄漏内存，以及如何避免。</li>
</ol>
<h1 id="最简单的智能指针boxt"><a class="header" href="#最简单的智能指针boxt">最简单的智能指针：Box<code>&lt;T&gt;</code></a></h1>
<h2 id="简介-1"><a class="header" href="#简介-1">简介</a></h2>
<ol>
<li>
<p>最简单直接的智能指针是 <em>box</em>，其类型是 <code>Box&lt;T&gt;</code></p>
</li>
<li>
<p>box 允许你将一个值放在堆上而不是栈上。</p>
</li>
<li>
<p>留在栈上的则是指向堆数据的指针</p>
</li>
</ol>
<p>除了数据被储存在堆上而不是栈上之外，box 没有性能损失。不过也没有很多额外的功能。它们多用于如下场景：</p>
<ol>
<li>
<p>当有一个在编译时未知大小的类型，而又想要在需要确切大小的上下文中使用这个类型值的时候</p>
<p>box 允许创建递归类型</p>
</li>
<li>
<p>当有大量数据并希望在确保数据不被拷贝的情况下转移所有权的时候</p>
<p>转移大量数据的所有权可能会花费很长的时间，因为数据在栈上进行了拷贝。为了改善这种情况下的性能，可以通过 box 将这些数据储存在堆上。接着，只有少量的指针数据在栈上被拷贝</p>
</li>
<li>
<p>当希望拥有一个值并只关心它的类型是否实现了特定 trait 而不是其具体类型的时候</p>
<p><strong>trait 对象</strong>（<em>trait object</em>）</p>
</li>
</ol>
<h2 id="box-允许创建递归类型"><a class="header" href="#box-允许创建递归类型">Box 允许创建递归类型</a></h2>
<h3 id="简介-2"><a class="header" href="#简介-2">简介</a></h3>
<ol>
<li>
<p>Rust 需要在编译时知道类型占用多少空间。一种无法在编译时知道大小的类型是 <strong>递归类型</strong>（<em>recursive type</em>）</p>
</li>
<li>
<p>其值的一部分可以是相同类型的另一个值。这种值的嵌套理论上可以无限的进行下去，</p>
</li>
<li>
<p>所以 Rust 不知道递归类型需要多少空间。</p>
</li>
<li>
<p>不过 box 有一个已知的大小，所以通过在循环类型定义中插入 box，就可以创建递归类型了。</p>
</li>
</ol>
<pre><pre class="playground"><code class="language-rust">enum List {
    Cons(i32, List),
    Nil,
}

use crate::List::{Cons, Nil};
fn main() {
    let list = Cons(1, Cons(2, Cons(3, Nil)));
}
</code></pre></pre>
<h3 id="计算非递归类型的大小"><a class="header" href="#计算非递归类型的大小">计算非递归类型的大小</a></h3>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span>
<span class="boring">fn main() {
</span>enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(i32, i32, i32),
}
<span class="boring">}
</span></code></pre></pre>
<p>当 Rust 需要知道要为 <code>Message</code> 值分配多少空间时，它可以检查每一个成员并发现 <code>Message::Quit</code> 并不需要任何空间，<code>Message::Move</code> 需要足够储存两个 <code>i32</code> 值的空间，依此类推。因此，<code>Message</code> <strong>值所需的空间等于储存其最大成员的空间大小。</strong></p>
<h3 id="使用-boxt给递归类型一个已知的大小"><a class="header" href="#使用-boxt给递归类型一个已知的大小">使用 Box&lt;T&gt;给递归类型一个已知的大小</a></h3>
<pre><pre class="playground"><code class="language-rust">enum List {
    Cons(i32, Box&lt;List&gt;),
    Nil,
}

use crate::List::{Cons, Nil};

fn main() {
    let list = Cons(1,
        Box::new(Cons(2,
            Box::new(Cons(3,
                Box::new(Nil))))));
}
</code></pre></pre>
<h1 id="通过-deref-trait-将智能指针当作常规引用处理"><a class="header" href="#通过-deref-trait-将智能指针当作常规引用处理">通过 Deref trait 将智能指针当作常规引用处理</a></h1>
<blockquote>
<p>实现 <code>Deref</code> trait 允许我们重载 <strong>解引用运算符</strong>（<em>dereference operator</em>）<code>*</code>（与乘法运算符或通配符相区别）</p>
</blockquote>
<blockquote>
<p>通过这种方式实现 <code>Deref</code> trait 的智能指针可以被当作常规引用来对待，</p>
</blockquote>
<ol>
<li>让我们首先看看解引用运算符如何处理常规引用</li>
<li>接着尝试定义我们自己的类似 <code>Box&lt;T&gt;</code> 的类型并看看为何解引用运算符不能像引用一样工作</li>
<li>我们会探索如何实现 <code>Deref</code> trait 使得智能指针以类似引用的方式工作变为可能</li>
<li>最后，我们会讨论 Rust 的 <strong>Deref 强制转换</strong>（<em>deref coercions</em>）功能以及它是如何处理引用或智能指针的</li>
</ol>
<p>我们将要构建的 <code>MyBox&lt;T&gt;</code> 类型与真正的 <code>Box&lt;T&gt;</code> 有一个很大的区别</p>
<ol>
<li>我们的版本不会在堆上储存数据</li>
<li>这个例子重点关注 <code>Deref</code>，所以其数据实际存放在何处，相比其类似指针的行为来说不算重要。</li>
</ol>
<h2 id="通过解引用运算符追踪指针的值"><a class="header" href="#通过解引用运算符追踪指针的值">通过解引用运算符追踪指针的值</a></h2>
<blockquote>
<p>常规引用是一个指针类型，一种理解指针的方式是将其看成指向储存在其他某处值的箭头</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let x = 5;
    let y = &amp;x;

    assert_eq!(5, x);
    assert_eq!(5, *y);
}
</code></pre></pre>
<p>不能 将 5 与 y比较 因为 y是 引用类型（指针类型）</p>
<pre><code class="language-sh">6 |   assert_eq!(5, y);

 |   ^^^^^^^^^^^^^^^^^ no implementation for `{integer} == &amp;{integer}`
</code></pre>
<h2 id="像引用一样使用-boxt"><a class="header" href="#像引用一样使用-boxt">像引用一样使用 Box&lt;T&gt;</a></h2>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let x = 5;
    let y = Box::new(x);

    assert_eq!(5, x);
    assert_eq!(5, *y);
}
</code></pre></pre>
<h2 id="自定义智能指针"><a class="header" href="#自定义智能指针">自定义智能指针</a></h2>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span>
<span class="boring">fn main() {
</span>use std::ops::Deref;


impl&lt;T&gt; Deref for MyBox&lt;T&gt; {
    type Target = T;

    fn deref(&amp;self) -&gt; &amp;T {
        //返回内部数据的引用
        &amp;self.0
    }
}

//等价于
*(y.deref()) 
//等价于
*(&amp;T)
//等价于
T
<span class="boring">}
</span></code></pre></pre>
<ol>
<li>
<p><code>deref</code>方法返回值的引用，以及 <code>*(y.deref())</code> 括号外边的普通解引用仍为必须的原因在于<strong>所有权</strong>。</p>
</li>
<li>
<p>如果 <code>deref</code> 方法直接返回值而不是值的引用，其值（的所有权）将被移出 <code>self</code></p>
</li>
<li>
<p>在这里以及大部分使用解引用运算符的情况下我们并不希望获取 <code>MyBox&lt;T&gt;</code> 内部值的所有权</p>
</li>
<li>
<p>每次当我们在代码中使用 <code>*</code> 时， <code>*</code> 运算符都被替换成了先调用 <code>deref</code> 方法再接着使用 <code>*</code> 解引用的操作，且只会发生一次，不会对 <code>*</code> 操作符无限递归替换</p>
</li>
<li>
<p>解引用出上面 <code>i32</code> 类型的值就停止了</p>
</li>
</ol>
<h1 id="函数和方法的隐式-deref-强制转换"><a class="header" href="#函数和方法的隐式-deref-强制转换">函数和方法的隐式 Deref 强制转换</a></h1>
<blockquote>
<p><strong>Deref 强制转换</strong>（<em>deref coercions</em>）是 Rust 在函数或方法传参上的一种便利</p>
</blockquote>
<ol>
<li>
<p>其将实现了 <code>Deref</code> 的类型的引用  转换为原始类型</p>
</li>
<li>
<p>通过 <code>Deref</code> 所能够转换的类型的引用</p>
</li>
<li>
<p>当这种特定类型的引用作为实参传递给和形参类型不同的函数或方法时，Deref 强制转换将自动发生，这时会有一系列的 <code>deref</code> 方法被调用，把我们提供的类型转换成了参数所需的类型。</p>
</li>
</ol>
<p>Deref 强制转换的加入使得 Rust 程序员编写函数和方法调用时无需增加过多显式使用 <code>&amp;</code> 和 <code>*</code> 的引用和解引用。这个功能也使得我们可以编写更多同时作用于引用或智能指针的代码。</p>
<h2 id="example"><a class="header" href="#example"><strong>example</strong></a></h2>
<blockquote>
<p><strong>对于 str的解引用</strong></p>
</blockquote>
<pre><pre class="playground"><code class="language-rust">mod smart_box;
use smart_box::MyBox;
fn main() {
    let my_box = MyBox::new(1);
    let my_box1 = MyBox::new(String::from(&quot;xjq&quot;));
    //普通手动解引用
		//*mybox1 为 String
    	//**mybox1 为 str
    	//&amp;**mybox1 为 &amp;str
    print_str(&amp;**my_box1);
    
    //自动强制解引用
    print_str(&amp;my_box1);
}

fn print_str(str: &amp;str){
    print!(&quot;{}&quot;,str);
}
let my_box1 = MyBox::new(String::from(&quot;xjq&quot;));

print_str(&amp;**my_box1);
</code></pre></pre>
<ol>
<li>Rust 可以通过 <code>deref</code> 调用将 <code>&amp;MyBox&lt;String&gt;</code> 变为 <code>&amp;String</code></li>
<li>Rust 再次调用 <code>deref</code> 将 <code>&amp;String</code> 变为 <code>&amp;str</code></li>
</ol>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let m = MyBox::new(String::from(&quot;Rust&quot;));
    hello(&amp;(*m)[..]);
}
</code></pre></pre>
<h2 id="deref-强制转换如何与可变性交互"><a class="header" href="#deref-强制转换如何与可变性交互">Deref 强制转换如何与可变性交互</a></h2>
<ol>
<li>
<p>类似于如何使用 <code>Deref</code> trait 重载不可变引用的 <code>*</code> 运算符</p>
</li>
<li>
<p>Rust 提供了 <code>DerefMut</code> trait 用于重载可变引用的 <code>*</code> 运算符。</p>
</li>
</ol>
<p>Rust 在发现类型和 trait 实现满足三种情况时会进行 Deref 强制转换：</p>
<ol>
<li>当 T: Deref&lt;Target=U&gt; 时从 &amp;T 到 &amp;U。</li>
<li>当 T: DerefMut&lt;Target=U&gt; 时从 &amp;mut T 到 &amp;mut U。</li>
<li>当 T: Deref&lt;Target=U&gt; 时从 &amp;mut T 到 &amp;U。</li>
</ol>
<p>将一个可变引用转换为不可变引用永远也不会打破借用规则。</p>
<h1 id="使用-drop-trait-运行清理代码"><a class="header" href="#使用-drop-trait-运行清理代码">使用 Drop Trait 运行清理代码</a></h1>
<ol>
<li>
<p>对于智能指针模式来说第二个重要的 trait 是 <code>Drop</code></p>
</li>
<li>
<p>其允许我们在值要离开作用域时执行一些代码</p>
</li>
<li>
<p>可以为任何类型提供 <code>Drop</code> trait 的实现</p>
</li>
<li>
<p>同时所指定的代码被用于释放类似于文件或网络连接的资源</p>
</li>
</ol>
<p>我们在智能指针上下文中讨论 <code>Drop</code> 是因为其功能几乎总是用于实现智能指针</p>
<ol>
<li><code>Drop</code> trait 包含在 prelude 中</li>
<li><code>drop</code> 函数体是放置任何当类型实例离开作用域时期望运行的逻辑的地方</li>
</ol>
<h2 id="通过-stdmemdrop-提早丢弃值"><a class="header" href="#通过-stdmemdrop-提早丢弃值">通过 std::mem::drop 提早丢弃值</a></h2>
<ol>
<li>整个 <code>Drop</code> trait 存在的意义在于其是自动处理的</li>
<li>你可能希望强制运行 <code>drop</code> 方法来释放锁以便作用域中的其他代码可以获取锁</li>
<li>Rust 并不允许我们主动调用 <code>Drop</code> trait 的 <code>drop</code> 方法；</li>
<li>当我们希望在作用域结束之前就强制释放变量的话，我们应该使用的是由标准库提供的 <code>std::mem::drop</code>。</li>
<li>Rust 中的 <code>drop</code> 函数就是这么一个析构函数。</li>
<li>因为不能禁用当值离开作用域时自动插入的 <code>drop</code>，并且不能显式调用 <code>drop</code>，如果我们需要强制提早清理值，可以使用 <code>std::mem::drop</code> 函数。</li>
<li><code>std::mem::drop</code> 函数不同于 <code>Drop</code> trait 中的 <code>drop</code> 方法。可以通过传递希望提早强制丢弃的值作为参数</li>
</ol>
<h1 id="rct-引用计数智能指针"><a class="header" href="#rct-引用计数智能指针">Rc&lt;T&gt; 引用计数智能指针</a></h1>
<ol>
<li>
<p>大部分情况下所有权是非常明确的:可以准确地知道哪个变量拥有某个值</p>
</li>
<li>
<p>有些情况单个值可能会有多个所有者,例如图数据结构</p>
</li>
<li>
<p>为了启用多所有权，Rust 有一个叫做 <code>Rc&lt;T&gt;</code> 的类型。其名称为 <strong>引用计数</strong>（<em>reference counting</em>）的缩写</p>
</li>
<li>
<p>引用计数意味着记录一个值引用的数量来知晓这个值是否仍在被使用。如果某个值有零个引用，就代表没有任何有效引用并可以被清理。</p>
</li>
<li>
<p><code>Rc&lt;T&gt;</code> 用于当我们希望在堆上分配一些内存供程序的多个部分读取，而且无法在编译时确定程序的哪一部分会最后结束使用它的时候</p>
</li>
<li>
<p>如果确实知道哪部分是最后一个结束使用的话，就可以令其成为数据的所有者，正常的所有权规则就可以在编译时生效。</p>
</li>
</ol>
<blockquote>
<p>注意 <code>Rc&lt;T&gt;</code> 只能用于单线程场景</p>
</blockquote>
<h2 id="使用-rct-共享数据"><a class="header" href="#使用-rct-共享数据">使用 Rc&lt;T&gt; 共享数据</a></h2>
<ol>
<li>
<p>不必像调用 <code>Rc::clone</code> 增加引用计数那样调用一个函数来减少计数；</p>
</li>
<li>
<p><code>Drop</code> trait 的实现当 <code>Rc&lt;T&gt;</code> 值离开作用域时自动减少引用计数。</p>
</li>
<li>
<p>使用 <code>Rc&lt;T&gt;</code> 允许一个值有多个所有者，引用计数则确保只要任何所有者依然存在其值也保持有效。</p>
</li>
<li>
<p>通过不可变引用， <code>Rc&lt;T&gt;</code> 允许在程序的多个部分之间只读地共享数据。如果 <code>Rc&lt;T&gt;</code> 也允许多个可变引用,则会违反第四章讨论的借用规则之一：相同位置的多个可变借用可能造成数据竞争和不一致</p>
</li>
</ol>
<h2 id="refcellt-和内部可变性模式"><a class="header" href="#refcellt-和内部可变性模式">RefCell&lt;T&gt; 和内部可变性模式</a></h2>
<ol>
<li>
<p><strong>内部可变性</strong>（<em>Interior mutability</em>）是 Rust 中的一个设计模式</p>
</li>
<li>
<p>它允许你即使在有不可变引用时也可以改变数据，这通常是借用规则所不允许的</p>
</li>
<li>
<p>为了改变数据，该模式在数据结构中使用 <code>unsafe</code> 代码来模糊 Rust 通常的可变性和借用规则</p>
</li>
<li>
<p>我们还未讲到不安全代码；第十九章会学习它们</p>
</li>
<li>
<p>当可以确保代码在运行时会遵守借用规则，即使编译器不能保证的情况，可以选择使用那些运用内部可变性模式的类型</p>
</li>
<li>
<p>所涉及的 <code>unsafe</code> 代码将被封装进安全的 API 中，而外部类型仍然是不可变的。</p>
</li>
</ol>
<h2 id="通过-refcellt-在运行时检查借用规则"><a class="header" href="#通过-refcellt-在运行时检查借用规则">通过 RefCell&lt;T&gt; 在运行时检查借用规则</a></h2>
<p>如下为选择 <code>Box&lt;T&gt;</code>，<code>Rc&lt;T&gt;</code> 或 <code>RefCell&lt;T&gt;</code> 的理由：</p>
<ul>
<li><code>Rc&lt;T&gt;</code> 允许相同数据有多个所有者；<code>Box&lt;T&gt;</code> 和 <code>RefCell&lt;T&gt;</code> 有单一所有者。</li>
<li><code>Box&lt;T&gt;</code> 允许在编译时执行不可变或可变借用检查；<code>Rc&lt;T&gt;</code>仅允许在编译时执行不可变借用检查；<code>RefCell&lt;T&gt;</code> 允许在运行时执行不可变或可变借用检查。</li>
<li>因为 <code>RefCell&lt;T&gt;</code> 允许在运行时执行可变借用检查，所以我们可以在即便 <code>RefCell&lt;T&gt;</code> 自身是不可变的情况下修改其内部的值。</li>
</ul>
<p>在不可变值内部改变值就是 <strong>内部可变性</strong> 模式。让我们看看何时内部可变性是有用的，并讨论这是如何成为可能的。</p>
<h2 id="内部可变性不可变值的可变借用"><a class="header" href="#内部可变性不可变值的可变借用">内部可变性：不可变值的可变借用</a></h2>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let vec1 = vec![1, 2, 3];
let cell = RefCell::new(vec1);

{
    let mut ref_mut1 = cell.borrow_mut();
    ref_mut1.push(4);
    println!(&quot;{:?}&quot;, ref_mut1);
}
let mut ref_mut2= cell.borrow_mut();
<span class="boring">}
</span></code></pre></pre>
<h2 id="refcellt-在运行时记录借用"><a class="header" href="#refcellt-在运行时记录借用">RefCell&lt;T&gt; 在运行时记录借用</a></h2>
<ul>
<li>当创建不可变和可变引用时，我们分别使用 <code>&amp;</code> 和 <code>&amp;mut</code> 语法。对于 <code>RefCell&lt;T&gt;</code> 来说，则是 <code>borrow</code> 和 <code>borrow_mut</code> 方法，这属于 <code>RefCell&lt;T&gt;</code> 安全 API 的一部分</li>
<li><code>borrow</code> 方法返回 <code>Ref&lt;T&gt;</code> 类型的智能指针，<code>borrow_mut</code> 方法返回 <code>RefMut</code> 类型的智能指针</li>
<li>这两个类型都实现了 <code>Deref</code>，所以可以当作常规引用对待。</li>
<li><code>RefCell&lt;T&gt;</code> 记录当前有多少个活动的 <code>Ref&lt;T&gt;</code> 和 <code>RefMut&lt;T&gt;</code> 智能指针</li>
<li>每次调用 <code>borrow</code>，<code>RefCell&lt;T&gt;</code> 将活动的不可变借用计数加一，当 <code>Ref&lt;T&gt;</code> 值离开作用域时，不可变借用计数减一，就像编译时借用规则一样</li>
<li><code>RefCell&lt;T&gt;</code> 在任何时候只允许有多个不可变借用或一个可变借用。</li>
<li>如果我们尝试违反这些规则，相比引用时的编译时错误，<code>RefCell&lt;T&gt;</code> 的实现会在运行时出现 panic</li>
</ul>
<h2 id="结合-rct-和-refcellt-来拥有多个可变数据所有者"><a class="header" href="#结合-rct-和-refcellt-来拥有多个可变数据所有者">结合 Rc&lt;T&gt; 和 RefCell&lt;T&gt; 来拥有多个可变数据所有者</a></h2>
<ul>
<li><code>RefCell&lt;T&gt;</code> 的一个常见用法是与 <code>Rc&lt;T&gt;</code> 结合</li>
<li><code>Rc&lt;T&gt;</code> 允许对相同数据有多个所有者，不过只能提供数据的不可变访问</li>
<li>如果有一个储存了 <code>RefCell&lt;T&gt;</code> 的 <code>Rc&lt;T&gt;</code> 的话，就可以得到有多个所有者 <strong>并且</strong> 可以修改的值了！</li>
</ul>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn test_ref_rc(){
    let vec1 = vec![1, 2, 3];
    let cell = RefCell::new(vec1);
    let rc = Rc::new(cell);
    let rc1 = rc.clone();
    let rc2 = rc.clone();
    rc1.borrow_mut().push(4);
    rc2.borrow_mut().push(5);

    println!(&quot;{:?}&quot;,rc);
}
<span class="boring">}
</span></code></pre></pre>
<h1 id="引用循环与内存泄漏"><a class="header" href="#引用循环与内存泄漏">引用循环与内存泄漏</a></h1>
<ol>
<li>Rust 的内存安全性保证使其难以意外地制造永远也不会被清理的内存（被称为 <strong>内存泄漏</strong>（<em>memory leak</em>））</li>
<li>但并不是不可能。与在编译时拒绝数据竞争不同， Rust 并不保证完全地避免内存泄漏，这意味着内存泄漏在 Rust 被认为是内存安全的</li>
<li>这一点可以通过 <code>Rc&lt;T&gt;</code> 和 <code>RefCell&lt;T&gt;</code> 看出：创建引用循环的可能性是存在的。这会造成内存泄漏，因为每一项的引用计数永远也到不了 0，其值也永远不会被丢弃。</li>
</ol>
<h2 id="制造引用循环"><a class="header" href="#制造引用循环">制造引用循环</a></h2>
<blockquote>
<p>创建一个引用循环：两个 <code>List</code> 值互相指向彼此</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust">fn main() {}
use std::rc::Rc;
use std::cell::RefCell;
use crate::List::{Cons, Nil};

#[derive(Debug)]
enum List {
    Cons(i32, RefCell&lt;Rc&lt;List&gt;&gt;),
    Nil,
}

impl List {
    fn tail(&amp;self) -&gt; Option&lt;&amp;RefCell&lt;Rc&lt;List&gt;&gt;&gt; {
        match self {
            Cons(_, item) =&gt; Some(item),
            Nil =&gt; None,
        }
    }
}

pub fn test_recursive(){
    let a =  Rc::new( Cons(1, RefCell::new(Rc::new(Nil))) ) ;
    println!(&quot;a initial rc count = {}&quot;, Rc::strong_count(&amp;a));
    println!(&quot;a next item = {:?}&quot;, a.tail());


    let b = Rc::new( Cons(2,RefCell::new(a.clone())) );
    println!(&quot;a rc count after b creation = {}&quot;, Rc::strong_count(&amp;a));
    println!(&quot;b initial rc count = {}&quot;, Rc::strong_count(&amp;b));
    println!(&quot;b next item = {:?}&quot;, b.tail());




    match  a.tail() {
        None =&gt; {}
        Some(item) =&gt; {
            *item.borrow_mut() = b.clone();
        }
    }

    println!(&quot;b rc count after changing a = {}&quot;, Rc::strong_count(&amp;b));
    println!(&quot;a rc count after changing a = {}&quot;, Rc::strong_count(&amp;a));
}
</code></pre></pre>
<h2 id="weakref的使用"><a class="header" href="#weakref的使用">WeakRef的使用</a></h2>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::rc::{Rc, Weak};
use std::cell::RefCell;
#[derive(Debug)]
struct Node {
    value: i32,
    child: RefCell&lt;Vec&lt;Rc&lt;Node&gt;&gt;&gt;,
    parent: RefCell&lt;Weak&lt;Node&gt;&gt;,
}

impl Node {
    fn new(value: i32, child: Vec&lt;Rc&lt;Node&gt;&gt;) -&gt; Rc&lt;Node&gt; {
        Rc::new(Node {
            value,
            child: RefCell::new(vec![]),
            parent: RefCell::new(Weak::new()),
        }
        )
    }
}

pub fn test_weak_ref() {
    //创建节点1
    let node1 = Node::new(1, vec![]);

    println!(&quot;node1 parent = {:?}&quot;, node1.parent.borrow().upgrade());


    {
        //创建节点2
        let node2 = Node::new(2, vec![node1.clone()]);

        println!(&quot;strong_count:{:?},weak_count:{:?}&quot;,Rc::strong_count(&amp;node2),Rc::weak_count(&amp;node2));

        //将parent赋值为node2
        *node1.parent.borrow_mut() = Rc::downgrade(&amp;node2);

        println!(&quot;strong_count:{:?},weak_count:{:?}&quot;,Rc::strong_count(&amp;node2),Rc::weak_count(&amp;node2));

        println!(&quot;node1 parent = {:?}&quot;, node1.parent.borrow().upgrade());
    }

    println!(&quot;node1 parent = {:?}&quot;, node1.parent.borrow().upgrade());
}
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="简述"><a class="header" href="#简述">简述</a></h1>
<p>关于一个语言被称为面向对象所需的功能，Rust 被很多不同的编程范式影响，包括面向对象编程，函数式编程的特性</p>
<h2 id="对象包含数据和行为"><a class="header" href="#对象包含数据和行为">对象包含数据和行为</a></h2>
<p>面向对象的程序是由对象组成的。一个 <strong>对象</strong> 包含数据和操作这些数据的过程。这些过程通常被称为 <strong>方法</strong> 或 <strong>操作</strong>。</p>
<p>在这个定义下，Rust 是面向对象的：结构体和枚举包含数据而 <code>impl</code> 块提供了在结构体和枚举之上的方法。</p>
<p>虽然带有方法的结构体和枚举并不被 <strong>称为</strong> 对象，但是他们提供了与对象相同的功能，</p>
<h2 id="封装隐藏了实现细节"><a class="header" href="#封装隐藏了实现细节">封装隐藏了实现细节</a></h2>
<p>对象的实现细节不能被使用对象的代码获取到，所以唯一与对象交互的方式是通过对象提供的公有 API</p>
<p>使用对象的代码无法深入到对象内部并直接改变数据或者行为</p>
<p>封装使得改变和重构对象的内部时无需改变使用对象的代码</p>
<p>可以使用 <code>pub</code> 关键字来决定模块、类型、函数和方法是公有的，而默认情况下其他一切都是私有的</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct AveragedCollection {
    list: Vec&lt;i32&gt;,
    average: f64,
}
<span class="boring">}
</span></code></pre></pre>
<p>注意，结构体自身被标记为 <code>pub</code>，这样其他代码就可以使用这个结构体，但是在结构体内部的字段仍然是私有的。这是非常重要的，因为我们希望保证变量被增加到列表或者被从列表删除时，也会同时更新平均值。可以通过在结构体上实现 <code>add</code>、<code>remove</code> 和 <code>average</code> 方法来做到这一点，</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span>
<span class="boring">fn main() {
</span>impl AveragedCollection {
    pub fn add(&amp;mut self, value: i32) {
        self.list.push(value);
        self.update_average();
    }

    pub fn remove(&amp;mut self) -&gt; Option&lt;i32&gt; {
        let result = self.list.pop();
        match result {
            Some(value) =&gt; {
                self.update_average();
                Some(value)
            },
            None =&gt; None,
        }
    }

    pub fn average(&amp;self) -&gt; f64 {
        self.average
    }

    fn update_average(&amp;mut self) {
        let total: i32 = self.list.iter().sum();
        self.average = total as f64 / self.list.len() as f64;
    }
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="继承作为类型系统与代码共享"><a class="header" href="#继承作为类型系统与代码共享">继承，作为类型系统与代码共享</a></h2>
<ol>
<li>
<p>一个对象可以定义为继承另一个对象的定义，这使其可以获得父对象的数据和行为，而无需重新定义。</p>
</li>
<li>
<p>如果一个语言必须有继承才能被称为面向对象语言的话，那么 Rust 就不是面向对象的</p>
</li>
<li>
<p>选择继承有两个主要的原因。</p>
<ol>
<li>第一个是为了重用代码：一旦为一个类型实现了特定行为，继承可以对一个不同的类型重用这个实现,相反 Rust 代码可以使用默认 trait 方法实现来进行共享</li>
<li>第二个使用继承的原因与类型系统有关：表现为子类型可以用于父类型被使用的地方。这也被称为 <strong>多态</strong>（<em>polymorphism</em>），这意味着如果多种对象共享特定的属性，则可以相互替代使用。</li>
</ol>
</li>
</ol>
<p><strong>为什么不用继承</strong></p>
<ol>
<li>
<p>近来继承作为一种语言设计的解决方案在很多语言中失宠了，因为其时常带有共享多于所需的代码的风险。</p>
</li>
<li>
<p>子类不应总是共享其父类的所有特征，但是继承却始终如此。如此会使程序设计更为不灵活，并引入无意义的子类方法调用，或由于方法实际并不适用于子类而造成错误的可能性。某些语言还只允许子类继承一个父类，进一步限制了程序设计的灵活性。</p>
</li>
</ol>
<p>因为这些原因，Rust 选择了一个不同的途径，使用 trait 对象而不是继承。让我们看一下 Rust 中的 trait 对象是如何实现多态的。</p>
<h1 id="为使用不同类型的值而设计的-trait-对象"><a class="header" href="#为使用不同类型的值而设计的-trait-对象">为使用不同类型的值而设计的 trait 对象</a></h1>
<h2 id="gui的component-与draw设计"><a class="header" href="#gui的component-与draw设计">GUI的Component 与Draw设计</a></h2>
<h2 id="状态模式的设计"><a class="header" href="#状态模式的设计">状态模式的设计</a></h2>
<div style="break-before: page; page-break-before: always;"></div><h2 id="包和箱crate"><a class="header" href="#包和箱crate">包和箱(<em>crate</em>)</a></h2>
<ul>
<li>
<p>crate 是一个二进制项或者库,例如某个第三方包</p>
</li>
<li>
<p><em>crate root</em> 是一个源文件，Rust 编译器以它为起始点,并构成你的 crate 的根模块</p>
</li>
<li>
<p><em>包</em>（<em>package</em>） 是提供一系列功能的一个或者多个 crate,整个项目工程</p>
</li>
<li>
<p>一个包会包含有一个 <em>Cargo.toml</em> 文件，阐述如何去构建这些 crate。</p>
</li>
</ul>
<h2 id="包规则"><a class="header" href="#包规则"><strong>包规则</strong></a></h2>
<ul>
<li>一个包中至多 <strong>只能</strong> 包含一个库 crate(library crate)；</li>
<li>包中可以包含任意多个二进制 crate(binary crate)；</li>
<li>包中至少包含一个 crate，无论是库的还是二进制的</li>
</ul>
<h3 id="示例"><a class="header" href="#示例"><strong>示例</strong></a></h3>
<pre><code>//Cargo 会给我们的包创建一个 Cargo.toml 文件
cargo new my-project
</code></pre>
<h2 id="cargo-遵循的一个约定"><a class="header" href="#cargo-遵循的一个约定"><strong>Cargo 遵循的一个约定</strong></a></h2>
<ul>
<li><em>src/main.rs</em> 就是一个与包同名的二进制 crate 的 crate 根</li>
<li>如果包目录中包含 <em>src/lib.rs</em>，则包带有与其同名的库 crate，且 <em>src/lib.rs</em> 是 crate 根。</li>
<li>crate 根文件将由 Cargo 传递给 <code>rustc</code> 来实际构建库或者二进制项目。</li>
</ul>
<p>在此，我们有了一个只包含 <em>src/main.rs</em> 的包，意味着它只含有一个名为 <code>my-project</code> 的二进制 crate。如果一个包同时含有 <em>src/main.rs</em> 和 <em>src/lib.rs</em>，则它有两个 crate：一个库和一个二进制项，且名字都与包相同。通过将文件放在 <em>src/bin</em> 目录下，一个包可以拥有多个二进制 crate：<strong>每个 <em>src/bin</em> 下的文件都会被编译成一个独立的二进制 crate。</strong></p>
<p><code>src/main.rs</code> 和 <code>src/lib.rs</code> 叫做 crate 根。之所以这样叫它们是因为这两个文件的内容都分别在 crate 模块结构的根组成了一个名为 <code>crate</code> 的模块，该结构被称为 <em>模块树</em>（<em>module tree</em>）。</p>
<p><strong>路径有两种形式</strong>：</p>
<ul>
<li><strong>绝对路径</strong>（<em>absolute path</em>）从 crate 根开始，以 crate 名或者字面值 <code>crate</code> 开头。</li>
<li><strong>相对路径</strong>（<em>relative path</em>）从当前模块开始，以 <code>self</code>、<code>super</code> 或当前模块的标识符开头。</li>
</ul>
<h2 id="使用-use-关键字将名称引入作用域"><a class="header" href="#使用-use-关键字将名称引入作用域"><strong>使用 use 关键字将名称引入作用域</strong></a></h2>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>mod front_of_house {
    pub mod hosting {
        pub fn add_to_waitlist() {}
    }
}

use front_of_house::hosting;

pub fn eat_at_restaurant() {
    hosting::add_to_waitlist();
    hosting::add_to_waitlist();
    hosting::add_to_waitlist();
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="创建惯用的-use-路径"><a class="header" href="#创建惯用的-use-路径"><strong>创建惯用的 use 路径</strong></a></h2>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>mod front_of_house {
    pub mod hosting {
        pub fn add_to_waitlist() {}
    }
}

use crate::front_of_house::hosting::add_to_waitlist;

pub fn eat_at_restaurant() {
    add_to_waitlist();
    add_to_waitlist();
    add_to_waitlist();
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="使用父模块将两个具有相同名称的类型引入同一作用域"><a class="header" href="#使用父模块将两个具有相同名称的类型引入同一作用域"><strong>使用父模块将两个具有相同名称的类型引入同一作用域</strong></a></h2>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::fmt::Result;
use std::io::Result as IoResult;

fn function1() -&gt; Result {
    // --snip--
}

fn function2() -&gt; IoResult&lt;()&gt; {
    // --snip--
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="使用as重命名"><a class="header" href="#使用as重命名"><strong>使用as重命名</strong></a></h2>
<pre><pre class="playground"><code class="language-rust">
#![allow(unused)]
fn main() {
use std::fmt::Result;
use std::io::Result as IoResult;

fn function1() -&gt; Result {
    // --snip--
    Ok(())
}

fn function2() -&gt; IoResult&lt;()&gt; {
    // --snip--
    Ok(())
}
}
</code></pre></pre>
<h2 id="使用-pub-use-重导出名称"><a class="header" href="#使用-pub-use-重导出名称"><strong>使用 pub use 重导出名称</strong></a></h2>
<pre><pre class="playground"><code class="language-rust">mod front_of_house {
    pub mod hosting {
        pub fn add_to_waitlist() {}
    }
}

pub use crate::front_of_house::hosting;

pub fn eat_at_restaurant() {
    hosting::add_to_waitlist();
    hosting::add_to_waitlist();
    hosting::add_to_waitlist();
}
fn main() {}

</code></pre></pre>
<p>使用<em>pub use</em>  可以使得使用该模块的 访问到内部的模块</p>
<h2 id="使用外部包"><a class="header" href="#使用外部包">使用外部包</a></h2>
<pre><pre class="playground"><code class="language-rust">[dependencies]
rand = &quot;0.5.5&quot;

//使用
use rand::Rng;
fn main() {
    let secret_number = rand::thread_rng().gen_range(1, 101);
}
</code></pre></pre>
<p><strong>标准库</strong></p>
<pre><pre class="playground"><code class="language-rust">
#![allow(unused)]
fn main() {
use std::collections::HashMap;
}
</code></pre></pre>
<h2 id="嵌套路径来消除大量的-use-行"><a class="header" href="#嵌套路径来消除大量的-use-行">嵌套路径来消除大量的 use 行</a></h2>
<pre><pre class="playground"><code class="language-rust">
#![allow(unused)]
fn main() {
use std::{cmp::Ordering, io};
// ---snip---
}

#![allow(unused)]
fn main() {
use std::io;
use std::io::Write;
}


#![allow(unused)]
fn main() {
use std::io::{self, Write};
}
</code></pre></pre>
<h2 id="通过-glob-运算符将所有的公有定义引入作用域"><a class="header" href="#通过-glob-运算符将所有的公有定义引入作用域">通过 glob 运算符将所有的公有定义引入作用域</a></h2>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::collections::*;
<span class="boring">}
</span></code></pre></pre>
<h2 id="将模块分割进不同文件"><a class="header" href="#将模块分割进不同文件">将模块分割进不同文件</a></h2>
<ul>
<li>每一个crate就是一个根模块。如：<code>exp, lip, lip1, lip2, lip3</code>。</li>
<li>独立的一个文件就是一个mod,文件名就是mod名；但是main.rs, lib.rs, mod.rs除外，mod.rs的模块名就是其所在目录的名字； 而main.rs, lib.rs 的目录结构，如：<code>exp/src/main.rs</code>或 <code>lip/src/lib.rs</code> ;两者的mod名分别是exp和lip。</li>
<li>文件和文件夹内的mod 及其内部定义的函数默认都是private的，除非pub声明公开。</li>
<li>一个文件夹直接包含mod.rs ，如: <code>rust_mod_study/lip2/src/worker/mod.rs ;</code>则 worker就是模块名； 并且mod.rs为此模块的入口文件，此文件夹内的其他子模块都要在mod.rs中 <code>pub mod 模块名</code>，声明后，外部方可看到。</li>
<li>如果一个元素是私有的，那么只有本模块内的元素以及它的子模块可以访问。</li>
<li>如果一个元素是公开的，那么它上一层的模块就有权访问它。</li>
<li>如果存在与文件同名的目录， 则在该目录下定义的模块都是该文件的子模块.（<code>2018 edition有效</code>）如：<code>rust_mod_study/lip3/src/caller.rs ;``rust_mod_study/lip3/src/caller/callerin.rs;</code></li>
</ul>
<p>特别注意，callerin这个mod必须在caller.rs中以<code>pub mod callerin;</code>形式声明，否则外部看不到； 最终模块路径为：<code>lip3::caller::callerin::call();</code></p>
<ul>
<li><code>rust 2018 edition</code> 不再需要在根模块中使用extern crate xxx;语法导入第三方包。如在文件<code>main.rs , lib.rs</code>中不再需要extern crate xxx语法导入第三方包, 如:<code>rust_mod_study/exp/src/main.rs</code> 中的extern crate xxx可以去掉了。只需在Cargo.toml中配置好， 然后在代码中以模块路径访问即可，如：modx::mody::modz::fnx()； 也可以use一下，缩短路径。</li>
<li>rust 如何引用未发布的本地crate, 特别之处在<code>exp/Cargo.toml</code>中， 如：</li>
</ul>
<pre><code class="language-text">[package]
name = &quot;exp&quot;
version = &quot;0.1.0&quot;
authors = [&quot;yujinliang &lt;285779289@qq.com&gt;&quot;]
edition = &quot;2018&quot;

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html
[dependencies]
lip = {path= &quot;../lip&quot; }
lip1 = {path= &quot;../lip1&quot; }
lip2 = {path= &quot;../lip2&quot; }
lip3 = {path= &quot;../lip3&quot; } 

</code></pre>
<ul>
<li>
<p>目录结构：<code>Cargo.lock Cargo.toml exp lip lip1 lip2 lip3 target</code>在同一个父目录<code>rust_mod_study</code>中；其中<code>exp/src/main.rs</code>引用lip开头的所有模块。</p>
</li>
<li>
<p>配置<code>rust workspace</code>, 在<code>rust_mod_study/Cargo.toml</code>中加入以下配置即可，如：
```
[workspace]
members = [&quot;exp&quot;, &quot;lip&quot;, &quot;lip1&quot;, &quot;lip2&quot;, &quot;lip3&quot;]
```</p>
</li>
<li>
<p>在rust_mod_study/exp中给出一个例子用于说明：在同一个crate下各个子mod间的可见性和引用方法</p>
</li>
</ul>
<ol>
<li>首先各个子mod都需要在main.rs(属于crate顶级mod)中声明自己， 如： mod producer; mod consumer; mod switcher;等 ，只有这样各个子mod才能看到彼此，才能引用。</li>
<li>每一个子mod可以用use crate::xxx形式引用在1.中声明的mod, 如：use crate::producer;等。</li>
<li>每一个子mod自身默认都是自私的，除非以pub , pub use等打开为公用。</li>
<li>对于pub struct 其field默认仍然是private的，需要pub声明为公用。</li>
</ol>
<p>总结： 父mod可以引用其子mod, 但是在父模块中仍然需要声明后方可应用子模块，如：<code>mod 子模块名</code> ；而每一个子模块，只可以看到在其父模块中声明过的子mod, 但是仍需<code>use crate::子模块名</code> 来引用一下后方可用。
我是在rust 1.39中做的实验， 时间急促，水平有限，如有谬误，欢迎指正，感谢啦！</p>
<ul>
<li>所有的例子代码都在rust_mod_study目录中 `</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="实例1"><a class="header" href="#实例1">实例1</a></h1>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 函数式的写法
let sum_of_squared_odd_numbers: u32 =
    (0..).map(|n| n * n)             // 所有自然数取平方
         .take_while(|&amp;n| n &lt; upper) // 取小于上限的
         .filter(|&amp;n| is_odd(n))     // 取奇数
         .fold(0, |sum, i| sum + i); // 最后加起来
println!(&quot;functional style: {}&quot;, sum_of_squared_odd_numbers);
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="宏"><a class="header" href="#宏">宏</a></h1>
<blockquote>
<p><strong>宏</strong>（<em>Macro</em>）指的是 Rust 中一系列的功能</p>
</blockquote>
<h2 id="声明declarative宏"><a class="header" href="#声明declarative宏"><strong>声明（<em>Declarative</em>）宏</strong></a></h2>
<h2 id="定义宏-macro_rules"><a class="header" href="#定义宏-macro_rules">定义宏 <code>macro_rules!</code></a></h2>
<h2 id="实例-1"><a class="header" href="#实例-1"><strong>实例</strong></a></h2>
<p><em>vec!</em> 实现</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span>
<span class="boring">fn main() {
</span>#[macro_export]
macro_rules! vec {
    ( $( $x:expr ),* ) =&gt; {
        {
            let mut temp_vec = Vec::new();
            $(
                temp_vec.push($x);
            )*
            temp_vec
        }
    };
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="三种-过程procedural宏"><a class="header" href="#三种-过程procedural宏">三种 <strong>过程</strong>（<em>Procedural</em>）宏</a></h2>
<p><strong>自定义派生（derive）</strong></p>
<p><strong>类属性</strong></p>
<p><strong>类函数</strong></p>
<h1 id="宏原理"><a class="header" href="#宏原理">宏原理</a></h1>
<h2 id="源分析"><a class="header" href="#源分析">源分析</a></h2>
<h3 id="tokenisation"><a class="header" href="#tokenisation"><strong>tokenisation</strong></a></h3>
<ul>
<li>
<p>编译的第一个阶段就是 词汇化(<code>tokenisation</code>)</p>
</li>
<li>
<p>将源代码转换为一系列不可分割的 词语单元</p>
</li>
<li>
<p>rust的各种各样的词法单元</p>
<ul>
<li>自定义标识符  <code>foo</code>, <code>Bambous</code>, <code>self</code>, <code>we_can_dance</code>, <code>LaCaravane</code>, …</li>
<li>整型字面量 : <code>42</code>, <code>72u32</code>, <code>0_______0</code>, …</li>
<li>关键字: <code>_</code>, <code>fn</code>, <code>self</code>, <code>match</code>, <code>yield</code>, <code>macro</code>, …</li>
<li>申明周期标识符: <code>'a</code>, <code>'b</code>, <code>'a_rare_long_lifetime_name</code>, …</li>
<li>字符串字面量: <code>&quot;&quot;</code>, <code>&quot;Leicester&quot;</code>, <code>r##&quot;venezuelan beaver&quot;##</code>, …</li>
<li>符号: <code>[</code>, <code>:</code>, <code>::</code>, <code>-&gt;</code>, <code>@</code>, <code>&lt;-</code>, …</li>
</ul>
</li>
</ul>
<h3 id="parsing"><a class="header" href="#parsing">parsing</a></h3>
<p>下一个阶段是转换 将一系列的 tokens 转换成 AST(Abstract Syntax Tree)</p>
<ul>
<li>会在内存中 构建 程序 的语法结构</li>
<li>例如 1+2 在内存中的结构如下</li>
<li>AST结构 包含了整个程序</li>
</ul>
<pre><code class="language-text">┌─────────┐   ┌─────────┐
│ BinOp   │ ┌╴│ LitInt  │
│ op: Add │ │ │ val: 1  │
│ lhs: ◌  │╶┘ └─────────┘
│ rhs: ◌  │╶┐ ┌─────────┐
└─────────┘ └╴│ LitInt  │
              │ val: 2  │
              └─────────┘
</code></pre>
<h3 id="token-trees"><a class="header" href="#token-trees">Token trees</a></h3>
<ul>
<li>token tree 是介于 tokens 和 AST 之间的一种结构</li>
<li>首先,大部分token都是 toeknTree 中的叶子结点 </li>
<li>唯一不是叶子结点的 token 是 <code>(...), [...], and {...}</code> 又 称 <em>grouping</em> ,它们是 token tree 的内部 非叶子结点</li>
<li>例如</li>
</ul>
<pre><code>a + b + (c + d[0]) + e
</code></pre>
<p>would be parsed into the following token trees:</p>
<pre><code class="language-text">«a» «+» «b» «+» «(   )» «+» «e»
          ╭────────┴──────────╮
           «c» «+» «d» «[   ]»
                        ╭─┴─╮
                         «0»
</code></pre>
<p>Note that this has <em>no relationship</em> to the AST the expression would produce; instead of a single root node, there are <em>nine</em> token trees at the root level. For reference, the AST would be:</p>
<pre><code class="language-text">              ┌─────────┐
              │ BinOp   │
              │ op: Add │
            ┌╴│ lhs: ◌  │
┌─────────┐ │ │ rhs: ◌  │╶┐ ┌─────────┐
│ Var     │╶┘ └─────────┘ └╴│ BinOp   │
│ name: a │                 │ op: Add │
└─────────┘               ┌╴│ lhs: ◌  │
              ┌─────────┐ │ │ rhs: ◌  │╶┐ ┌─────────┐
              │ Var     │╶┘ └─────────┘ └╴│ BinOp   │
              │ name: b │                 │ op: Add │
              └─────────┘               ┌╴│ lhs: ◌  │
                            ┌─────────┐ │ │ rhs: ◌  │╶┐ ┌─────────┐
                            │ BinOp   │╶┘ └─────────┘ └╴│ Var     │
                            │ op: Add │                 │ name: e │
                          ┌╴│ lhs: ◌  │                 └─────────┘
              ┌─────────┐ │ │ rhs: ◌  │╶┐ ┌─────────┐
              │ Var     │╶┘ └─────────┘ └╴│ Index   │
              │ name: c │               ┌╴│ arr: ◌  │
              └─────────┘   ┌─────────┐ │ │ ind: ◌  │╶┐ ┌─────────┐
                            │ Var     │╶┘ └─────────┘ └╴│ LitInt  │
                            │ name: d │                 │ val: 0  │
                            └─────────┘                 └─────────┘
</code></pre>
<p><strong>tokenTree 与 AST 的差别 要理解</strong></p>
<p><strong>写宏时会涉及到这两个结构</strong></p>
<p><strong>方括号,括号,花括号 必须要配对</strong></p>
<h2 id="ast中的宏"><a class="header" href="#ast中的宏">AST中的宏</a></h2>
<p><strong>宏处理发生在AST构建好之后</strong></p>
<p><strong>宏使用语法</strong></p>
<ul>
<li><code># [ $arg ]</code>; <em>e.g.</em> <code>#[derive(Clone)]</code>, <code>#[no_mangle]</code>, …</li>
<li><code># ! [ $arg ]</code>; <em>e.g.</em> <code>#![allow(dead_code)]</code>, <code>#![crate_name=&quot;blang&quot;]</code>, …</li>
<li><code>$name ! $arg</code>; <em>e.g.</em> <code>println!(&quot;Hi!&quot;)</code>, <code>concat!(&quot;a&quot;, &quot;b&quot;)</code>, …</li>
<li><code>$name ! $arg0 $arg1</code>; <em>e.g.</em> <code>macro_rules! dummy { () =&gt; {}; }</code>.</li>
</ul>
<p>头两个是 <em>attribute</em>,目前暂无法定义这两种形式</p>
<p>最后一种 只有  <code>macro_rules!</code>宏 是这种形式</p>
<p>只考虑第三种</p>
<pre><code>bitflags! {
    flags Color: u8 {
        const RED    = 0b0001,
        const GREEN  = 0b0010,
        const BLUE   = 0b0100,
        const BRIGHT = 0b1000,
    }
}

lazy_static! {
    static ref FIB_100: u32 = {
        fn fib(a: u32) -&gt; u32 {
            match a {
                0 =&gt; 0,
                1 =&gt; 1,
                a =&gt; fib(a-1) + fib(a-2)
            }
        }

        fib(100)
    };
}

fn main() {
    let colors = vec![RED, GREEN, BLUE];
    println!(&quot;Hello, World!&quot;);
}
</code></pre>
<p>Although the above invocations may <em>look</em> like they contain various kinds of Rust code, the parser simply sees a collection of meaningless token trees. To make this clearer, we can replace all these syntactic &quot;black boxes&quot; with ⬚, leaving us with:</p>
<pre><code class="language-text">bitflags! ⬚

lazy_static! ⬚

fn main() {
    let colors = vec! ⬚;
    println! ⬚;
}
</code></pre>
<p>重点是:</p>
<ul>
<li>rust有各种各样的语法扩展, 现在只讨论  <code>macro_rules!</code> 定义的约定</li>
<li><code>$name! $arg</code> 这种形式可能不是 宏, 而是某种形式的语法扩展</li>
<li>对 宏的输入 是一个 单一的 非叶子结点的 token tree</li>
</ul>
<p>宏只能出现在 明确定义支持的地方</p>
<ul>
<li>Patterns , 模式匹配</li>
<li>Statements 语句</li>
<li>Expressions 表达式</li>
<li>Items </li>
<li><code>impl</code> Items</li>
</ul>
<h2 id="展开"><a class="header" href="#展开">展开</a></h2>
<p>遍历AST, 定位 宏 然后展开</p>
<pre><code>let eight = 2 * four!();
</code></pre>
<p>We can visualise this partial AST as follows:</p>
<pre><code class="language-text">┌─────────────┐
│ Let         │
│ name: eight │   ┌─────────┐
│ init: ◌     │╶─╴│ BinOp   │
└─────────────┘   │ op: Mul │
                ┌╴│ lhs: ◌  │
     ┌────────┐ │ │ rhs: ◌  │╶┐ ┌────────────┐
     │ LitInt │╶┘ └─────────┘ └╴│ Macro      │
     │ val: 2 │                 │ name: four │
     └────────┘                 │ body: ()   │
                                └────────────┘
</code></pre>
<p>从上下文得知, 宏展开成一个 表达式</p>
<pre><code class="language-text">┌─────────────┐
│ Let         │
│ name: eight │   ┌─────────┐
│ init: ◌     │╶─╴│ BinOp   │
└─────────────┘   │ op: Mul │
                ┌╴│ lhs: ◌  │
     ┌────────┐ │ │ rhs: ◌  │╶┐ ┌─────────┐
     │ LitInt │╶┘ └─────────┘ └╴│ BinOp   │
     │ val: 2 │                 │ op: Add │
     └────────┘               ┌╴│ lhs: ◌  │
                   ┌────────┐ │ │ rhs: ◌  │╶┐ ┌────────┐
                   │ LitInt │╶┘ └─────────┘ └╴│ LitInt │
                   │ val: 1 │                 │ val: 3 │
                   └────────┘                 └────────┘
</code></pre>
<p>This can be written out like so:</p>
<pre><code>let eight = 2 * (1 + 3);
</code></pre>
<ul>
<li>宏展开会被当成语法 一个 AST的 node</li>
<li>宏还可以展开成 宏 , 递归宏 展开是有限度的, 默认最大32 #![recursion_limit=&quot;…&quot;]</li>
</ul>
<h1 id="macro_rules"><a class="header" href="#macro_rules">macro_rules!</a></h1>
<h2 id="语法-3"><a class="header" href="#语法-3">语法</a></h2>
<p><code>macro_rules!</code> 是自身的一个语法扩展, 不是rust的语法</p>
<pre><code>macro_rules! $name {
    $rule0 ;
    $rule1 ;
    // …
    $ruleN ;
}
</code></pre>
<p>至少有一个<code>rule</code> 最后一个<code>rule</code> 的分号可以省略</p>
<p>每一个<code>rule</code>的定义为</p>
<pre><code>    ($pattern) =&gt; {$expansion}
</code></pre>
<p>pattern周围的 <code>()</code> 和 expression 的 <code>{}</code> 是用来分组的, 可以任意替换使用</p>
<h2 id="matching"><a class="header" href="#matching">Matching</a></h2>
<p><strong>空模式</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>macro_rules! four {
    () =&gt; {1 + 3};
}
//four!(), four![] or four!{} 都行
<span class="boring">}
</span></code></pre></pre>
<p>匹配时不会考虑, 分组符号</p>
<p>模式同样能包好 字面 tokenTree ,必须精确匹配,通过简单正常编写 token tree 来完成</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>//例如
macro_rules! gibberish {
    (4 fn ['spang &quot;whammo&quot;] @_@) =&gt; {...};
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="captures"><a class="header" href="#captures">Captures</a></h2>
<p><strong>捕获标识</strong> 用  <code>$self_variable: type</code></p>
<p>type只能是以下几种</p>
<ul>
<li><code>item</code>: an item, like a function, struct, module, etc.</li>
<li><code>block</code>: a block (i.e. a block of statements and/or an expression, surrounded by braces)</li>
<li><code>stmt</code>: a statement</li>
<li><code>pat</code>: a pattern</li>
<li><code>expr</code>: an expression</li>
<li><code>ty</code>: a type</li>
<li><code>ident</code>: an identifier</li>
<li><code>path</code>: a path (e.g. <code>foo</code>, <code>::std::mem::replace</code>, <code>transmute::&lt;_, int&gt;</code>, …)</li>
<li><code>meta</code>: a meta item; the things that go inside <code>#[...]</code> and <code>#![...]</code> attributes</li>
<li><code>tt</code>: a single token tree</li>
</ul>
<p>For example, here is a macro which captures its input as an expression:</p>
<pre><code>macro_rules! one_expression {
    ($e:expr) =&gt; {...};
}
</code></pre>
<p>A capture <code>$name:kind</code> can be substituted into the expansion by writing <code>$name</code>. For example:</p>
<pre><code>macro_rules! times_five {
    ($e:expr) =&gt; {5 * $e};
}
</code></pre>
<p><strong>多捕获</strong></p>
<pre><code>macro_rules! multiply_add {
    ($a:expr, $b:expr, $c:expr) =&gt; {$a * ($b + $c)};
}
</code></pre>
<h2 id="repetitions"><a class="header" href="#repetitions"><a href="https://danielkeep.github.io/tlborm/book/mbe-macro-rules.html#repetitions">Repetitions</a></a></h2>
<p>重复标识</p>
<p>These allow a sequence of tokens to be matched. These have the general form</p>
<p><code>$ ( ... ) sep rep</code></p>
<ul>
<li><code>$</code> is a literal dollar token.</li>
<li><code>( ... )</code> is the paren-grouped pattern being repeated.</li>
<li><code>sep</code> is an <em>optional</em> separator token. Common examples are <code>,</code>, and <code>;</code>.</li>
<li><code>rep</code> is   <code>*</code>  或者 <code>+</code></li>
</ul>
<pre><code>macro_rules! vec_strs {
    (
        // Start a repetition:
        $(
            // Each repeat must contain an expression...
            $element:expr
        )
        // ...separated by commas...
        ,
        // ...zero or more times.
        *
    ) =&gt; {
        // Enclose the expansion in a block so that we can use
        // multiple statements.
        {
            let mut v = Vec::new();

            // Start a repetition:
            $(
                // Each repeat will contain the following statement, with
                // $element replaced with the corresponding expression.
                v.push(format!(&quot;{}&quot;, $element));
            )*

            v
        }
    };
}
</code></pre>
<h2 id="captures-and-expansion-redux"><a class="header" href="#captures-and-expansion-redux">Captures and Expansion Redux</a></h2>
<h3 id="第二个规则永远也不会匹配"><a class="header" href="#第二个规则永远也不会匹配"><strong>第二个规则永远也不会匹配</strong></a></h3>
<p>因为一个ident也是也是一个expr</p>
<pre><code>macro_rules! dead_rule {
    ($e:expr) =&gt; { ... };
    ($i:ident +) =&gt; { ... };
}
</code></pre>
<p>规则匹配的广度</p>
<ul>
<li><code>item</code>: anything.</li>
<li><code>block</code>: anything.</li>
<li><code>stmt</code>: <code>=&gt;</code> <code>,</code> <code>;</code></li>
<li><code>pat</code>: <code>=&gt;</code> <code>,</code> <code>=</code> <code>if</code> <code>in</code></li>
<li><code>expr</code>: <code>=&gt;</code> <code>,</code> <code>;</code></li>
<li><code>ty</code>: <code>,</code> <code>=&gt;</code> <code>:</code> <code>=</code> <code>&gt;</code> <code>;</code> <code>as</code></li>
<li><code>ident</code>: anything.</li>
<li><code>path</code>: <code>,</code> <code>=&gt;</code> <code>:</code> <code>=</code> <code>&gt;</code> <code>;</code> <code>as</code></li>
<li><code>meta</code>: anything.</li>
<li><code>tt</code>: anything.</li>
</ul>
<p>Additionally, <code>macro_rules!</code> generally forbids a repetition to be followed by another repetition, even if the contents do not conflict.</p>
<h3 id="捕获之后无法重新被捕获"><a class="header" href="#捕获之后无法重新被捕获">捕获之后无法重新被捕获</a></h3>
<p>One aspect of substitution that often surprises people is that substitution is <em>not</em> token-based, despite very much <em>looking</em> like it. Here is a simple demonstration:</p>
<pre><code>macro_rules! capture_expr_then_stringify {
    ($e:expr) =&gt; {
        stringify!($e)
    };
}

fn main() {
    println!(&quot;{:?}&quot;, stringify!(dummy(2 * (1 + (3)))));
    println!(&quot;{:?}&quot;, capture_expr_then_stringify!(dummy(2 * (1 + (3)))));
}
</code></pre>
<p>Note that <code>stringify!</code> is a built-in syntax extension which simply takes all tokens it is given and concatenates them into one big string.</p>
<p>The output when run is:</p>
<pre><code class="language-text">&quot;dummy ( 2 * ( 1 + ( 3 ) ) )&quot;
&quot;dummy(2 * (1 + (3)))&quot;
</code></pre>
<p>Note that <em>despite</em> having the same input, the output is different. This is because the first invocation is stringifying a sequence of token trees, whereas the second is stringifying <em>an AST expression node</em>.</p>
<p>To visualise the difference another way, here is what the <code>stringify!</code> macro gets invoked with in the first case:</p>
<pre><code class="language-text">«dummy» «(   )»
   ╭───────┴───────╮
    «2» «*» «(   )»
       ╭───────┴───────╮
        «1» «+» «(   )»
                 ╭─┴─╮
                  «3»
</code></pre>
<p>…and here is what it gets invoked with in the second case:</p>
<pre><code class="language-text">« »
 │ ┌─────────────┐
 └╴│ Call        │
   │ fn: dummy   │   ┌─────────┐
   │ args: ◌     │╶─╴│ BinOp   │
   └─────────────┘   │ op: Mul │
                   ┌╴│ lhs: ◌  │
        ┌────────┐ │ │ rhs: ◌  │╶┐ ┌─────────┐
        │ LitInt │╶┘ └─────────┘ └╴│ BinOp   │
        │ val: 2 │                 │ op: Add │
        └────────┘               ┌╴│ lhs: ◌  │
                      ┌────────┐ │ │ rhs: ◌  │╶┐ ┌────────┐
                      │ LitInt │╶┘ └─────────┘ └╴│ LitInt │
                      │ val: 1 │                 │ val: 3 │
                      └────────┘                 └────────┘
</code></pre>
<p>As you can see, there is exactly <em>one</em> token tree, which contains the AST which was parsed from the input to the <code>capture_expr_then_stringify!</code> invocation. Hence, what you see in the output is not the stringified tokens, it's the stringified <em>AST node</em>.</p>
<p>This has further implications. Consider the following:</p>
<pre><code>macro_rules! capture_then_match_tokens {
    ($e:expr) =&gt; {match_tokens!($e)};
}

macro_rules! match_tokens {
    ($a:tt + $b:tt) =&gt; {&quot;got an addition&quot;};
    (($i:ident)) =&gt; {&quot;got an identifier&quot;};
    ($($other:tt)*) =&gt; {&quot;got something else&quot;};
}

fn main() {
    println!(&quot;{}\n{}\n{}\n&quot;,
        match_tokens!((caravan)),
        match_tokens!(3 + 6),
        match_tokens!(5));
    println!(&quot;{}\n{}\n{}&quot;,
        capture_then_match_tokens!((caravan)),
        capture_then_match_tokens!(3 + 6),
        capture_then_match_tokens!(5));
}
</code></pre>
<p>The output is:</p>
<pre><code class="language-text">got an identifier
got an addition
got something else

got something else
got something else
got something else
</code></pre>
<p><strong>By parsing the input into an AST node, the substituted result becomes <em>un-destructible</em></strong>; <em>i.e.</em> you cannot examine the contents or match against it ever again.</p>
<p>Here is <em>another</em> example which can be particularly confusing:</p>
<pre><code>macro_rules! capture_then_what_is {
    (#[$m:meta]) =&gt; {what_is!(#[$m])};
}

macro_rules! what_is {
    (#[no_mangle]) =&gt; {&quot;no_mangle attribute&quot;};
    (#[inline]) =&gt; {&quot;inline attribute&quot;};
    ($($tts:tt)*) =&gt; {concat!(&quot;something else (&quot;, stringify!($($tts)*), &quot;)&quot;)};
}

fn main() {
    println!(
        &quot;{}\n{}\n{}\n{}&quot;,
        what_is!(#[no_mangle]),
        what_is!(#[inline]),
        capture_then_what_is!(#[no_mangle]),
        capture_then_what_is!(#[inline]),
    );
}
</code></pre>
<p>The output is:</p>
<pre><code class="language-text">no_mangle attribute
inline attribute
something else (# [ no_mangle ])
something else (# [ inline ])
</code></pre>
<p>The only way to avoid this is to capture using the <code>tt</code> or <code>ident</code> kinds. Once you capture with anything else, the only thing you can do with the result from then on is substitute it directly into the output.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="vectort"><a class="header" href="#vectort"><code>Vector&lt;T&gt;</code></a></h1>
<h2 id="新建vector"><a class="header" href="#新建vector">新建Vector</a></h2>
<pre><pre class="playground"><code class="language-rust">//新建一个空的 vector 来储存 i32 类型的值
#![allow(unused)]
fn main() {
let v: Vec&lt;i32&gt; = Vec::new();
}
</code></pre></pre>
<p><strong>使用宏</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let v = vec![1, 2, 3];
<span class="boring">}
</span></code></pre></pre>
<h2 id="更新-vector"><a class="header" href="#更新-vector">更新 vector</a></h2>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span>
<span class="boring">fn main() {
</span>let mut v = Vec::new();

v.push(5);
v.push(6);
<span class="boring">}
</span></code></pre></pre>
<h2 id="读取"><a class="header" href="#读取">读取</a></h2>
<p><strong>索引语法</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let v = vec![1, 2, 3, 4, 5];
let third: &amp;i32 = &amp;v[2];
println!(&quot;The third element is {}&quot;, third);
match v.get(2) {
    Some(third) =&gt; println!(&quot;The third element is {}&quot;, third),
    None =&gt; println!(&quot;There is no third element.&quot;),
}
<span class="boring">}
</span></code></pre></pre>
<p><strong>get语法</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let v = vec![1, 2, 3, 4, 5];

let does_not_exist = &amp;v[100];
let does_not_exist = v.get(100);
<span class="boring">}
</span></code></pre></pre>
<h2 id="集合中的-所有权检查"><a class="header" href="#集合中的-所有权检查">集合中的 所有权检查</a></h2>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>//编译会报错
let mut v = vec![1, 2, 3, 4, 5];

let first = &amp;v[0];

v.push(6);

println!(&quot;The first element is: {}&quot;, first);
<span class="boring">}
</span></code></pre></pre>
<p>在 vector 的结尾增加新元素时，在没有足够空间将所有所有元素依次相邻存放的情况下，可能会要求分配新内存并将老的元素拷贝到新的空间中。这时，第一个元素的引用就指向了被释放的内存。借用规则阻止程序陷入这种状况</p>
<h2 id="遍历"><a class="header" href="#遍历">遍历</a></h2>
<p><strong>可变遍历</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span>
<span class="boring">fn main() {
</span>let mut v = vec![100, 32, 57];
for i in &amp;mut v {
    *i += 50;
}
<span class="boring">}
</span></code></pre></pre>
<h1 id="string字符串"><a class="header" href="#string字符串">String字符串</a></h1>
<h2 id="什么是字符串类型"><a class="header" href="#什么是字符串类型">什么是字符串类型</a></h2>
<ul>
<li>Rust 的核心语言中只有一种字符串类型, <code>str</code></li>
<li>字符串 slice，它通常以被借用的形式出现 <code>&amp;str</code></li>
<li>称作 <code>String</code> 的类型是由标准库提供的,而没有写进核心语言部分，它是可增长的、可变的、有所有权的、UTF-8 编码的字符串类型</li>
</ul>
<h2 id="新建字符串"><a class="header" href="#新建字符串">新建字符串</a></h2>
<h3 id="new关键字"><a class="header" href="#new关键字">new关键字</a></h3>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut s = String::new();
<span class="boring">}
</span></code></pre></pre>
<h3 id="tostring转string"><a class="header" href="#tostring转string">toString()转string</a></h3>
<blockquote>
<p>用于任何实现了 Display的 trait</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span>
<span class="boring">fn main() {
</span>let data = &quot;initial contents&quot;;

let s = data.to_string();

// 该方法也可直接用于字符串字面值：
let s = &quot;initial contents&quot;.to_string();
<span class="boring">}
</span></code></pre></pre>
<h3 id="从字面量转string"><a class="header" href="#从字面量转string">从字面量转String</a></h3>
<blockquote>
<p>字符串是 UTF-8 编码的</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s = String::from(&quot;initial contents&quot;);
<span class="boring">}
</span></code></pre></pre>
<h2 id="更新字符串"><a class="header" href="#更新字符串">更新字符串</a></h2>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut s = String::from(&quot;foo&quot;);
s.push_str(&quot;bar&quot;);

let mut s1 = String::from(&quot;foo&quot;);
let s2 = &quot;bar&quot;;
s1.push_str(s2);
println!(&quot;s2 is {}&quot;, s2);


let mut s = String::from(&quot;lo&quot;);
s.push('l');
<span class="boring">}
</span></code></pre></pre>
<h2 id="拼接字符串"><a class="header" href="#拼接字符串">拼接字符串</a></h2>
<h3 id="使用加号运算符"><a class="header" href="#使用加号运算符">使用加号运算符</a></h3>
<blockquote>
<p>add函数</p>
</blockquote>
<pre><code>fn add(self, s: &amp;str) -&gt; String {
</code></pre>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s1 = String::from(&quot;Hello, &quot;);
let s2 = String::from(&quot;world!&quot;);
let s3 = s1 + &amp;s2; // 注意 s1 被移动了，不能继续使用
<span class="boring">}
</span></code></pre></pre>
<p><strong>所有权分析</strong></p>
<p>​	会取得第一个参数的所有权,然后将剩余的字符串复制在该字符串的后面</p>
<h2 id="索引字符串"><a class="header" href="#索引字符串">索引字符串</a></h2>
<blockquote>
<p><code>String</code> 是一个 <code>Vec&lt;u8&gt;</code> 的封装</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let len = String::from(&quot;Hola&quot;).len();

let hello = &quot;Здравствуйте&quot;;
let answer = &amp;hello[0];
<span class="boring">}
</span></code></pre></pre>
<p><strong>底层以字节存储</strong></p>
<p><strong>Rust 不允许使用索引获取 <code>String</code> 字符的原因是</strong></p>
<ul>
<li>
<p>索引操作预期总是需要常数时间 (O(1))。但是对于 <code>String</code> 不可能保证这样的性能</p>
</li>
<li>
<p>因为 Rust 必须从开头到索引位置遍历来确定有多少有效的字符</p>
</li>
</ul>
<h2 id="字符串-slice"><a class="header" href="#字符串-slice">字符串 slice</a></h2>
<blockquote>
<p>可以使用 <code>[]</code> 和一个 range 来创建含特定字节的字符串 slice：</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let hello = &quot;Здравствуйте&quot;;
let s = &amp;hello[0..4];
//访问也是按字节访问的
<span class="boring">}
</span></code></pre></pre>
<h2 id="字符串遍历"><a class="header" href="#字符串遍历">字符串遍历</a></h2>
<p>如果你需要操作单独的 <strong>Unicode 标量值</strong>，最好的选择是使用 <code>chars</code> 方法。对 “नमस्ते” 调用 chars 方法会将其分开并返回六个 char 类型的值</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span>
<span class="boring">fn main() {
</span>for c in &quot;नमस्ते&quot;.chars() {
    println!(&quot;{}&quot;, c);
}

//返回原始字节
for b in &quot;नमस्ते&quot;.bytes() {
    println!(&quot;{}&quot;, b);
}
<span class="boring">}
</span></code></pre></pre>
<h1 id="hashmap"><a class="header" href="#hashmap">HashMap</a></h1>
<h2 id="新建hashmap"><a class="header" href="#新建hashmap">新建HashMap</a></h2>
<h3 id="构造函数构建"><a class="header" href="#构造函数构建">构造函数构建</a></h3>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::collections::HashMap;
let mut scores = HashMap::new();
scores.insert(String::from(&quot;Blue&quot;), 10);
scores.insert(String::from(&quot;Yellow&quot;), 50);
<span class="boring">}
</span></code></pre></pre>
<h3 id="使用元组构建"><a class="header" href="#使用元组构建">使用元组构建</a></h3>
<blockquote>
<p>使用一个元组的 vector 的 <code>collect</code> 方法，其中每个元组包含一个键值对。<code>collect</code> 方法可以将数据收集进一系列的集合类型，包括 <code>HashMap</code></p>
</blockquote>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::collections::HashMap;
let teams  = vec![String::from(&quot;Blue&quot;), String::from(&quot;Yellow&quot;)];
let initial_scores = vec![10, 50];
//zip方法创建一个元组, 将两个vec按索引对应创建
let scores: HashMap&lt;_, _&gt; = teams.iter().zip(initial_scores.iter()).collect();
<span class="boring">}
</span></code></pre></pre>
<h2 id="hashmap所有权"><a class="header" href="#hashmap所有权">HashMap所有权</a></h2>
<ul>
<li>对于像 <code>i32</code> 这样的实现了 <code>Copy</code> trait 的类型，其值可以拷贝进哈希 map。</li>
<li>对于像 <code>String</code> 这样拥有所有权的值，其值将被移动而哈希 map 会成为这些值的所有者</li>
</ul>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::collections::HashMap;

let field_name = String::from(&quot;Favorite color&quot;);
let field_value = String::from(&quot;Blue&quot;);

let mut map = HashMap::new();
map.insert(field_name, field_value);
// 这里 field_name 和 field_value 不再有效，
// 尝试使用它们看看会出现什么编译错误
<span class="boring">}
</span></code></pre></pre>
<h2 id="hashmap访问"><a class="header" href="#hashmap访问">hashMap访问</a></h2>
<h3 id="get-返回-optionv"><a class="header" href="#get-返回-optionv"><code>get</code> 返回 <code>Option&lt;V&gt;</code></a></h3>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::collections::HashMap;

let mut scores = HashMap::new();

scores.insert(String::from(&quot;Blue&quot;), 10);
scores.insert(String::from(&quot;Yellow&quot;), 50);

let team_name = String::from(&quot;Blue&quot;);
let score = scores.get(&amp;team_name);
<span class="boring">}
</span></code></pre></pre>
<h3 id="遍历map"><a class="header" href="#遍历map"><em>遍历Map</em></a></h3>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>for (key, value) in &amp;scores {
    println!(&quot;{}: {}&quot;, key, value);
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="更新hashmap"><a class="header" href="#更新hashmap">更新HashMap</a></h2>
<h3 id="覆盖旧的键值"><a class="header" href="#覆盖旧的键值"><strong>覆盖旧的键值</strong></a></h3>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>scores.insert(String::from(&quot;Blue&quot;), 10);
scores.insert(String::from(&quot;Blue&quot;), 25);
<span class="boring">}
</span></code></pre></pre>
<h3 id="键不存在时插入"><a class="header" href="#键不存在时插入">键不存在时插入</a></h3>
<pre><pre class="playground"><code class="language-rust">
#![allow(unused)]
fn main() {
use std::collections::HashMap;

let mut scores = HashMap::new();
scores.insert(String::from(&quot;Blue&quot;), 10);

scores.entry(String::from(&quot;Yellow&quot;)).or_insert(50);
scores.entry(String::from(&quot;Blue&quot;)).or_insert(50);

println!(&quot;{:?}&quot;, scores);
}
</code></pre></pre>
<h3 id="根据旧值更新新值"><a class="header" href="#根据旧值更新新值">根据旧值更新新值</a></h3>
<p><code>or_insert</code> 方法事实上会返回这个键的值的一个可变引用（<code>&amp;mut V</code>）。这里我们将这个可变引用储存在 <code>count</code> 变量中</p>
<pre><pre class="playground"><code class="language-rust">
#![allow(unused)]
fn main() {
use std::collections::HashMap;

let text = &quot;hello world wonderful world&quot;;

let mut map = HashMap::new();

for word in text.split_whitespace() {
    let count = map.entry(word).or_insert(0);
    *count += 1;
}

println!(&quot;{:?}&quot;, map);
}
</code></pre></pre>
<h2 id="哈希函数"><a class="header" href="#哈希函数">哈希函数</a></h2>
<ul>
<li>
<p><code>HashMap</code> 默认使用一种 “密码学安全的”（“cryptographically strong” ）<a href="https://kaisery.github.io/trpl-zh-cn/ch08-03-hash-maps.html#siphash">1</a> 哈希函数，它可以抵抗拒绝服务（Denial of Service, DoS）攻击。</p>
</li>
<li>
<p>然而这并不是可用的最快的算法，不过为了更高的安全性值得付出一些性能的代价。</p>
</li>
<li>
<p>如果性能监测显示此哈希函数非常慢，以致于你无法接受，你可以指定一个不同的 <em>hasher</em> 来切换为其它函数。hasher 是一个实现了 <code>BuildHasher</code> trait 的类型</p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="模式由如下一些内容组合而成"><a class="header" href="#模式由如下一些内容组合而成">模式由如下一些内容组合而成</a></h1>
<ul>
<li>字面值</li>
<li>解构的数组、枚举、结构体或者元组</li>
<li>变量</li>
<li>通配符</li>
<li>占位符</li>
</ul>
<h1 id="模式匹配使用场景"><a class="header" href="#模式匹配使用场景">模式匹配使用场景</a></h1>
<h2 id="match-分支"><a class="header" href="#match-分支">match 分支</a></h2>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>match VALUE {
    PATTERN =&gt; EXPRESSION,
    PATTERN =&gt; EXPRESSION,
    PATTERN =&gt; EXPRESSION,
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="if-let-条件表达式"><a class="header" href="#if-let-条件表达式">if let 条件表达式</a></h2>
<blockquote>
<p>编写等同于只关心一个情况的 <code>match</code> 语句简写的</p>
</blockquote>
<ul>
<li>
<p>也可以组合并匹配 <code>if let</code>、<code>else if</code> 和 <code>else if let</code> 表达式。</p>
</li>
<li>
<p>这相比 <code>match</code> 表达式一次只能将一个值与模式比较提供了更多灵活性；</p>
</li>
<li>
<p>一系列 <code>if let</code>、<code>else if</code>、<code>else if let</code> 分支并不要求其条件相互关联</p>
</li>
</ul>
<h2 id="while-let-条件循环"><a class="header" href="#while-let-条件循环">while let 条件循环</a></h2>
<ul>
<li>示例一 : 定义一个 枚举集合 ,循环打印</li>
</ul>
<h2 id="for循环"><a class="header" href="#for循环">for循环</a></h2>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>for (index, value) in v.iter().enumerate() {
    println!(&quot;{} is at index {}&quot;, value, index);
}

for pattern in v.iter(){
	statement
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="let-语句"><a class="header" href="#let-语句">let 语句</a></h2>
<pre><code>let PATTERN = EXPRESSION;

let (x, y) = (1, 2, 3);
</code></pre>
<h2 id="函数参数-1"><a class="header" href="#函数参数-1">函数参数</a></h2>
<pre><pre class="playground"><code class="language-rust">fn print_coordinates(&amp;(x, y): &amp;(i32, i32)) {
    println!(&quot;Current location: ({}, {})&quot;, x, y);
}

fn main() {
    let point = (3, 5);
    print_coordinates(&amp;point);
}
</code></pre></pre>
<h2 id="可反驳性与非反驳性"><a class="header" href="#可反驳性与非反驳性">可反驳性与非反驳性</a></h2>
<ul>
<li>let 语句和 for 循环只能接受不可反驳的模式</li>
<li><em>if let<code>和</code>while let</em> 只接受 可反驳模式</li>
</ul>
<h2 id="变量覆盖"><a class="header" href="#变量覆盖">变量覆盖</a></h2>
<p><code>match</code> 会开始一个新作用域，<code>match</code> 表达式中作为模式的一部分声明的变量会覆盖 <code>match</code> 结构之外的同名变量</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let x = Some(5);
    let y = 10;

    match x {
        Some(50) =&gt; println!(&quot;Got 50&quot;),
        Some(y) =&gt; println!(&quot;Matched, y = {:?}&quot;, y),
        _ =&gt; println!(&quot;Default case, x = {:?}&quot;, x),
    }

    println!(&quot;at the end: x = {:?}, y = {:?}&quot;, x, y);
}
</code></pre></pre>
<h2 id="多模式"><a class="header" href="#多模式">多模式</a></h2>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span>
<span class="boring">fn main() {
</span>let x = 1;

match x {
    1 | 2 =&gt; println!(&quot;one or two&quot;),
    3 =&gt; println!(&quot;three&quot;),
    _ =&gt; println!(&quot;anything&quot;),
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="范围匹配"><a class="header" href="#范围匹配">范围匹配</a></h2>
<blockquote>
<p>只允许数字和char</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span>
<span class="boring">fn main() {
</span>let x = 5;

match x {
    1..=5 =&gt; println!(&quot;one through five&quot;),
    _ =&gt; println!(&quot;something else&quot;),
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="匹配结构体"><a class="header" href="#匹配结构体">匹配结构体</a></h2>
<pre><pre class="playground"><code class="language-rust">struct Point {
    x: i32,
    y: i32,
}

fn main() {
    let p = Point { x: 0, y: 7 };

    let Point { x: a, y: b } = p;
    assert_eq!(0, a);
    assert_eq!(7, b);
}
</code></pre></pre>
<h2 id="匹配枚举"><a class="header" href="#匹配枚举">匹配枚举</a></h2>
<pre><pre class="playground"><code class="language-rust">enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(i32, i32, i32),
}

fn main() {
    let msg = Message::ChangeColor(0, 160, 255);

    match msg {
        Message::Quit =&gt; {
            println!(&quot;The Quit variant has no data to destructure.&quot;)
        }
        Message::Move { x, y } =&gt; {
            println!(
                &quot;Move in the x direction {} and in the y direction {}&quot;,
                x,
                y
            );
        }
        Message::Write(text) =&gt; println!(&quot;Text message: {}&quot;, text),
        Message::ChangeColor(r, g, b) =&gt; {
            println!(
                &quot;Change the color to red {}, green {}, and blue {}&quot;,
                r,
                g,
                b
            )
        }
    }
}
</code></pre></pre>
<h2 id="嵌套匹配"><a class="header" href="#嵌套匹配">嵌套匹配</a></h2>
<pre><pre class="playground"><code class="language-rust">
#![allow(unused)]
fn main() {
struct Point {
    x: i32,
    y: i32,
}

let ((feet, inches), Point {x, y}) = ((3, 10), Point { x: 3, y: -10 });
}

</code></pre></pre>
<h2 id="忽略模式"><a class="header" href="#忽略模式">忽略模式</a></h2>
<pre><pre class="playground"><code class="language-rust">//忽略函数参数
fn foo(_: i32, y: i32) {
    println!(&quot;This code only uses the y parameter: {}&quot;, y);
}

fn main() {
    foo(3, 4);
}

</code></pre></pre>
<p><strong>嵌套忽略</strong></p>
<pre><pre class="playground"><code class="language-rust">
#![allow(unused)]
fn main() {
let mut setting_value = Some(5);
let new_setting_value = Some(10);

match (setting_value, new_setting_value) {
    (Some(_), Some(_)) =&gt; {
        println!(&quot;Can't overwrite an existing customized value&quot;);
    }
    _ =&gt; {
        setting_value = new_setting_value;
    }
}

println!(&quot;setting is {:?}&quot;, setting_value);
}

#![allow(unused)]
fn main() {
let mut setting_value = Some(5);
let new_setting_value = Some(10);

match (setting_value, new_setting_value) {
    (Some(_), Some(_)) =&gt; {
        println!(&quot;Can't overwrite an existing customized value&quot;);
    }
    _ =&gt; {
        setting_value = new_setting_value;
    }
}

println!(&quot;setting is {:?}&quot;, setting_value);
}

</code></pre></pre>
<p><strong>忽略元组多个部分</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let numbers = (2, 4, 8, 16, 32);

match numbers {
    (first, _, third, _, fifth) =&gt; {
        println!(&quot;Some numbers: {}, {}, {}&quot;, first, third, fifth)
    },
}
<span class="boring">}
</span></code></pre></pre>
<p><strong>_下划线开头的变量,可以避免编译器警告</strong></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let _x = 5;
    let y = 10;
}
</code></pre></pre>
<p><strong>用 .. 忽略剩余值</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Point {
    x: i32,
    y: i32,
    z: i32,
}

let origin = Point { x: 0, y: 0, z: 0 };

match origin {
    Point { x, .. } =&gt; println!(&quot;x is {}&quot;, x),
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="匹配守卫"><a class="header" href="#匹配守卫">匹配守卫</a></h2>
<h3 id="条件匹配"><a class="header" href="#条件匹配">条件匹配</a></h3>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let num = Some(4);

match num {
    Some(x) if x &lt; 5 =&gt; println!(&quot;less than five: {}&quot;, x),
    Some(x) =&gt; println!(&quot;{}&quot;, x),
    None =&gt; (),
}
<span class="boring">}
</span></code></pre></pre>
<h3 id="范围匹配-1"><a class="header" href="#范围匹配-1">范围匹配</a></h3>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>match msg {
    Message::Hello { id: id_variable @ 3..=7 } =&gt; {
        println!(&quot;Found an id in range: {}&quot;, id_variable)
    },
    Message::Hello { id: 10..=12 } =&gt; {
        println!(&quot;Found an id in another range&quot;)
    },
    Message::Hello { id } =&gt; {
        println!(&quot;Found some other id: {}&quot;, id)
    },
}
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="泛型的使用"><a class="header" href="#泛型的使用">泛型的使用</a></h1>
<h2 id="函数泛型定义与使用"><a class="header" href="#函数泛型定义与使用"><strong>函数泛型定义与使用</strong></a></h2>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>//定义,写在函数名后面, 使用在函数的任何地方
fn largest&lt;T&gt;(list: &amp;[T]) -&gt; T {
    let mut largest = list[0];
    for &amp;item in list.iter() {
        if item &gt; largest {
            largest = item;
        }
    }
    largest
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="结构体泛型定义与使用"><a class="header" href="#结构体泛型定义与使用"><strong>结构体泛型定义与使用</strong></a></h2>
<pre><pre class="playground"><code class="language-rust">struct Point&lt;T&gt; {
    x: T,
    y: T,
}

fn main() {
    let wont_work = Point { x: 5, y: 4.0 };
}
</code></pre></pre>
<h2 id="枚举定义的泛型"><a class="header" href="#枚举定义的泛型">枚举定义的泛型</a></h2>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Option&lt;T&gt; {
    Some(T),
    None,
}
enum Result&lt;T, E&gt; {
    Ok(T),
    Err(E),
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="方法实现中的泛型定义"><a class="header" href="#方法实现中的泛型定义">方法实现中的泛型定义</a></h2>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Point&lt;T&gt; {
x: T,
y: T,
}


impl Point&lt;f32&gt; {
    fn distance_from_origin(&amp;self) -&gt; f32 {
        (self.x.powi(2) + self.y.powi(2)).sqrt()
    }
}

impl&lt;T&gt; Point&lt;T&gt; {
    fn x(&amp;self) -&gt; &amp;T {
        &amp;self.x
    }
}

//产生新泛型
struct Point&lt;T, U&gt; {
    x: T,
    y: U,
}

impl&lt;T, U&gt; Point&lt;T, U&gt; {
    fn mixup&lt;V, W&gt;(self, other: Point&lt;V, W&gt;) -&gt; Point&lt;T, W&gt; {
        Point {
            x: self.x,
            y: other.y,
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="泛型代码的性能"><a class="header" href="#泛型代码的性能">泛型代码的性能</a></h2>
<ul>
<li>Rust 实现了泛型，使得使用泛型类型参数的代码相比使用具体类型并没有任何速度上的损失。</li>
<li>Rust 通过在编译时进行泛型代码的 <strong>单态化</strong>（<em>monomorphization</em>）来保证效率。单态化是一个通过填充编译时使用的具体类型，将通用代码转换为特定代码的过程。</li>
<li>编译器寻找所有泛型代码被调用的位置并使用泛型代码针对具体类型生成代码。</li>
</ul>
<p>让我们看看一个使用标准库中 <code>Option</code> 枚举的例子：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let integer = Some(5);
let float = Some(5.0);
<span class="boring">}
</span></code></pre></pre>
<p>编译器会读取传递给 <code>Option&lt;T&gt;</code> 的值并发现有两种 <code>Option&lt;T&gt;</code>：一个对应 <code>i32</code> 另一个对应 <code>f64</code></p>
<p>为此，它会将泛型定义 <code>Option&lt;T&gt;</code> 展开为 <code>Option_i32</code> 和 <code>Option_f64</code>，接着将泛型定义替换为这两个具体的定义。</p>
<h1 id="trait特性"><a class="header" href="#trait特性">Trait(特性)</a></h1>
<h2 id="定义"><a class="header" href="#定义">定义</a></h2>
<ul>
<li>
<p>一个类型的行为由其可供调用的方法构成。</p>
</li>
<li>
<p>如果可以<strong>对不同类型调用相同的方法</strong>的话，这些类型就可以共享相同的行为了。</p>
</li>
<li>
<p>trait 定义是一种将方法签名组合起来的方法，目的是定义一个实现某些目的所必需的行为的集合。</p>
</li>
</ul>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>//trait 体中可以有多个方法
pub trait Summary {
    fn summarize(&amp;self) -&gt; String;
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="为结构体实现trait"><a class="header" href="#为结构体实现trait">为结构体实现<em>Trait</em></a></h2>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct NewsArticle {
    pub headline: String,
    pub location: String,
    pub author: String,
    pub content: String,
}

impl Summary for NewsArticle {
    fn summarize(&amp;self) -&gt; String {
        format!(&quot;{}, by {} ({})&quot;, self.headline, self.author, self.location)
    }
}

pub struct Tweet {
    pub username: String,
    pub content: String,
    pub reply: bool,
    pub retweet: bool,
}

impl Summary for Tweet {
    fn summarize(&amp;self) -&gt; String {
        format!(&quot;{}: {}&quot;, self.username, self.content)
    }
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="trait-的相干性"><a class="header" href="#trait-的相干性">trait 的相干性</a></h2>
<ul>
<li>不能为 外部类型(第三方) 实现 外部 （第三方）trait
<ul>
<li>例如 <em>不能在 <code>aggregator</code> crate 中为 <code>Vec&lt;T&gt;</code> 实现 <code>Display</code> trait</em></li>
<li>因为 <code>Display</code> 和 <code>Vec&lt;T&gt;</code> 都定义于标准库中</li>
<li>并不位于 <code>aggregator</code> crate 本地作用域中</li>
<li>这个限制是被称为 <strong>相干性</strong>（<em>coherence</em>） 更具体的说是 <strong>孤儿规则</strong>（<em>orphan rule</em>）</li>
<li>这条规则确保了其他人编写的代码不会破坏你代码</li>
</ul>
</li>
</ul>
<h2 id="trait-的默认实现"><a class="header" href="#trait-的默认实现">Trait 的默认实现</a></h2>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Summary {
    fn summarize(&amp;self) -&gt; String {
        String::from(&quot;(Read more...)&quot;)
    }
}
<span class="boring">}
</span></code></pre></pre>
<p><strong>默认方法与抽象方法共存</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span>
<span class="boring">fn main() {
</span>pub trait Summary {
    fn summarize_author(&amp;self) -&gt; String;

    fn summarize(&amp;self) -&gt; String {
        format!(&quot;(Read more from {}...)&quot;, self.summarize_author())
    }
}
<span class="boring">}
</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Summary{
     fn summary(&amp;self) -&gt; String{
        String::from(&quot;read more&quot;)
    }
}
impl Summary for Book{

}
<span class="boring">}
</span></code></pre></pre>
<h2 id="trait-作为参数"><a class="header" href="#trait-作为参数">Trait 作为参数</a></h2>
<h3 id="traitbound-语法糖"><a class="header" href="#traitbound-语法糖">TraitBound 语法糖</a></h3>
<blockquote>
<p>与 <em>impl Summary</em> 是一样</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn notify&lt;T: Summary&gt;(item: T) {
    println!(&quot;Breaking news! {}&quot;, item.summarize());
}
<span class="boring">}
</span></code></pre></pre>
<pre><code>pub fn notify(item1: impl Summary, item2: impl Summary) {
与
pub fn notify&lt;T: Summary&gt;(item1: T, item2: T) {
</code></pre>
<p><strong>通过 + 号 指定多个</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn notify(item: impl Summary + Display) {
与
pub fn notify&lt;T: Summary + Display&gt;(item: T) {
<span class="boring">}
</span></code></pre></pre>
<p><strong>通过 where 简化 trait bound</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn some_function&lt;T: Display + Clone, U: Clone + Debug&gt;(t: T, u: U) -&gt; i32 {
与

fn some_function&lt;T, U&gt;(t: T, u: U) -&gt; i32
    where T: Display + Clone,
          U: Clone + Debug
{
<span class="boring">}
</span></code></pre></pre>
<h3 id="函数参数-2"><a class="header" href="#函数参数-2">函数参数</a></h3>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn notify(item: impl Summary) {
    println!(&quot;Breaking news! {}&quot;, item.summarize());
}
<span class="boring">}
</span></code></pre></pre>
<h3 id="返回类型"><a class="header" href="#返回类型">返回类型</a></h3>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn returns_summarizable() -&gt; impl Summary {
    Tweet {
        username: String::from(&quot;horse_ebooks&quot;),
        content: String::from(&quot;of course, as you probably already know, people&quot;),
        reply: false,
        retweet: false,
    }
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="使用-trait-bound-有条件地实现方法"><a class="header" href="#使用-trait-bound-有条件地实现方法">使用 trait bound 有条件地实现方法</a></h2>
<blockquote>
<p>限定泛型的实现 类型</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::fmt::Display;

struct Pair&lt;T&gt; {
    x: T,
    y: T,
}

impl&lt;T&gt; Pair&lt;T&gt; {
    fn new(x: T, y: T) -&gt; Self {
        Self {
            x,
            y,
        }
    }
}

impl&lt;T: Display + PartialOrd&gt; Pair&lt;T&gt; {
    fn cmp_display(&amp;self) {
        if self.x &gt;= self.y {
            println!(&quot;The largest member is x = {}&quot;, self.x);
        } else {
            println!(&quot;The largest member is y = {}&quot;, self.y);
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p><strong>例如</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>//标准库为任何实现了 Display trait 的类型实现了 ToString trait。这个 impl 块看起来像这样：
impl&lt;T: Display&gt; ToString for T {
    // --snip--
}
//因为标准库有了这些 blanket implementation，我们可以对任何实现了 Display trait 的类型调用由 ToString 定义的 to_string 方法。例如，可以将整型转换为对应的 String 值，因为整型实现了 Display：
<span class="boring">}
</span></code></pre></pre>
<h2 id="dyn-trait-trait-对象"><a class="header" href="#dyn-trait-trait-对象">dyn Trait trait 对象</a></h2>
<p><code>dyn Trait</code> 是使用 trait 对象的新语法，简而言之：</p>
<ul>
<li><code>Box&lt;Trait&gt;</code> becomes <code>Box&lt;dyn Trait&gt;</code></li>
<li><code>&amp;Trait</code> and <code>&amp;mut Trait</code> become <code>&amp;dyn Trait</code> and <code>&amp;mut dyn Trait</code></li>
</ul>
<h1 id="标准库中的-trait"><a class="header" href="#标准库中的-trait">标准库中的 <em>Trait</em></a></h1>
<h2 id="debug详细打印"><a class="header" href="#debug详细打印">Debug详细打印</a></h2>
<p><code>Debug</code> trait 用于开启格式化字符串中的调试格式，其通过在 <code>{}</code> 占位符中增加 <code>:?</code> 表明。</p>
<p>需要实现 <code>Debug</code> 的 <code>fmt</code></p>
<pre><code>impl Debug for Address{
    fn fmt(&amp;self, f: &amp;mut Formatter&lt;'_&gt;) -&gt; Result&lt;(), Error&gt; {
        write!(f,&quot;a={}&quot;,self.home)
    }
}
</code></pre>
<h2 id="等值比较"><a class="header" href="#等值比较">等值比较</a></h2>
<p><a href="https://rustcc.cn/article?id=9a1990b9-e86a-46df-a3c3-fcfaff3c8533"><em>相关解释</em></a> </p>
<h2 id="partitaleq"><a class="header" href="#partitaleq"><code>PartitalEq</code></a></h2>
<blockquote>
<p>派生的 <code>PartialEq</code> 实现了 <code>eq</code> 方法。</p>
</blockquote>
<ul>
<li>当 <code>PartialEq</code> 在结构体上派生时，只有<em>所有</em> 的字段都相等时两个实例才相等。</li>
<li>当在枚举上派生时，每一个成员都和其自身相等，且和其他成员都不相等。</li>
</ul>
<h2 id="eq"><a class="header" href="#eq"><code>Eq</code></a></h2>
<p>Eq 相比 PartialEq 需要额外满足反身性，即 <code>a == a</code>，对于浮点类型，Rust 只实现了 PartialEq 而不是 Eq，原因就是 <code>NaN != NaN</code>。</p>
<h2 id="ord--partialord"><a class="header" href="#ord--partialord"><code>Ord &amp; PartialOrd</code></a></h2>
<p>类似于 Eq，Ord 指的是 <a href="https://en.wikipedia.org/wiki/Total_order">Total Order</a>，需要满足以下三个性质：</p>
<ul>
<li>反对称性（Antisymmetry）：<code>a &lt;= b</code> 且 <code>a &gt;= b</code> 可推出 <code>a == b</code></li>
<li>传递性（Transitivity）：<code>a &lt;= b</code> 且 <code>b &lt;= c</code> 可推出 <code>a &lt;= c</code></li>
<li>连通性（Connexity）：<code>a &lt;= b</code> 或 <code>a &gt;= b</code></li>
</ul>
<p>而 PartialOrd 无需满足连通性，只满足反对称性和传递性即可。</p>
<ul>
<li>反对称性：<code>a &lt; b</code> 则有 <code>!(a &gt; b)</code>，反之亦然</li>
<li>传递性：<code>a &lt; b</code> 且 <code>b &lt; c</code> 可推出 <code>a &lt; c</code>，<code>==</code> 和 <code>&gt;</code> 同理</li>
</ul>
<h2 id="复制值的-clone-和-copy"><a class="header" href="#复制值的-clone-和-copy">复制值的 <code>Clone</code> 和 <code>Copy</code></a></h2>
<ul>
<li>可以明确地创建一个值的深拷贝（deep copy），复制过程可能包含任意代码的执行以及堆上数据的复制</li>
<li>派生 <code>Clone</code> 实现了 <code>clone</code> 方法，其为整个的类型实现时，在类型的每一部分上调用了 <code>clone</code> 方法。这意味着类型中所有字段或值也必须实现了 <code>Clone</code>，这样才能够派生 <code>Clone</code> 。</li>
</ul>
<p><strong>切片转集合时需要clone</strong></p>
<p>当在一个切片（slice）上调用 to_vec 方法时，Clone 是必须的。切片并不拥有其所包含实例的类型，但是从 to_vec 中返回的 vector 需要拥有其实例，因此，to_vec 在每个元素上调用 clone。因此，存储在切片中的类型必须实现 Clone。</p>
<p><strong>拷贝存储在栈上的数据不需要额外代码</strong></p>
<p><code>Copy</code> trait 允许你通过只拷贝存储在栈上的位来复制值而不需要额外的代码。查阅第四章 <a href="https://kaisery.github.io/trpl-zh-cn/ch04-01-what-is-ownership.html#stack-only-data-copy">“只在栈上的数据：拷贝”</a> 的部分来获取有关 <code>Copy</code> 的更多信息。</p>
<h2 id="固定大小的值到值映射的-hash"><a class="header" href="#固定大小的值到值映射的-hash">固定大小的值到值映射的 Hash</a></h2>
<ul>
<li>
<p><code>Hash</code> trait 可以实例化一个任意大小的类型，并且能够用哈希（hash）函数将该实例映射到一个固定大小的值上。</p>
</li>
<li>
<p>派生 <code>Hash</code> 实现了 <code>hash</code> 方法。<code>hash</code> 方法的派生实现结合了在类型的每部分调用 <code>hash</code> 的结果，这意味着所有的字段或值也必须实现了 <code>Hash</code>，这样才能够派生 <code>Hash</code>。</p>
</li>
</ul>
<blockquote>
<p>例如，在 <code>HashMap&lt;K, V&gt;</code> 上存储数据，存放 key 的时候，<code>Hash</code> 是必须的。</p>
</blockquote>
<h2 id="默认值的-default"><a class="header" href="#默认值的-default">默认值的 <code>Default</code></a></h2>
<p>*　<code>Default</code> trait 使你创建一个类型的默认值</p>
<p><strong>使用</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn  test_default(){
    let person = Person {..Default::default()};
    println!(&quot;{:?}&quot;,person);
}
#[derive(Debug)]
struct Person{
    age:i32,
    name:String,
    address:String
}

impl Default for Person{
    fn default() -&gt; Self {
        Person{
            age:18,
            name:&quot;ssss&quot;.to_owned(),
            address: &quot;&quot;.to_owned()
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="trait-对象执行动态分发"><a class="header" href="#trait-对象执行动态分发">trait 对象执行动态分发</a></h2>
<ol>
<li>
<p>当对泛型使用 trait bound 时编译器所进行单态化处理：编译器为每一个被泛型类型参数代替的具体类型生成了非泛型的函数和方法实现。</p>
</li>
<li>
<p>单态化所产生的代码进行 <strong>静态分发</strong>（<em>static dispatch</em>）</p>
</li>
<li>
<p>静态分发发生于编译器在编译时就知晓调用了什么方法的时候。这与 <strong>动态分发</strong> （<em>dynamic dispatch</em>）相对，这时编译器在编译时无法知晓调用了什么方法。在动态分发的情况下，编译器会生成在运行时确定调用了什么方法的代码。</p>
</li>
</ol>
<p><strong>当使用 trait 对象时，Rust 必须使用动态分发</strong></p>
<h2 id="trait-对象要求对象安全"><a class="header" href="#trait-对象要求对象安全">Trait 对象要求对象安全</a></h2>
<p>只有 <strong>对象安全</strong>（<em>object safe</em>）的 trait 才可以组成 trait 对象</p>
<p>如果一个 trait 中所有的方法有如下属性时，则该 trait 是对象安全的：</p>
<ul>
<li>返回值类型不为 <code>Self</code></li>
<li>方法没有任何泛型类型参数</li>
</ul>
<p>一个 trait 的方法不是对象安全的例子是<strong>标准库中的 <code>Clone</code> trait</strong>。<code>Clone</code> trait 的 <code>clone</code> 方法的参数签名看起来像这样：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Clone {
    fn clone(&amp;self) -&gt; Self;
}
<span class="boring">}
</span></code></pre></pre>
<h1 id="高级trait"><a class="header" href="#高级trait">高级Trait</a></h1>
<h2 id="trait中的关联类型"><a class="header" href="#trait中的关联类型">trait中的关联类型</a></h2>
<p><strong>干什么用的?</strong></p>
<ul>
<li>提供类似泛型的作用</li>
<li>提供迭代的子类型</li>
<li><code>Item</code> 是一个占位类型,在编译时期,会根据具体的实现类去替换</li>
</ul>
<p><strong>怎么使用的?</strong></p>
<p><strong>定义</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span>
<span class="boring">fn main() {
</span>pub trait Iterator {
    type Item;

    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt;;
}
<span class="boring">}
</span></code></pre></pre>
<p><strong>使用</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>mpl Iterator for Counter {
    type Item = u32;

    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
<span class="boring">}
</span></code></pre></pre>
<h3 id="为什么会要有定义这个而不使用泛型"><a class="header" href="#为什么会要有定义这个而不使用泛型"><strong>为什么会要有定义这个而不使用泛型?</strong></a></h3>
<p>如果使用泛型 的话,每次调用 next方法都得指定泛型具体类型</p>
<h2 id="默认类型参数"><a class="header" href="#默认类型参数">默认类型参数</a></h2>
<h3 id="干嘛用的"><a class="header" href="#干嘛用的"><strong>干嘛用的?</strong></a></h3>
<ul>
<li>当使用泛型类型参数时，可以为泛型指定一个默认的具体类型。如果默认类型就足够的话，这消除了为具体类型实现 trait 的需要</li>
</ul>
<h3 id="如何使用"><a class="header" href="#如何使用"><strong>如何使用</strong></a></h3>
<p><strong>定义默认类型参数</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>//定义,RHS参数默认使用 实现该Trait 的 类型 
trait Add&lt;RHS=Self&gt; {
    type Output;
    fn add(self, rhs: RHS) -&gt; Self::Output;
}

<span class="boring">}
</span></code></pre></pre>
<p><strong>使用默认类型参数</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span>
<span class="boring">fn main() {
</span>#[derive(Debug, PartialEq)]
struct Point {
    x: i32,
    y: i32,
}

impl Add for Point {
    type Output = Point;

    fn add(self, other: Point) -&gt; Point {
        Point {
            x: self.x + other.x,
            y: self.y + other.y,
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p><strong>使用自定义类型参数</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::ops::Add;

struct Millimeters(u32);
struct Meters(u32);

impl Add&lt;Meters&gt; for Millimeters {
    type Output = Millimeters;

    fn add(self, other: Meters) -&gt; Millimeters {
        Millimeters(self.0 + (other.0 * 1000))
    }
}
<span class="boring">}
</span></code></pre></pre>
<p><strong>为什么要引入这个</strong></p>
<ul>
<li>一小部分实现的样板代码是不必要的，这样使用 trait 就更容易了,减少不必要的泛型类型</li>
<li>扩展类型而不破坏现有代码。</li>
</ul>
<h2 id="完全限定语法"><a class="header" href="#完全限定语法">完全限定语法</a></h2>
<h3 id="干嘛用的-1"><a class="header" href="#干嘛用的-1"><strong>干嘛用的?</strong></a></h3>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span>
<span class="boring">fn main() {
</span>trait Pilot {
    fn fly(&amp;self);
}

trait Wizard {
    fn fly(&amp;self);
}

struct Human;

impl Pilot for Human {
    fn fly(&amp;self) {
        println!(&quot;This is your captain speaking.&quot;);
    }
}

impl Wizard for Human {
    fn fly(&amp;self) {
        println!(&quot;Up!&quot;);
    }
}

impl Human {
    fn fly(&amp;self) {
        println!(&quot;*waving arms furiously*&quot;);
    }
}
<span class="boring">}
</span></code></pre></pre>
<ul>
<li>当一个类上实现了多个方法,编译器默认调用 使用 <code>impl Type</code> 中的方法</li>
<li>使用 完全限定语法可以调用 其他 <code>Trait</code>的方法</li>
</ul>
<h3 id="如何使用-1"><a class="header" href="#如何使用-1"><strong>如何使用?</strong></a></h3>
<p><strong>全语法</strong></p>
<p><code>&lt;Type as Trait&gt;::function(receiver_if_method, next_arg, ...);</code></p>
<p><strong>使用(类型定义见上)</strong></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let person = Human;
    Pilot::fly(&amp;person);
    Wizard::fly(&amp;person);
    person.fly();
}
</code></pre></pre>
<p><strong>使用2</strong></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    println!(&quot;A baby dog is called a {}&quot;, &lt;Dog as Animal&gt;::baby_name());
}
</code></pre></pre>
<h2 id="trait中的继承"><a class="header" href="#trait中的继承">Trait中的继承</a></h2>
<h3 id="干什么用的"><a class="header" href="#干什么用的"><strong>干什么用的?</strong></a></h3>
<ul>
<li>
<p>用于在另一个 trait 中使用某 trait 的功能</p>
</li>
<li>
<p><code>Trait</code> 定义指定了 要实现它就 必须先 实现 <code>Display</code></p>
</li>
</ul>
<h3 id="如何使用-2"><a class="header" href="#如何使用-2">如何使用</a></h3>
<p><strong>定义</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::fmt;

trait OutlinePrint: fmt::Display {
    fn outline_print(&amp;self) {
        let output = self.to_string();
        let len = output.len();
        println!(&quot;{}&quot;, &quot;*&quot;.repeat(len + 4));
        println!(&quot;*{}*&quot;, &quot; &quot;.repeat(len + 2));
        println!(&quot;* {} *&quot;, output);
        println!(&quot;*{}*&quot;, &quot; &quot;.repeat(len + 2));
        println!(&quot;{}&quot;, &quot;*&quot;.repeat(len + 4));
    }
}
<span class="boring">}
</span></code></pre></pre>
<p><strong>使用</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Point {
    x: i32,
    y: i32,
}
impl OutlinePrint for Point {}
<span class="boring">}
</span></code></pre></pre>
<h3 id="为什么要定义这个"><a class="header" href="#为什么要定义这个">为什么要定义这个</a></h3>
<ul>
<li><strong>广义上来说是为了 重用代码</strong></li>
<li>狭义上 就是实现某一trait 需要依赖另一个 <em>trait</em></li>
<li>类似于继承的概念</li>
</ul>
<h2 id="解决为-外部类型-实现外部-trait"><a class="header" href="#解决为-外部类型-实现外部-trait">解决为 外部类型 实现外部 Trait</a></h2>
<h3 id="背景"><a class="header" href="#背景">背景</a></h3>
<p><strong>外部类型或Trait</strong></p>
<p>即非本地的, 例如标准库,第三方库的类型或Trait</p>
<p><strong>孤儿规则</strong> (orphan rule)</p>
<ul>
<li>不能为外部类型,实现外部trait</li>
<li>避免本地库 影响第三方库的行为</li>
</ul>
<p><strong>什么是<em>newType</em> 模式</strong></p>
<p><strong>举例</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>//常规定义
struct Person{
	age:u32,
	address:String
}
//newType定义
struct Person{
	age:Year,
	address:Address
}

struct Year(u32);
struct Address(String);
<span class="boring">}
</span></code></pre></pre>
<p><strong>说明</strong></p>
<ul>
<li>
<p><strong>使用这个模式没有运行时性能惩罚，这个封装类型在编译时就被省略了。</strong></p>
</li>
<li>
<p>在编写代码时,很快就能知道 某个字段的具体 业务含义</p>
</li>
<li>
<p><strong>nwType模式可以在外部类型上实现外部Trait</strong></p>
</li>
</ul>
<h3 id="如何使用-3"><a class="header" href="#如何使用-3"><strong>如何使用</strong></a></h3>
<pre><pre class="playground"><code class="language-rust">use std::fmt;

struct Wrapper(Vec&lt;String&gt;);

impl fmt::Display for Wrapper {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
        write!(f, &quot;[{}]&quot;, self.0.join(&quot;, &quot;))
    }
}

fn main() {
    let w = Wrapper(vec![String::from(&quot;hello&quot;), String::from(&quot;world&quot;)]);
    println!(&quot;w = {}&quot;, w);
}
</code></pre></pre>
<ul>
<li>
<p><code>Display</code> 的实现使用 <strong><code>self.0</code> 来访问其内部的 <code>Vec&lt;T&gt;</code></strong></p>
</li>
<li>
<p>此方法的缺点是，因为 <strong><code>Wrapper</code> 是一个新类型，它没有定义于其值之上的方法</strong>；必须直接在 <code>Wrapper</code> 上实现 <code>Vec&lt;T&gt;</code> 的所有方法，这样就可以代理到<code>self.0</code> 上 </p>
</li>
<li>
<p>如果希望<strong>新类型拥有其内部类型的每一个方法</strong>，为封装类型实现 <code>Deref</code> trait（第十五章 <a href="https://kaisery.github.io/trpl-zh-cn/ch15-02-deref.html#treating-smart-pointers-like-regular-references-with-the-deref-trait">“通过 <code>Deref</code> trait 将智能指针当作常规引用处理”</a> 部分讨论过）并返回其内部类型是一种解决方案。</p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="结构体"><a class="header" href="#结构体">结构体</a></h1>
<h2 id="定义-1"><a class="header" href="#定义-1"><strong>定义</strong></a></h2>
<pre><pre class="playground"><code class="language-rust">fn main() {
struct User {
    username: String,
    email: String,
    sign_in_count: u64,
    active: bool,
}
}
</code></pre></pre>
<h2 id="使用-1"><a class="header" href="#使用-1"><strong>使用</strong></a></h2>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let user1 = User {
    email: String::from(&quot;someone@example.com&quot;),
    username: String::from(&quot;someusername123&quot;),
    active: true,
    sign_in_count: 1,
};
<span class="boring">}
</span></code></pre></pre>
<h2 id="赋值"><a class="header" href="#赋值"><strong>赋值</strong></a></h2>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut user1 = User {
    email: String::from(&quot;someone@example.com&quot;),
    username: String::from(&quot;someusername123&quot;),
    active: true,
    sign_in_count: 1,
};
user1.email = String::from(&quot;anotheremail@example.com&quot;);
<span class="boring">}
</span></code></pre></pre>
<h2 id="字段同名时的简化写法"><a class="header" href="#字段同名时的简化写法"><strong>字段同名时的简化写法</strong></a></h2>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn build_user(email: String, username: String) -&gt; User {
    User {
        email,
        username,
        active: true,
        sign_in_count: 1,
    }
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="使用结构体更新语法创建示例对象"><a class="header" href="#使用结构体更新语法创建示例对象">使用结构体更新语法创建示例对象</a></h2>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let user2 = User {
    email: String::from(&quot;another@example.com&quot;),
    username: String::from(&quot;anotherusername567&quot;),
    active: user1.active,
    sign_in_count: user1.sign_in_count,
};
<span class="boring">}
</span></code></pre></pre>
<h2 id="使用没有命名的元组结构体创建不同的类型"><a class="header" href="#使用没有命名的元组结构体创建不同的类型"><strong>使用没有命名的元组结构体创建不同的类型</strong></a></h2>
<pre><pre class="playground"><code class="language-rust">
#![allow(unused)]
fn main() {
struct Color(i32, i32, i32);
struct Point(i32, i32, i32);

let black = Color(0, 0, 0);
let origin = Point(0, 0, 0);
}
</code></pre></pre>
<h2 id="没有任何字段的类单元结构体"><a class="header" href="#没有任何字段的类单元结构体">没有任何字段的类单元结构体</a></h2>
<p>我们也可以定义一个没有任何字段的结构体！它们被称为 <strong>类单元结构体</strong>（<em>unit-like structs</em>）因为它们类似于 <code>()</code>，即 unit 类型。类单元结构体常常在你想要在某个类型上实现 trait 但不需要在类型中存储数据的时候发挥作用</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    struct A();
    let a  =A();
<span class="boring">}
</span></code></pre></pre>
<h2 id="结构体的所有权"><a class="header" href="#结构体的所有权">结构体的所有权</a></h2>
<ul>
<li>
<p>一般情况  结构体拥有其 子字段的所有权, </p>
</li>
<li>
<p>可以使结构体存储被其他对象拥有的数据的引用，不过这么做的话需要用上 <strong>生命周期</strong>（<em>lifetimes</em>），</p>
</li>
<li>
<p><em>生命周期</em><strong>确保结构体引用的数据有效性跟结构体本身保持一致</strong></p>
</li>
</ul>
<h2 id="定义方法"><a class="header" href="#定义方法">定义方法</a></h2>
<pre><pre class="playground"><code class="language-rust">#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}
impl Rectangle {
    fn area(&amp;self) -&gt; u32 {
        self.width * self.height
    }
}
fn main() {
    let rect1 = Rectangle { width: 30, height: 50 };
    println!(
        &quot;The area of the rectangle is {} square pixels.&quot;,
        rect1.area()
    );
}
</code></pre></pre>
<ul>
<li>在 <code>area</code> 的签名中，使用 <code>&amp;self</code> 来替代 <code>rectangle: &amp;Rectangle</code></li>
</ul>
<h1 id="枚举"><a class="header" href="#枚举">枚举</a></h1>
<h2 id="使用枚举"><a class="header" href="#使用枚举">使用枚举</a></h2>
<p><strong>定义</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum IpAddrKind {
    V4,
    V6,
}
<span class="boring">}
</span></code></pre></pre>
<p><strong>取值</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let four = IpAddrKind::V4;
let six = IpAddrKind::V6;
<span class="boring">}
</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn route(ip_type: IpAddrKind) { }
route(IpAddrKind::V4);
route(IpAddrKind::V6);
<span class="boring">}
</span></code></pre></pre>
<p><strong>每个成员可以处理不同类型和数量的数据</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum IpAddr {
    V4(u8, u8, u8, u8),
    V6(String),
}

let home = IpAddr::V4(127, 0, 0, 1);

let loopback = IpAddr::V6(String::from(&quot;::1&quot;));
<span class="boring">}
</span></code></pre></pre>
<p><strong>示例</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Message {
    Quit,
    Move { x: i32, y: i32 }, //匿名结构体
    Write(String),//string类型
    ChangeColor(i32, i32, i32), //元组
}
<span class="boring">}
</span></code></pre></pre>
<p><strong>使用 <code>impl</code> 来为结构体定义方法</strong></p>
<h2 id="option枚举"><a class="header" href="#option枚举">Option枚举</a></h2>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Option&lt;T&gt; {
    Some(T),
    None,
}
<span class="boring">}
</span></code></pre></pre>
<p><code>Option&lt;T&gt;</code> 枚举是如此有用以至于它甚至被包含在了 prelude 之中，你不需要将其显式引入作用域</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>//直接使用
Some()
None
let y: Option&lt;i8&gt; = Some(5);
<span class="boring">}
</span></code></pre></pre>
<h2 id="match控制流运算符"><a class="header" href="#match控制流运算符">Match控制流运算符</a></h2>
<ul>
<li>它允许我们将<strong>一个值与一系列的模式相比较</strong>，并根据相匹配的模式<strong>执行相应代码</strong></li>
<li>模式可由字面值、变量、通配符和许多其他内容构成</li>
</ul>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>//match匹配枚举
enum Coin {
    Penny,
    Nickel,
    Dime,
    Quarter,
}

fn value_in_cents(coin: Coin) -&gt; u8 {
    match coin {
        Coin::Penny =&gt; 1,
        Coin::Nickel =&gt; 5,
        Coin::Dime =&gt; 10,
        Coin::Quarter =&gt; 25,
    }
}
<span class="boring">}
</span></code></pre></pre>
<p><strong>枚举的变量获取</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span>
<span class="boring">fn main() {
</span>fn plus_one(x: Option&lt;i32&gt;) -&gt; Option&lt;i32&gt; {
    match x {
        None =&gt; None,
        Some(i) =&gt; Some(i + 1),
    }
}

let five = Some(5);
let six = plus_one(five);
let none = plus_one(None);
<span class="boring">}
</span></code></pre></pre>
<p><strong>枚举的匹配时穷尽的</strong> 通过指定默认块</p>
<pre><pre class="playground"><code class="language-rust">
#![allow(unused)]
fn main() {
let some_u8_value = 0u8;
match some_u8_value {
    1 =&gt; println!(&quot;one&quot;),
    3 =&gt; println!(&quot;three&quot;),
    5 =&gt; println!(&quot;five&quot;),
    7 =&gt; println!(&quot;seven&quot;),
    _ =&gt; (),
}
}
</code></pre></pre>
<h2 id="if-let-简洁控制流"><a class="header" href="#if-let-简洁控制流">if let 简洁控制流</a></h2>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span>
<span class="boring">fn main() {
</span>let mut count = 0;
if let Coin::Quarter(state) = coin {
    println!(&quot;State quarter from {:?}!&quot;, state);
} else {
    count += 1;
}

if coin
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="闭包"><a class="header" href="#闭包">闭包</a></h1>
<ul>
<li>
<p>Rust 的 <strong>闭包</strong>（<em>closures</em>）是可以保存进变量或作为参数传递给其他函数的匿名函数。</p>
</li>
<li>
<p>可以在一个地方创建闭包，然后在不同的上下文中执行闭包运算。</p>
</li>
<li>
<p>不同于函数，闭包允许捕获调用者作用域中的值。我们将展示闭包的这些功能如何复用代码和自定义行为。</p>
</li>
</ul>
<h2 id="闭包写法"><a class="header" href="#闭包写法">闭包写法</a></h2>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>//函数写法,捕获上下文变量
fn  add_one_v1   (x: u32) -&gt; u32 { x + 1 }
//闭包完整写法
let add_one_v2 = |x: u32| -&gt; u32 { x + 1 };
//省略类型
let add_one_v3 = |x|             { x + 1 };
//只有一行时省略大括号
let add_one_v4 = |x|               x + 1  ;
<span class="boring">}
</span></code></pre></pre>
<h2 id="带有泛型的-fn-traint闭包"><a class="header" href="#带有泛型的-fn-traint闭包">带有泛型的 Fn traint闭包</a></h2>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>//泛型 T 的定义是 Fn(u32)-&gt;u32, 接受一个int返回一个int. 使用了Fn的闭包
struct Cacher&lt;T&gt;
    where T: Fn(u32) -&gt; u32
{
    calculation: T,
    value: Option&lt;u32&gt;,
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="闭包引用变量的场景"><a class="header" href="#闭包引用变量的场景">闭包引用变量的场景</a></h2>
<h3 id="默认是不可变引用"><a class="header" href="#默认是不可变引用">默认是不可变引用</a></h3>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    let str = String::from(&quot;士大夫大师傅&quot;);

    let consume = || {
        println!(&quot;{}&quot;,str);
    };
    consume();
    consume();
    consume();
    consume();
<span class="boring">}
</span></code></pre></pre>
<h3 id="可变借用"><a class="header" href="#可变借用">可变借用</a></h3>
<blockquote>
<p>只能有一个可变借用</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn test_closure_4(){
    let mut str = String::from(&quot;士大夫大师傅&quot;);
    use std::mem;
    let mut consume = || {
        str.push('a');
        println!(&quot;{}&quot;,str);
    };
    consume();
    consume();
}
//中途借用会报错
pub fn test_closure_4(){
    let mut str = String::from(&quot;士大夫大师傅&quot;);
    use std::mem;
    let mut consume = || {
        str.push('a');
        println!(&quot;{}&quot;,str);
    };
    consume();
    println!(&quot;{}&quot;,str);
    consume();
}

//借用完毕后可以重新使用
pub fn test_closure_4(){
    let mut str = String::from(&quot;士大夫大师傅&quot;);
    use std::mem;
    let mut consume = || {
        str.push('a');
        println!(&quot;{}&quot;,str);
    };
    consume();
    consume();
    println!(&quot;{}&quot;,str);
}
<span class="boring">}
</span></code></pre></pre>
<h3 id="移动所有权到闭包"><a class="header" href="#移动所有权到闭包">移动所有权到闭包</a></h3>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>//除闭包之外的任何地方都不能访问
pub fn test_closure_4(){
    let mut str = String::from(&quot;士大夫大师傅&quot;);
    use std::mem;
    let mut consume = move || {
        str.push('a');
        println!(&quot;{}&quot;,str);
    };
    consume();
    consume();
}
<span class="boring">}
</span></code></pre></pre>
<h3 id="从闭包中返回可变引用或不可变引用"><a class="header" href="#从闭包中返回可变引用或不可变引用"><del>从闭包中返回可变引用或不可变引用</del></a></h3>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>//编译错误
pub fn test_closure_4(){
    let mut str = String::from(&quot;士大夫大师傅&quot;);
    use std::mem;
    let mut consume =  || -&gt; &amp;String{
        str.push('a');
        println!(&quot;{}&quot;,str);
        &amp;str
    };
    consume();
}
<span class="boring">}
</span></code></pre></pre>
<h3 id="从闭包中返回所有权"><a class="header" href="#从闭包中返回所有权">从闭包中返回所有权</a></h3>
<blockquote>
<p>只能调用一次</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn test_closure_4(){
    let mut str = String::from(&quot;士大夫大师傅&quot;);
    use std::mem;
    let mut consume = move || -&gt; String{
        str.push('a');
        println!(&quot;{}&quot;,str);
        str
    };
    let string = consume();
    println!(&quot;{}&quot;,string);
    //下面的consume会报错,因为所有权被返回出去了
    consume();
}
<span class="boring">}
</span></code></pre></pre>
<h3 id="从闭包中放弃所有权"><a class="header" href="#从闭包中放弃所有权">从闭包中放弃所有权</a></h3>
<blockquote>
<p>只能调用一次</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span>
<span class="boring">fn main() {
</span>pub fn test_closure_4(){
    let str = String::from(&quot;士大夫大师傅&quot;);
    use std::mem;
    let consume = || {
        println!(&quot;{}&quot;,str);
        mem::drop(str);
    };
    consume();
    consume();
    consume();
    consume();
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="作为输入参数"><a class="header" href="#作为输入参数">作为输入参数</a></h2>
<ul>
<li>
<p>虽然 Rust 无需类型说明就能在大多数时候完成变量捕获，但在编写函数时，<strong>这种模糊写法 是不允许的</strong>。</p>
</li>
<li>
<p>当以闭包作为输入参数时，必须指出闭包的完整类型，它是通过使用以下 <code>trait</code> 中的一种来指定的</p>
</li>
</ul>
<h3 id="闭包捕获环境的三种方式"><a class="header" href="#闭包捕获环境的三种方式">闭包捕获环境的三种方式</a></h3>
<ul>
<li><code>Fn</code>：表示捕获方式为通过引用（<code>&amp;T</code>）的闭包</li>
<li><code>FnMut</code>：表示捕获方式为通过可变引用（<code>&amp;mut T</code>）的闭包</li>
<li><code>FnOnce</code>：表示捕获方式为通过值（<code>T</code>）的闭包</li>
</ul>
<h3 id="闭包捕获变量的形式"><a class="header" href="#闭包捕获变量的形式">闭包捕获变量的形式</a></h3>
<p><strong>在满足使用需求的前提下尽量以限制最多的方式捕获</strong></p>
<pre><pre class="playground"><code class="language-rust">// 该函数将闭包作为参数并调用它。
fn apply&lt;F&gt;(f: F) where
    // 闭包没有输入值和返回值。
    F: FnOnce() {
    // ^ 试一试：将 `FnOnce` 换成 `Fn` 或 `FnMut`。

    f();
}

// 输入闭包，返回一个 `i32` 整型的函数。
fn apply_to_3&lt;F&gt;(f: F) -&gt; i32 where
    // 闭包处理一个 `i32` 整型并返回一个 `i32` 整型。
    F: Fn(i32) -&gt; i32 {

    f(3)
}

fn main() {
    use std::mem;
    
    let greeting = &quot;hello&quot;;
    // 不可复制的类型。
    // `to_owned` 从借用的数据创建有所有权的数据。
    let mut farewell = &quot;goodbye&quot;.to_owned();

    // 捕获 2 个变量：通过引用捕获 `greeting`，通过值捕获 `farewell`。
    let diary = || {
        // `greeting` 通过引用捕获，故需要闭包是 `Fn`。
        println!(&quot;I said {}.&quot;, greeting);

        // 下文改变了 `farewell` ，因而要求闭包通过可变引用来捕获它。
        // 现在需要 `FnMut`。
        farewell.push_str(&quot;!!!&quot;);
        println!(&quot;Then I screamed {}.&quot;, farewell);
        println!(&quot;Now I can sleep. zzzzz&quot;);

        // 手动调用 drop 又要求闭包通过值获取 `farewell`。
        // 现在需要 `FnOnce`。
        mem::drop(farewell);
    };

    // 以闭包作为参数，调用函数 `apply`。
    apply(diary);

    // 闭包 `double` 满足 `apply_to_3` 的 trait 约束。
    let double = |x| 2 * x;

    println!(&quot;3 doubled: {}&quot;, apply_to_3(double));
}
</code></pre></pre>
<h2 id="作为输出参数"><a class="header" href="#作为输出参数">作为输出参数</a></h2>
<ul>
<li>
<p>闭包作为输入参数是可能的，所以返回闭包作为输出参数（output parameter）也应该是 可能的。然而返回闭包类型会有问题，</p>
</li>
<li>
<p>因为目前 Rust 只支持<strong>返回具体（非泛型）的 类型</strong>。按照定义，匿名的闭包的类型是未知的，所以只有使用<code>impl Trait</code>才能返回一个闭包。</p>
</li>
</ul>
<p>返回值的合法 trait 和前面的略有不同：</p>
<ul>
<li><code>Fn</code>：和前面的一样</li>
<li><code>FnMut</code>：和前面的一样</li>
<li><code>FnOnce</code>：不太一样。总之现在你需要返回 [<code>FnBox</code>][fnbox] 类型，目前该类型还是不稳定的。这个情况估计将来会改进。</li>
</ul>
<p>除此之外，还必须使用 <code>move</code> 关键字，它表明所有的捕获都是通过值进行的。这是必须 的，因为在函数退出时，任何通过引用的捕获都被丢弃，在闭包中留下无效的引用。</p>
<pre><pre class="playground"><code class="language-rust">fn create_fn() -&gt; impl Fn() {
    let text = &quot;Fn&quot;.to_owned();

    move || println!(&quot;This is a: {}&quot;, text)
}

fn create_fnmut() -&gt; impl FnMut() {
    let text = &quot;FnMut&quot;.to_owned();

    move || println!(&quot;This is a: {}&quot;, text)
}

fn main() {
    let fn_plain = create_fn();
    let mut fn_mut = create_fnmut();

    fn_plain();
    fn_mut();
}
</code></pre></pre>
<h1 id="迭代"><a class="header" href="#迭代">迭代</a></h1>
<h2 id="定义-2"><a class="header" href="#定义-2">定义</a></h2>
<blockquote>
<p>迭代器都实现了一个叫做 <code>Iterator</code> 的定义于标准库的 trait</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Iterator {
    type Item;

    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt;;

    // 此处省略了方法的默认实现
}
<span class="boring">}
</span></code></pre></pre>
<ul>
<li><code>type Item</code> 和 <code>Self::Item</code>，他们定义了 trait 的 <strong>关联类型</strong>（<em>associated type</em>）</li>
<li>这个 <code>Item</code> 类型被用作 <code>next</code> 方法的返回值类型</li>
</ul>
<h2 id="使用-2"><a class="header" href="#使用-2">使用</a></h2>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[test]
fn iterator_demonstration() {
    let v1 = vec![1, 2, 3];

    let mut v1_iter = v1.iter();

    assert_eq!(v1_iter.next(), Some(&amp;1));
    assert_eq!(v1_iter.next(), Some(&amp;2));
    assert_eq!(v1_iter.next(), Some(&amp;3));
    assert_eq!(v1_iter.next(), None);
}
<span class="boring">}
</span></code></pre></pre>
<p>迭代器变量需要是可变的：在迭代器上调用 <code>next</code> 方法改变了迭代器中用来记录序列位置的状态</p>
<h2 id="消费迭代器的方式"><a class="header" href="#消费迭代器的方式">消费迭代器的方式</a></h2>
<p>调用 <code>next</code> 方法的方法被称为 <strong>消费适配器</strong>（<em>consuming adaptors</em>）</p>
<h3 id="sum"><a class="header" href="#sum">SUM</a></h3>
<blockquote>
<p>　调用 <code>sum</code> 之后不再允许使用 <code>v1_iter</code> 因为调用 <code>sum</code> 时它会获取迭代器的所有权。</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[test]
fn iterator_sum() {
    let v1 = vec![1, 2, 3];

    let v1_iter = v1.iter();

    let total: i32 = v1_iter.sum();

    assert_eq!(total, 6);
}
<span class="boring">}
</span></code></pre></pre>
<h3 id="产生其他迭代器"><a class="header" href="#产生其他迭代器">产生其他迭代器</a></h3>
<blockquote>
<p><strong>迭代器适配器</strong>（<em>iterator adaptors</em>）</p>
</blockquote>
<ul>
<li>
<p>允许我们将当前迭代器变为不同类型的迭代器</p>
</li>
<li>
<p>可以链式调用多个迭代器适配器</p>
</li>
</ul>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let v1: Vec&lt;i32&gt; = vec![1, 2, 3];

v1.iter().map(|x| x + 1);

// 迭代器适配器是惰性的,只有真正消费的了才会执行
<span class="boring">}
</span></code></pre></pre>
<h3 id="collect收集"><a class="header" href="#collect收集">collect收集</a></h3>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let v2: Vec&lt;_&gt; = v1.iter().map(|x| x + 1).collect();
<span class="boring">}
</span></code></pre></pre>
<h3 id="filter过滤"><a class="header" href="#filter过滤">filter过滤</a></h3>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    shoes.into_iter()
        .filter(|s| s.size == shoe_size)
        .collect()
<span class="boring">}
</span></code></pre></pre>
<h2 id="自定义迭代器"><a class="header" href="#自定义迭代器">自定义迭代器</a></h2>
<h3 id="第一步定义结构体"><a class="header" href="#第一步定义结构体">第一步定义结构体</a></h3>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Counter{
    counter:i32,
    range:i32
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="第二步实现构造函数"><a class="header" href="#第二步实现构造函数">第二步实现构造函数</a></h2>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Counter{
    fn new(range:i32)-&gt;Counter{
        Counter{
            counter:0,
            range
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<h3 id="第三步实现迭代器"><a class="header" href="#第三步实现迭代器">第三步实现迭代器</a></h3>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Iterator for Counter{
    type Item = i32;

    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
        if self.counter &gt;= self.range {
            None
        }else{
            self.counter+=1;
            Some(self.counter)
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<h3 id="第四步使用"><a class="header" href="#第四步使用">第四步使用</a></h3>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    let counter1 = Counter::new(10);
    let counter2 = Counter::new(11);
    let counter3 = Counter::new(12);

    counter1.zip(counter2.skip(1)).zip(counter3.skip(2)).for_each(|((x,y),z)|{
        println!(&quot;x={},y={},z={}&quot;,x,y,z);
    });
<span class="boring">}
</span></code></pre></pre>
<h2 id="使用迭代器读取命令行"><a class="header" href="#使用迭代器读取命令行">使用迭代器读取命令行</a></h2>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::env;

pub fn test_iter() {
    env::args().for_each(|e|{
        println!(&quot;{}&quot;,e)
    })
}
<span class="boring">}
</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span> // 函数式的写法
    let sum_of_squared_odd_numbers: u32 =
        (0..).map(|n| n * n)             // 所有自然数取平方
             .take_while(|&amp;n| n &lt; upper) // 取小于上限的
             .filter(|&amp;n| is_odd(n))     // 取奇数
             .fold(0, |sum, i| sum + i); // 最后加起来
    println!(&quot;functional style: {}&quot;, sum_of_squared_odd_numbers);
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><ul>
<li>Start Date: 2014-08-04</li>
<li>RFC PR #: <a href="https://github.com/rust-lang/rfcs/pull/195">rust-lang/rfcs#195</a></li>
<li>Rust Issue #: <a href="https://github.com/rust-lang/rust/issues/17307">rust-lang/rust#17307</a></li>
</ul>
<h1 id="summary"><a class="header" href="#summary">Summary</a></h1>
<p>该RFC使用<em>关联项</em>扩展特性，从而实现泛型编程 更方便、可扩展和强大，特别的，traits将包含一系列方法</p>
<ul>
<li>Associated functions (already present as &quot;static&quot; functions)</li>
<li>Associated consts</li>
<li>Associated types</li>
<li>Associated lifetimes</li>
</ul>
<p>这个RFC还为 <em>multidispatch</em> traits 提供了一种机制，其中根据不同类型选择不同的 trait实现。</p>
<p>注意:在 RFC 246引入const和静态项之间的区别之前，这个RFC已经被接受了。该文本已经被 更新，以 澄清：关联常量而不是静态，并提供了对关联常量初始实现的限制 的摘要，除了这个修改之外，没有其他的新语法 影响这个提案的修改</p>
<h1 id="motivation"><a class="header" href="#motivation">Motivation</a></h1>
<blockquote>
<p>动机</p>
</blockquote>
<p>关联项发挥作用的一个典型例子是数据结构，比如 图，至少包含三种类型:节点、边和图本身。</p>
<p>在今天的《Rust》中，为了将 <em>graph</em> 设计为 通用的trait，你必须采用 与图关联的其他类型作为 参数</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Graph&lt;N, E&gt; {
    fn has_edge(&amp;self, &amp;N, &amp;N) -&gt; bool;
    ...
}
<span class="boring">}
</span></code></pre></pre>
<p>把节点和边类型当做参数这令人困惑，因为任何 具体的图类型他们的边跟节点的类型都是确定的、唯一的</p>
<p>同时，这也带来了不遍，因为使用 泛型的 图的代码 也同样被迫 参数化，即使不是所有的类型都是相关的</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>//使用N、E参数化了,所以G必须也是参数化的
fn distance&lt;N, E, G: Graph&lt;N, E&gt;&gt;(graph: &amp;G, start: &amp;N, end: &amp;N) -&gt; uint { ... }
<span class="boring">}
</span></code></pre></pre>
<p>使用关联的类型，图trait 可以明确表明  节点和 边类型由impl决定:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Graph {
    type N;
    type E;
    fn has_edge(&amp;self, &amp;N, &amp;N) -&gt; bool;
}
<span class="boring">}
</span></code></pre></pre>
<p>客户端可以 直接使用关联类型 表示 图类型</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn distance&lt;G: Graph&gt;(graph: &amp;G, start: &amp;G::N, end: &amp;G::N) -&gt; uint { ... }
<span class="boring">}
</span></code></pre></pre>
<p>下面的小节扩展了 关联类型 的上述好处</p>
<h2 id="associated-types-engineering-benefits-for-generics"><a class="header" href="#associated-types-engineering-benefits-for-generics">Associated types: engineering benefits for generics</a></h2>
<blockquote>
<p>泛型的工程好处</p>
</blockquote>
<p>关联类型提供了几个工程上的好处</p>
<ul>
<li>
<p><strong>Readability and scalability</strong>:可读性和可伸缩性</p>
<p>关联类型可以一次性抽象整个类型族，而不需要分别命名它们</p>
<p>这提高了 泛型代码的可读性 (就像上面的 <code>distance</code> 函数). </p>
<p>它还 使泛型更具“可伸缩性”:traits可以合并其他相关的特性 类型不会给不关心这些的客户带来额外的负担</p>
<p>相比之下，在今天的Rust中，将额外的通用参数添加到 Trait经常感觉像是一个非常“重量级”的举动。</p>
</li>
<li>
<p><strong>Ease of refactor ing/evolution</strong>：易于重构</p>
<p>因为trait的用户不必单独参数化它 相关的类型，可以添加新的关联类型而不破坏所有 现有的客户端代码。</p>
<p>相反，在今天的Rust中，关联类型只能通过给 一个trait 添加更多的类型参数，这会破坏所有使用到这个trait的代码。</p>
</li>
</ul>
<h2 id="clearer-trait-matching"><a class="header" href="#clearer-trait-matching">Clearer trait matching</a></h2>
<blockquote>
<p>清晰的trait匹配</p>
</blockquote>
<p>traits的类型参数 要么是 输入、输出</p>
<ul>
<li>
<p><strong>Inputs</strong>. “input”类型参数用于确定使用哪个类型的实现</p>
</li>
<li>
<p><strong>Outputs</strong>. &quot;output&quot; 类型参数 在选择实现时没有作用。</p>
</li>
</ul>
<p>输入和输出类型在类型推理和   trait 一致性规则 中起着重要作用，这后面会有更详细的描述</p>
<p>在目前绝大多数的库中，唯一的输入类型是' Self ' 类型实现trait，所有其他特征类型参数都是输出</p>
<p>例如，<code>trait  Iterator&lt;A&gt;</code> 接受元素的类型形参' A ' 但这种类型总是由具体的“Self”决定的 类型(e.g. <code>Items&lt;u8&gt;</code>) ，A类型通常是输出类型</p>
<p>Additional input type parameters are useful for cases like binary operators,
where you may want the <code>impl</code> to depend on the types of <em>both</em>
arguments. For example, you might want a trait</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Add&lt;Rhs, Sum&gt; {
    fn add(&amp;self, rhs: &amp;Rhs) -&gt; Sum;
}
<span class="boring">}
</span></code></pre></pre>
<p>将' Self '和' Rhs '类型视为输入，将' Sum '类型视为输出 (因为它是由参数类型唯一决定的)。这将允许 ' impl ' s取决于' Rhs '类型，即使' Self '类型是相同的:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Add&lt;int, int&gt; for int { ... }
impl Add&lt;Complex, Complex&gt; for int { ... }
<span class="boring">}
</span></code></pre></pre>
<p>今天的Rust没有明确区分输入类型和输出类型 参数特征。如果你试图提供上面的两个impl，你 会收到如下错误</p>
<pre><code>error: conflicting implementations for trait `Add`
</code></pre>
<p>这个RFC通过</p>
<ul>
<li>将所有trait类型参数视为输入类型，并且</li>
<li>提供关联类型，即输出类型</li>
</ul>
<p>在这个设计中，“Add”trait将会像下面这样写和实现:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Self and Rhs are *inputs*
trait Add&lt;Rhs&gt; {
    type Sum; // Sum is an *output*
    fn add(&amp;self, &amp;Rhs) -&gt; Sum;
}

impl Add&lt;int&gt; for int {
    type Sum = int;
    fn add(&amp;self, rhs: &amp;int) -&gt; int { ... }
}

impl Add&lt;Complex&gt; for int {
    type Sum = Complex;
    fn add(&amp;self, rhs: &amp;Complex) -&gt; Complex { ... }
}
<span class="boring">}
</span></code></pre></pre>
<p>通过这种方法，一个trait声明像<code>trait Add&lt;Rhs&gt;{…}</code> 定义了一个“家族”特征，每个“Rhs”选择一类家族</p>
<h2 id="expressiveness"><a class="header" href="#expressiveness">Expressiveness</a></h2>
<blockquote>
<p>善于表现；表情丰富</p>
</blockquote>
<p>今天的rust  已经可以表达 Associated types、lifetimes、functions，尽管这样做很笨拙(如上所述)。</p>
<p>但associated _consts_不能表达。</p>
<p>例如，今天的Rust包含了各种数字traits，包括 ' Float '，当前必须将常量公开为静态函数:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Float {
    fn nan() -&gt; Self;
    fn infinity() -&gt; Self;
    fn neg_infinity() -&gt; Self;
    fn neg_zero() -&gt; Self;
    fn pi() -&gt; Self;
    fn two_pi() -&gt; Self;
    ...
} 
<span class="boring">}
</span></code></pre></pre>
<p>因为这些函数不能用在常量表达式中，</p>
<p>float类型的模块 同样导出了一组单独的常量作为 const,而没有使用 traits</p>
<p>相关的常量将允许常量直接存在于特征上:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Float {
    const NAN: Self;
    const INFINITY: Self;
    const NEG_INFINITY: Self;
    const NEG_ZERO: Self;
    const PI: Self;
    const TWO_PI: Self;
    ...
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="why-now"><a class="header" href="#why-now">Why now?</a></h2>
<p>撇开上述动机不谈，添加 associated types 的原因可能并不明显, <em>现在</em>(即1.0之前)很重要。主要有两个原因。</p>
<p>首先，这里展示的设计是“不”向后兼容的，因为它 为了trait实现匹配的目的，将trait类型参数重新解释为输入 匹配</p>
<p>输入/输出的区别对一致性规则、类型推断和解析都有区别，这些都将在后面的 RFC。</p>
<p>当然，也有可能给出一个不太理想的设计 关联类型可以稍后添加，而不需要更改 已有的特征类型参数解析</p>
<p>例如，类型参数可以是显式的 标记为输入，否则假定为输出。这将是 不幸的是，因为关联的类型<em>也</em>是输出</p>
<p>这会使语言 具有两种指定traits的输出类型的方法</p>
<p>但第二个原因是库的稳定过程:</p>
<ul>
<li>
<p>由于trait类型参数的大多数现有用途都是作为输出，它们实际上应该是关联类型。对这些api做出承诺：他们目前面临的风险是，将库置于一个这样的设计中：关联类型 添加后 即原有代码就会被抛弃。这种风险可能会 可以通过不同的向后兼容的 相关项设计来缓解，但是 以牺牲语言本身为代价。</p>
</li>
<li>
<p>二元运算符的特征(例如。' Add ')应该是multidispatch</p>
</li>
<li>
<p>It does not seem possible to stabilize them <em>now</em> in a way that will support moving to multidispatch later.</p>
</li>
<li>
<p>当前的库中还存在一些棘手的问题,</p>
<ul>
<li>such as the <code>_equiv</code>methods accumulating in <code>HashMap</code>, 这可以通过关联类型来解决</li>
<li>(请参阅下面的“Defaults”以获得关于这个特定示例的更多信息。) 额外的 示例包括：错误传播的 trait、类型转换的 trait</li>
</ul>
</li>
</ul>
<h1 id="detailed-design"><a class="header" href="#detailed-design">Detailed design</a></h1>
<blockquote>
<p>详细设计</p>
</blockquote>
<h2 id="trait-headers"><a class="header" href="#trait-headers">Trait headers</a></h2>
<p>Trait头是根据以下语法写的</p>
<pre><code>TRAIT_HEADER =
  'trait' IDENT [ '&lt;' INPUT_PARAMS '&gt;' ] [ ':' BOUNDS ] [ WHERE_CLAUSE ]

INPUT_PARAMS = INPUT_TY { ',' INPUT_TY }* [ ',' ]
INPUT_PARAM  = IDENT [ ':' BOUNDS ]

BOUNDS = BOUND { '+' BOUND }* [ '+' ]
BOUND  = IDENT [ '&lt;' ARGS '&gt;' ]

ARGS   = INPUT_ARGS
       | OUTPUT_CONSTRAINTS
       | INPUT_ARGS ',' OUTPUT_CONSTRAINTS

INPUT_ARGS = TYPE { ',' TYPE }*

OUTPUT_CONSTRAINTS = OUTPUT_CONSTRAINT { ',' OUTPUT_CONSTRAINT }*
OUTPUT_CONSTRAINT  = IDENT '=' TYPE
</code></pre>
<p>注意：<code>WHERE_CLAUSE</code> and <code>BOUND</code> 的语法 在下面的 &quot;Constraining associated types&quot; 节中详细解释</p>
<p>一个trait的所有类型参数都被认为是输入，可以用来选择 一个“impl”;</p>
<p>从概念上讲，每个不同实例的类型 都会产生一个 截然不同的trait。更多细节在&quot;The input/output type
distinction&quot;一节中给出 区别”。</p>
<h2 id="trait-bodies-defining-associated-items"><a class="header" href="#trait-bodies-defining-associated-items">Trait bodies: defining associated items</a></h2>
<p>Trait bodies扩展成包含 三种新事物：</p>
<p>consts, types and lifetimes:</p>
<pre><code>TRAIT = TRAIT_HEADER '{' TRAIT_ITEM* '}'
TRAIT_ITEM =
  ... &lt;existing productions&gt;
  | 'const' IDENT ':' TYPE [ '=' CONST_EXP ] ';'
  | 'type' IDENT [ ':' BOUNDS ] [ WHERE_CLAUSE ] [ '=' TYPE ] ';'
  | 'lifetime' LIFETIME_IDENT ';'
</code></pre>
<p>Traits已经支持 关联函数，就是之前 称作：“static”的函数</p>
<p>关联类型上的 <code>BOUNDS</code> and <code>WHERE_CLAUSE</code>  是对 trait的挑选、假设</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Graph {
    type N: Show + Hash;
    type E: Show + Hash;
    ...
}

impl Graph for MyGraph {
    // Both MyNode and MyEdge must implement Show and Hash
    type N = MyNode;
    type E = MyEdge;
    ...
}

fn print_nodes&lt;G: Graph&gt;(g: &amp;G) {
    // here, can assume G::N implements Show
    ...
}
<span class="boring">}
</span></code></pre></pre>
<h3 id="namespacingshadowing-for-associated-types"><a class="header" href="#namespacingshadowing-for-associated-types">Namespacing/shadowing for associated types</a></h3>
<blockquote>
<p>关联类型的命名空间/遮蔽</p>
</blockquote>
<p>关联类型可以与作用域中现有类型具有相同的名称，除trait的类型参数之外:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Foo { ... }

trait Bar&lt;Input&gt; {
    type Foo; // this is allowed
    fn into_foo(self) -&gt; Foo; // this refers to the trait's Foo

    type Input; // this is NOT allowed
}
<span class="boring">}
</span></code></pre></pre>
<p>By not allowing name clashes between input and output types,
keep open the possibility of later allowing syntax like:</p>
<p>通过不允许输入和输出类型之间的名称冲突， 保留以后允许 如下语法的可能性</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>Bar&lt;Input=u8, Foo=uint&gt;
<span class="boring">}
</span></code></pre></pre>
<p>where both input and output parameters are constrained by name. And anyway,
there is no use for clashing input/output names.</p>
<p>其中输入和输出参数都由名称约束。无论如何, 输入/输出名称冲突是没有用的。</p>
<p>在名字冲突的情况下，如上面的' Foo '，由于某种原因 如果trait需要引用 外部 Foo，它总是可以通过使用' type 别名来做到这一点 在 trait 之外。</p>
<h3 id="defaults"><a class="header" href="#defaults">Defaults</a></h3>
<p>注意，关联的常量和类型都允许默认值，就像trait一样 方法和函数可以提供默认值。</p>
<p>作为一种代码重用机制和一种扩展方法，默认值都是有用的 </p>
<p>然而，关联类型的默认值提出了一个有趣的问题：默认方法可以采用默认类型吗</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait ContainerKey : Clone + Hash + Eq {
    type Query: Hash = Self;
    fn compare(&amp;self, other: &amp;Query) -&gt; bool { self == other }
    fn query_to_key(q: &amp;Query) -&gt; Self { q.clone() };
}

impl ContainerKey for String {
    type Query = str;
    fn compare(&amp;self, other: &amp;str) -&gt; bool {
        self.as_slice() == other
    }
    fn query_to_key(q: &amp;str) -&gt; String {
        q.into_string()
    }
}

impl&lt;K,V&gt; HashMap&lt;K,V&gt; where K: ContainerKey {
    fn find(&amp;self, q: &amp;K::Query) -&gt; &amp;V { ... }
}
<span class="boring">}
</span></code></pre></pre>
<p>在这个例子中，' ContainerKey ' trait被用来关联一个' Query ' '类型 (用于查找)具有拥有的键类型</p>
<p>这解决了 <code>HashMap</code>中棘手的问题:使用 &amp;str索引，而不是 &amp;String索引</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// H: HashMap&lt;String, SomeType&gt;
H.find(&quot;some literal&quot;)
<span class="boring">}
</span></code></pre></pre>
<p>而不是写作：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>H.find(&amp;&quot;some literal&quot;.to_string())`
<span class="boring">}
</span></code></pre></pre>
<p>当前的解决方案包括使用' _equiv '方法复制API表面 使用了一些微妙的“Equiv”特征，但也使用了关联类型方法 使得提供一个覆盖相同用例的简单、单一的API变得容易。</p>
<p>' ContainerKey '的默认值只是假设拥有键和查找键 类型是相同的</p>
<p>但是默认方法必须假定默认值 关联类型，才能正常工作。</p>
<p>不可用 覆盖 Query类型、而保留默认方法。</p>
<p>我们用一种非常简单的方法来处理这个问题:</p>
<ul>
<li>如果一个trait 覆盖了任何默认的关联类型，它们也必须覆盖 覆盖<em>所有</em>默认函数和方法。</li>
<li>否则，trait实现者可以有选择地覆盖单个默认值 方法/函数，就像今天一样。</li>
</ul>
<h2 id="trait-implementations"><a class="header" href="#trait-implementations">Trait implementations</a></h2>
<p><strong>triat实现语法</strong></p>
<pre><code>IMPL_ITEM =
  ... &lt;existing productions&gt;
  | 'const' IDENT ':' TYPE '=' CONST_EXP ';'
  | 'type' IDENT' '=' 'TYPE' ';'
  | 'lifetime' LIFETIME_IDENT '=' LIFETIME_REFERENCE ';'
</code></pre>
<p>类中的任何“type”实现必须满足所有边界和where子句</p>
<h2 id="referencing-associated-items"><a class="header" href="#referencing-associated-items">Referencing associated items</a></h2>
<blockquote>
<p>引用关联项</p>
</blockquote>
<p>关联项是通过路径引用的</p>
<p>表达式路径语法为 作为[UFCS]的一部分更新(https://github.com/rust-lang/rfcs/pull/132)，</p>
<p>但 容纳相关的类型和生命周期，我们需要更新类型路径 语法。</p>
<p>完整的语法如下:</p>
<pre><code>EXP_PATH
  = EXP_ID_SEGMENT { '::' EXP_ID_SEGMENT }*
  | TYPE_SEGMENT { '::' EXP_ID_SEGMENT }+
  | IMPL_SEGMENT { '::' EXP_ID_SEGMENT }+
EXP_ID_SEGMENT   = ID [ '::' '&lt;' TYPE { ',' TYPE }* '&gt;' ]

TY_PATH
  = TY_ID_SEGMENT { '::' TY_ID_SEGMENT }*
  | TYPE_SEGMENT { '::' TY_ID_SEGMENT }*
  | IMPL_SEGMENT { '::' TY_ID_SEGMENT }+

TYPE_SEGMENT = '&lt;' TYPE '&gt;'
IMPL_SEGMENT = '&lt;' TYPE 'as' TRAIT_REFERENCE '&gt;'
TRAIT_REFERENCE = ID [ '&lt;' TYPE { ',' TYPE * '&gt;' ]
</code></pre>
<p>下面是一些示例路径，以及它们可能引用的内容</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Expression paths ///////////////////////////////////////////////////////////////

a::b::c         // reference to a function `c` in module `a::b`
a::&lt;T1, T2&gt;     // the function `a` instantiated with type arguments `T1`, `T2`
Vec::&lt;T&gt;::new   // reference to the function `new` associated with `Vec&lt;T&gt;`
&lt;Vec&lt;T&gt; as SomeTrait&gt;::some_fn
                // reference to the function `some_fn` associated with `SomeTrait`,
                //   as implemented by `Vec&lt;T&gt;`
T::size_of      // the function `size_of` associated with the type or trait `T`
&lt;T&gt;::size_of    // the function `size_of` associated with `T` _viewed as a type_
&lt;T as SizeOf&gt;::size_of
                // the function `size_of` associated with `T`'s impl of `SizeOf`

// Type paths /////////////////////////////////////////////////////////////////////

a::b::C         // reference to a type `C` in module `a::b`
A&lt;T1, T2&gt;       // type A instantiated with type arguments `T1`, `T2`
Vec&lt;T&gt;::Iter    // reference to the type `Iter` associated with `Vec&lt;T&gt;
&lt;Vec&lt;T&gt; as SomeTrait&gt;::SomeType
                // reference to the type `SomeType` associated with `SomeTrait`,
                //   as implemented by `Vec&lt;T&gt;`
<span class="boring">}
</span></code></pre></pre>
<h3 id="ways-to-reference-items"><a class="header" href="#ways-to-reference-items">Ways to reference items</a></h3>
<p>接下来，我们将详细介绍每种路径的含义。  为了便于讨论，我们假设已经定义了一个trait类似于</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Container {
    type E;
    fn empty() -&gt; Self;
    fn insert(&amp;mut self, E);
    fn contains(&amp;self, &amp;E) -&gt; bool where E: PartialEq;
    ...
}

impl&lt;T&gt; Container for Vec&lt;T&gt; {
    type E = T;
    fn empty() -&gt; Vec&lt;T&gt; { Vec::new() }
    ...
}
<span class="boring">}
</span></code></pre></pre>
<h4 id="via-an-id_segment-prefix"><a class="header" href="#via-an-id_segment-prefix">Via an <code>ID_SEGMENT</code> prefix</a></h4>
<blockquote>
<p>通过ID_SEGEMENT 前缀 访问</p>
</blockquote>
<h5 id="当前缀解析为类型时"><a class="header" href="#当前缀解析为类型时">当前缀解析为类型时</a></h5>
<p>获取关联项的最常见方法是通过  带有特征限制类型参数 :</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn pick&lt;C: Container&gt;(c: &amp;C) -&gt; Option&lt;&amp;C::E&gt; { ... }

fn mk_with_two&lt;C&gt;() -&gt; C where C: Container, C::E = uint {
    let mut cont = C::empty();  // reference to associated function
    cont.insert(0);
    cont.insert(1);
    cont
}
<span class="boring">}
</span></code></pre></pre>
<p>要使这些引用有效，必须知道类型参数才能实现 相关的特征:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Knowledge via bounds
fn pick&lt;C: Container&gt;(c: &amp;C) -&gt; Option&lt;&amp;C::E&gt; { ... }

// ... or equivalently,  where clause
fn pick&lt;C&gt;(c: &amp;C) -&gt; Option&lt;&amp;C::E&gt; where C: Container { ... }

// Knowledge via ambient constraints
struct TwoContainers&lt;C1: Container, C2: Container&gt;(C1, C2);
impl&lt;C1: Container, C2: Container&gt; TwoContainers&lt;C1, C2&gt; {
    fn pick_one(&amp;self) -&gt; Option&lt;&amp;C1::E&gt; { ... }
    fn pick_other(&amp;self) -&gt; Option&lt;&amp;C2::E&gt; { ... }
}
<span class="boring">}
</span></code></pre></pre>
<p>请注意<code>' Vec&lt;T&gt;::E '和' Vec::&lt;T&gt;::empty '</code>也是有效的类型和函数</p>
<p>对于像<code>' C::E '或' Vec&lt;T&gt;::E '</code>这样的情况，路径以' ID_SEGMENT '开头，前缀本身解析为_type: <code>' C '和' Vec&lt;T&gt; '</code>都是类型。在 一般情况下，路径<code>PREFIX::REST_OF_PATH</code>，其中<code>PREFIX</code>解析为类型是 等价于使用' TYPE_SEGMENT 前缀 <code>&lt;PREFIX&gt;::REST_OF_PATH</code> 。因此,对于 下面的例子都是等价的:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn pick&lt;C: Container&gt;(c: &amp;C) -&gt; Option&lt;&amp;C::E&gt; { ... }
fn pick&lt;C: Container&gt;(c: &amp;C) -&gt; Option&lt;&amp;&lt;C&gt;::E&gt; { ... }
fn pick&lt;C: Container&gt;(c: &amp;C) -&gt; Option&lt;&amp;&lt;&lt;C&gt;::E&gt;&gt; { ... }
<span class="boring">}
</span></code></pre></pre>
<p><code>TYPE_SEGMENT</code>前缀的行为将在下一小节中描述。</p>
<h5 id="当前缀解析为trait时"><a class="header" href="#当前缀解析为trait时">当前缀解析为trait时</a></h5>
<p><code>ID_SEGMENT</code> 前缀可以解析为<em>trait</em>' 其行为不同于 ' TYPE_SEGMENT '的类型</p>
<p>如下:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// a reference Container::insert is roughly equivalent to:
fn trait_insert&lt;C: Container&gt;(c: &amp;C, e: C::E);

// a reference &lt;Container&gt;::insert is roughly equivalent to:
fn object_insert&lt;E&gt;(c: &amp;Container&lt;E=E&gt;, e: E);
<span class="boring">}
</span></code></pre></pre>
<p>trait前缀</p>
<ul>
<li>
<p>A path <code>PREFIX::REST</code> resolves to the item/path <code>REST</code> defined within
<code>Trait</code>, while treating the type implementing the trait as a type parameter.</p>
</li>
<li>
<p>A path <code>&lt;PREFIX&gt;::REST</code> treats <code>PREFIX</code> as a (DST-style) <em>type</em>, and is
hence usable only with trait objects. See the
<a href="https://github.com/rust-lang/rfcs/pull/132">UFCS RFC</a> for more detail.</p>
</li>
</ul>
<p>请注意，像' Container::E '这样的路径虽然在语法上是有效的，但将失败 ，因为没有办法告诉使用哪个“impl”。 Container::empty '的函数大致相当于:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn trait_empty&lt;C: Container&gt;() -&gt; C;
<span class="boring">}
</span></code></pre></pre>
<h4 id="via-a-type_segment-prefix"><a class="header" href="#via-a-type_segment-prefix">Via a <code>TYPE_SEGMENT</code> prefix</a></h4>
<blockquote>
<p>The following text is <em>slightly changed</em> from the
<a href="https://github.com/rust-lang/rfcs/pull/132">UFCS RFC</a>.</p>
</blockquote>
<p>当路径以<code>' TYPE_SEGMENT '</code>开头时，它是一个类型相对路径</p>
<p>如果这已经是一个全部路径，则解析到指定的 类型。如果路径继续(例如，<code>' &lt;int&gt;::size_of '</code>)，那么下一个段是 使用以下过程进行解析。</p>
<p>该过程旨在模拟 方法查找，因此对方法查找的任何更改也可能会更改 此查找算法。</p>
<p>Given a path <code>&lt;T&gt;::m::...</code>:</p>
<ol>
<li>Search for members of inherent impls defined on <code>T</code> (if any) with
the name <code>m</code>. If any are found, the path resolves to that item.</li>
<li>Otherwise, let <code>IN_SCOPE_TRAITS</code> be the set of traits that are in
scope and which contain a member named <code>m</code>:
<ul>
<li>Let <code>IMPLEMENTED_TRAITS</code> be those traits from <code>IN_SCOPE_TRAITS</code>
for which an implementation exists that (may) apply to <code>T</code>.
<ul>
<li>There can be ambiguity in the case that <code>T</code> contains type inference
variables.</li>
</ul>
</li>
<li>If <code>IMPLEMENTED_TRAITS</code> is not a singleton set, report an ambiguity
error. Otherwise, let <code>TRAIT</code> be the member of <code>IMPLEMENTED_TRAITS</code>.</li>
<li>If <code>TRAIT</code> is ambiguously implemented for <code>T</code>, report an
ambiguity error and request further type information.</li>
<li>Otherwise, rewrite the path to <code>&lt;T as Trait&gt;::m::...</code> and
continue.</li>
</ul>
</li>
</ol>
<h4 id="via-a-impl_segment-prefix"><a class="header" href="#via-a-impl_segment-prefix">Via a <code>IMPL_SEGMENT</code> prefix</a></h4>
<blockquote>
<p>The following text is <em>somewhat different</em> from the
<a href="https://github.com/rust-lang/rfcs/pull/132">UFCS RFC</a>.</p>
</blockquote>
<p>When a path begins with an <code>IMPL_SEGMENT</code>, it is a reference to an item defined
from a trait. Note that such paths must always have a follow-on member <code>m</code> (that
is, <code>&lt;T as Trait&gt;</code> is not a complete path, but <code>&lt;T as Trait&gt;::m</code> is).</p>
<p>To resolve the path, first search for an applicable implementation of <code>Trait</code>
for <code>T</code>. If no implementation can be found -- or the result is ambiguous -- then
report an error.  Note that when <code>T</code> is a type parameter, a bound <code>T: Trait</code>
guarantees that there is such an implementation, but does not count for
ambiguity purposes.</p>
<p>Otherwise, resolve the path to the member of the trait with the substitution
<code>Self =&gt; T</code> and continue.</p>
<p>This apparently straightforward algorithm has some subtle consequences, as
illustrated by the following example:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Foo {
    type T;
    fn as_T(&amp;self) -&gt; &amp;T;
}

// A blanket impl for any Show type T
impl&lt;T: Show&gt; Foo for T {
    type T = T;
    fn as_T(&amp;self) -&gt; &amp;T { self }
}

fn bounded&lt;U: Foo&gt;(u: U) where U::T: Show {
    // Here, we just constrain the associated type directly
    println!(&quot;{}&quot;, u.as_T())
}

fn blanket&lt;U: Show&gt;(u: U) {
    // the blanket impl applies to U, so we know that `U: Foo` and
    // &lt;U as Foo&gt;::T = U (and, of course, U: Show)
    println!(&quot;{}&quot;, u.as_T())
}

fn not_allowed&lt;U: Foo&gt;(u: U) {
    // this will not compile, since &lt;U as Trait&gt;::T is not known to
    // implement Show
    println!(&quot;{}&quot;, u.as_T())
}
<span class="boring">}
</span></code></pre></pre>
<p>This example includes three generic functions that make use of an associated
type; the first two will typecheck, while the third will not.</p>
<ul>
<li>
<p>The first case, <code>bounded</code>, places a <code>Show</code> constraint directly on the
otherwise-abstract associated type <code>U::T</code>. Hence, it is allowed to assume that
<code>U::T: Show</code>, even though it does not know the concrete implementation of
<code>Foo</code> for <code>U</code>.</p>
</li>
<li>
<p>The second case, <code>blanket</code>, places a <code>Show</code> constraint on the type <code>U</code>, which
means that the blanket <code>impl</code> of <code>Foo</code> applies even though we do not know the
<em>concrete</em> type that <code>U</code> will be. That fact means, moreover, that we can
compute exactly what the associated type <code>U::T</code> will be, and know that it will
satisfy <code>Show</code>. Coherence guarantees that that the blanket <code>impl</code> is the only
one that could apply to <code>U</code>. (See the section &quot;Impl specialization&quot; under
&quot;Unresolved questions&quot; for a deeper discussion of this point.)</p>
</li>
<li>
<p>The third case assumes only that <code>U: Foo</code>, and therefore nothing is known
about the associated type <code>U::T</code>. In particular, the function cannot assume
that <code>U::T: Show</code>.</p>
</li>
</ul>
<p>The resolution rules also interact with instantiation of type parameters in an
intuitive way. For example:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Graph {
    type N;
    type E;
    ...
}

impl Graph for MyGraph {
    type N = MyNode;
    type E = MyEdge;
    ...
}

fn pick_node&lt;G: Graph&gt;(t: &amp;G) -&gt; &amp;G::N {
    // the type G::N is abstract here
    ...
}

let G = MyGraph::new();
...
pick_node(G) // has type: &lt;MyGraph as Graph&gt;::N = MyNode
<span class="boring">}
</span></code></pre></pre>
<p>Assuming there are no blanket implementations of <code>Graph</code>, the <code>pick_node</code>
function knows nothing about the associated type <code>G::N</code>. However, a <em>client</em> of
<code>pick_node</code> that instantiates it with a particular concrete graph type will also
know the concrete type of the value returned from the function -- here, <code>MyNode</code>.</p>
<h2 id="scoping-of-trait-and-impl-items"><a class="header" href="#scoping-of-trait-and-impl-items">Scoping of <code>trait</code> and <code>impl</code> items</a></h2>
<p>Associated types are frequently referred to in the signatures of a trait's
methods and associated functions, and it is natural and convenient to refer to
them directly.</p>
<p>In other words, writing this:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Graph {
    type N;
    type E;
    fn has_edge(&amp;self, &amp;N, &amp;N) -&gt; bool;
    ...
}
<span class="boring">}
</span></code></pre></pre>
<p>is more appealing than writing this:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Graph {
    type N;
    type E;
    fn has_edge(&amp;self, &amp;Self::N, &amp;Self::N) -&gt; bool;
    ...
}
<span class="boring">}
</span></code></pre></pre>
<p>This RFC proposes to treat both <code>trait</code> and <code>impl</code> bodies (both
inherent and for traits) the same way we treat <code>mod</code> bodies: <em>all</em>
items being defined are in scope. In particular, methods are in scope
as UFCS-style functions:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Foo {
    type AssocType;
    lifetime 'assoc_lifetime;
    const ASSOC_CONST: uint;
    fn assoc_fn() -&gt; Self;

    // Note: 'assoc_lifetime and AssocType in scope:
    fn method(&amp;self, Self) -&gt; &amp;'assoc_lifetime AssocType;

    fn default_method(&amp;self) -&gt; uint {
        // method in scope UFCS-style, assoc_fn in scope
        let _ = method(self, assoc_fn());
        ASSOC_CONST // in scope
    }
}

// Same scoping rules for impls, including inherent impls:
struct Bar;
impl Bar {
    fn foo(&amp;self) { ... }
    fn bar(&amp;self) {
        foo(self); // foo in scope UFCS-style
        ...
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Items from super traits are <em>not</em> in scope, however. See
<a href="3.rust/rfcs/0195_associated-items.html#super-traits">the discussion on super traits below</a> for more detail.</p>
<p>These scope rules provide good ergonomics for associated types in
particular, and a consistent scope model for language constructs that
can contain items (like traits, impls, and modules). In the long run,
we should also explore imports for trait items, i.e. <code>use Trait::some_method</code>, but that is out of scope for this RFC.</p>
<p>Note that, according to this proposal, associated types/lifetimes are <em>not</em> in
scope for the optional <code>where</code> clause on the trait header. For example:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Foo&lt;Input&gt;
    // type parameters in scope, but associated types are not:
    where Bar&lt;Input, Self::Output&gt;: Encodable {

    type Output;
    ...
}
<span class="boring">}
</span></code></pre></pre>
<p>This setup seems more intuitive than allowing the trait header to refer directly
to items defined within the trait body.</p>
<p>It's also worth noting that <em>trait-level</em> <code>where</code> clauses are never needed for
constraining associated types anyway, because associated types also have <code>where</code>
clauses. Thus, the above example could (and should) instead be written as
follows:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Foo&lt;Input&gt; {
    type Output where Bar&lt;Input, Output&gt;: Encodable;
    ...
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="constraining-associated-types"><a class="header" href="#constraining-associated-types">Constraining associated types</a></h2>
<p>Associated types are not treated as parameters to a trait, but in some cases a
function will want to constrain associated types in some way. For example, as
explained in the Motivation section, the <code>Iterator</code> trait should treat the
element type as an output:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Iterator {
    type A;
    fn next(&amp;mut self) -&gt; Option&lt;A&gt;;
    ...
}
<span class="boring">}
</span></code></pre></pre>
<p>For code that works with iterators generically, there is no need to constrain
this type:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn collect_into_vec&lt;I: Iterator&gt;(iter: I) -&gt; Vec&lt;I::A&gt; { ... }
<span class="boring">}
</span></code></pre></pre>
<p>But other code may have requirements for the element type:</p>
<ul>
<li>That it implements some traits (bounds).</li>
<li>That it unifies with a particular type.</li>
</ul>
<p>These requirements can be imposed via <code>where</code> clauses:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn print_iter&lt;I&gt;(iter: I) where I: Iterator, I::A: Show { ... }
fn sum_uints&lt;I&gt;(iter: I) where I: Iterator, I::A = uint { ... }
<span class="boring">}
</span></code></pre></pre>
<p>In addition, there is a shorthand for equality constraints:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn sum_uints&lt;I: Iterator&lt;A = uint&gt;&gt;(iter: I) { ... }
<span class="boring">}
</span></code></pre></pre>
<p>In general, a trait like:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Foo&lt;Input1, Input2&gt; {
    type Output1;
    type Output2;
    lifetime 'a;
    const C: bool;
    ...
}
<span class="boring">}
</span></code></pre></pre>
<p>can be written in a bound like:</p>
<pre><code>T: Foo&lt;I1, I2&gt;
T: Foo&lt;I1, I2, Output1 = O1&gt;
T: Foo&lt;I1, I2, Output2 = O2&gt;
T: Foo&lt;I1, I2, Output1 = O1, Output2 = O2&gt;
T: Foo&lt;I1, I2, Output1 = O1, 'a = 'b, Output2 = O2&gt;
T: Foo&lt;I1, I2, Output1 = O1, 'a = 'b, C = true, Output2 = O2&gt;
</code></pre>
<p>The output constraints must come after all input arguments, but can appear in
any order.</p>
<p>Note that output constraints are allowed when referencing a trait in a <em>type</em> or
a <em>bound</em>, but not in an <code>IMPL_SEGMENT</code> path:</p>
<ul>
<li>As a type: <code>fn foo(obj: Box&lt;Iterator&lt;A = uint&gt;&gt;</code> is allowed.</li>
<li>In a bound: <code>fn foo&lt;I: Iterator&lt;A = uint&gt;&gt;(iter: I)</code> is allowed.</li>
<li>In an <code>IMPL_SEGMENT</code>: <code>&lt;I as Iterator&lt;A = uint&gt;&gt;::next</code> is <em>not</em> allowed.</li>
</ul>
<p>The reason not to allow output constraints in <code>IMPL_SEGMENT</code> is that such paths
are references to a trait implementation that has already been determined -- it
does not make sense to apply additional constraints to the implementation when
referencing it.</p>
<p>Output constraints are a handy shorthand when using trait bounds, but they are a
<em>necessity</em> for trait objects, which we discuss next.</p>
<h2 id="trait-objects"><a class="header" href="#trait-objects">Trait objects</a></h2>
<p>When using trait objects, the <code>Self</code> type is &quot;erased&quot;, so different types
implementing the trait can be used under the same trait object type:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Show for Foo { ... }
impl Show for Bar { ... }

fn make_vec() -&gt; Vec&lt;Box&lt;Show&gt;&gt; {
    let f = Foo { ... };
    let b = Bar { ... };
    let mut v = Vec::new();
    v.push(box f as Box&lt;Show&gt;);
    v.push(box b as Box&lt;Show&gt;);
    v
}
<span class="boring">}
</span></code></pre></pre>
<p>One consequence of erasing <code>Self</code> is that methods using the <code>Self</code> type as
arguments or return values cannot be used on trait objects, since their types
would differ for different choices of <code>Self</code>.</p>
<p>In the model presented in this RFC, traits have additional input parameters
beyond <code>Self</code>, as well as associated types that may vary depending on all of the
input parameters. This raises the question: which of these types, if any, are
erased in trait objects?</p>
<p>The approach we take here is the simplest and most conservative: when using a
trait as a <em>type</em> (i.e., as a trait object), <em>all</em> input and output types must
be provided as part of the type. In other words, <em>only</em> the <code>Self</code> type is
erased, and all other types are specified statically in the trait object type.</p>
<p>Consider again the following example:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Foo&lt;Input1, Input2&gt; {
    type Output1;
    type Output2;
    lifetime 'a;
    const C: bool;
    ...
}
<span class="boring">}
</span></code></pre></pre>
<p>Unlike the case for static trait bounds, which do not have to specify any of the
associated types, lifetimes, or consts, (but do have to specify the input types),
trait object types must specify all of the types:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn consume_foo&lt;T: Foo&lt;I1, I2&gt;&gt;(t: T) // this is valid
fn consume_obj(t: Box&lt;Foo&lt;I1, I2&gt;&gt;)  // this is NOT valid

// but this IS valid:
fn consume_obj(t: Box&lt;Foo&lt;I1, I2, Output1 = O2, Output2 = O2, 'a = 'static, C = true&gt;&gt;)
<span class="boring">}
</span></code></pre></pre>
<p>With this design, it is clear that none of the non-<code>Self</code> types are erased as
part of trait objects. But it leaves wiggle room to relax this restriction
later on: trait object types that are not allowed under this design can be given
meaning in some later design.</p>
<h2 id="inherent-associated-items"><a class="header" href="#inherent-associated-items">Inherent associated items</a></h2>
<p>All associated items are also allowed in inherent <code>impl</code>s, so a definition like
the following is allowed:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct MyGraph { ... }
struct MyNode { ... }
struct MyEdge { ... }

impl MyGraph {
    type N = MyNode;
    type E = MyEdge;

    // Note: associated types in scope, just as with trait bodies
    fn has_edge(&amp;self, &amp;N, &amp;N) -&gt; bool {
        ...
    }

    ...
}
<span class="boring">}
</span></code></pre></pre>
<p>Inherent associated items are referenced similarly to trait associated items:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn distance(g: &amp;MyGraph, from: &amp;MyGraph::N, to: &amp;MyGraph::N) -&gt; uint { ... }
<span class="boring">}
</span></code></pre></pre>
<p>Note, however, that output constraints do not make sense for inherent outputs:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// This is *not* a legal type:
MyGraph&lt;N = SomeNodeType&gt;
<span class="boring">}
</span></code></pre></pre>
<h2 id="the-inputoutput-type-distinction"><a class="header" href="#the-inputoutput-type-distinction">The input/output type distinction</a></h2>
<p>When designing a trait that references some unknown type, you now have the
option of taking that type as an input parameter, or specifying it as an output
associated type. What are the ramifications of this decision?</p>
<h3 id="coherence-implications"><a class="header" href="#coherence-implications">Coherence implications</a></h3>
<p>Input types are used when determining which <code>impl</code> matches, even for the same
<code>Self</code> type:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Iterable1&lt;A&gt; {
    type I: Iterator&lt;A&gt;;
    fn iter(self) -&gt; I;
}

// These impls have distinct input types, so are allowed
impl Iterable1&lt;u8&gt; for Foo { ... }
impl Iterable1&lt;char&gt; for Foo { ... }

trait Iterable2 {
    type A;
    type I: Iterator&lt;A&gt;;
    fn iter(self) -&gt; I;
}

// These impls apply to a common input (Foo), so are NOT allowed
impl Iterable2 for Foo { ... }
impl Iterable2 for Foo { ... }
<span class="boring">}
</span></code></pre></pre>
<p>More formally, the <em>coherence</em> property is revised as follows:</p>
<ul>
<li>Given a trait and values for all its type parameters (inputs, including
<code>Self</code>), there is at most one applicable <code>impl</code>.</li>
</ul>
<p>In the <a href="https://github.com/rust-lang/rfcs/pull/48">trait reform RFC</a>, coherence
is guaranteed by maintaining two other key properties, which are revised as
follows:</p>
<p><em>Orphan check</em>: Every implementation must meet one of
the following conditions:</p>
<ol>
<li>
<p>The trait being implemented (if any) must be defined in the current crate.</p>
</li>
<li>
<p>At least one of the input type parameters (including but not
necessarily <code>Self</code>) must meet the following grammar, where <code>C</code>
is a struct or enum defined within the current crate:</p>
<pre><code>T = C
  | [T]
  | [T, ..n]
  | &amp;T
  | &amp;mut T
  | ~T
  | (..., T, ...)
  | X&lt;..., T, ...&gt; where X is not bivariant with respect to T
</code></pre>
</li>
</ol>
<p><em>Overlapping instances</em>: No two implementations can be instantiable
with the same set of types for the input type parameters.</p>
<p>See the <a href="https://github.com/rust-lang/rfcs/pull/48">trait reform RFC</a> for more
discussion of these properties.</p>
<h3 id="type-inference-implications"><a class="header" href="#type-inference-implications">Type inference implications</a></h3>
<p>Finally, <em>output</em> type parameters can be inferred/resolved as soon as there is
a matching <code>impl</code> based on the input type parameters. Because of the
coherence property above, there can be at most one.</p>
<p>On the other hand, even if there is only one applicable <code>impl</code>, type inference
is <em>not</em> allowed to infer the input type parameters from it. This restriction
makes it possible to ensure <em>crate concatenation</em>: adding another crate may add
<code>impl</code>s for a given trait, and if type inference depended on the absence of such
<code>impl</code>s, importing a crate could break existing code.</p>
<p>In practice, these inference benefits can be quite valuable. For example, in the
<code>Add</code> trait given at the beginning of this RFC, the <code>Sum</code> output type is
immediately known once the input types are known, which can avoid the need for
type annotations.</p>
<h2 id="limitations"><a class="header" href="#limitations">Limitations</a></h2>
<p>The main limitation of associated items as presented here is about associated
<em>types</em> in particular. You might be tempted to write a trait like the following:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Iterable {
    type A;
    type I: Iterator&lt;&amp;'a A&gt;; // what is the lifetime here?
    fn iter&lt;'a&gt;(&amp;'a self) -&gt; I;  // and how to connect it to self?
}
<span class="boring">}
</span></code></pre></pre>
<p>The problem is that, when implementing this trait, the return type <code>I</code> of <code>iter</code>
must generally depend on the <em>lifetime</em> of self. For example, the corresponding
method in <code>Vec</code> looks like the following:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;T&gt; Vec&lt;T&gt; {
    fn iter(&amp;'a self) -&gt; Items&lt;'a, T&gt; { ... }
}
<span class="boring">}
</span></code></pre></pre>
<p>This means that, given a <code>Vec&lt;T&gt;</code>, there isn't a <em>single</em> type <code>Items&lt;T&gt;</code> for
iteration -- rather, there is a <em>family</em> of types, one for each input lifetime.
In other words, the associated type <code>I</code> in the <code>Iterable</code> needs to be
&quot;higher-kinded&quot;: not just a single type, but rather a family:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Iterable {
    type A;
    type I&lt;'a&gt;: Iterator&lt;&amp;'a A&gt;;
    fn iter&lt;'a&gt;(&amp;self) -&gt; I&lt;'a&gt;;
}
<span class="boring">}
</span></code></pre></pre>
<p>In this case, <code>I</code> is parameterized by a lifetime, but in other cases (like
<code>map</code>) an associated type needs to be parameterized by a type.</p>
<p>In general, such higher-kinded types (HKTs) are a much-requested feature for
Rust, and they would extend the reach of associated types. But the design and
implementation of higher-kinded types is, by itself, a significant investment.
The point of view of this RFC is that associated items bring the most important
changes needed to stabilize our existing traits (and add a few key others),
while HKTs will allow us to define important traits in the future but are not
necessary for 1.0.</p>
<h3 id="encoding-higher-kinded-types"><a class="header" href="#encoding-higher-kinded-types">Encoding higher-kinded types</a></h3>
<p>That said, it's worth pointing out that variants of higher-kinded types can be
encoded in the system being proposed here.</p>
<p>For example, the <code>Iterable</code> example above can be written in the following
somewhat contorted style:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait IterableOwned {
    type A;
    type I: Iterator&lt;A&gt;;
    fn iter_owned(self) -&gt; I;
}

trait Iterable {
    fn iter&lt;'a&gt;(&amp;'a self) -&gt; &lt;&amp;'a Self&gt;::I where &amp;'a Self: IterableOwned {
        IterableOwned::iter_owned(self)
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>The idea here is to define a trait that takes, as input type/lifetimes
parameters, the parameters to any HKTs. In this case, the trait is implemented
on the type <code>&amp;'a Self</code>, which includes the lifetime parameter.</p>
<p>We can in fact generalize this technique to encode arbitrary HKTs:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// The kind * -&gt; *
trait TypeToType&lt;Input&gt; {
    type Output;
}
type Apply&lt;Name, Elt&gt; where Name: TypeToType&lt;Elt&gt; = Name::Output;

struct Vec_;
struct DList_;

impl&lt;T&gt; TypeToType&lt;T&gt; for Vec_ {
    type Output = Vec&lt;T&gt;;
}

impl&lt;T&gt; TypeToType&lt;T&gt; for DList_ {
    type Output = DList&lt;T&gt;;
}

trait Mappable
{
    type E;
    type HKT where Apply&lt;HKT, E&gt; = Self;

    fn map&lt;F&gt;(self, f: E -&gt; F) -&gt; Apply&lt;HKT, F&gt;;
}
<span class="boring">}
</span></code></pre></pre>
<p>While the above demonstrates the versatility of associated types and <code>where</code>
clauses, it is probably too much of a hack to be viable for use in <code>libstd</code>.</p>
<h3 id="associated-consts-in-generic-code"><a class="header" href="#associated-consts-in-generic-code">Associated consts in generic code</a></h3>
<p>If the value of an associated const depends on a type parameter (including
<code>Self</code>), it cannot be used in a constant expression. This restriction will
almost certainly be lifted in the future, but this raises questions outside the
scope of this RFC.</p>
<h1 id="staging"><a class="header" href="#staging">Staging</a></h1>
<p>Associated lifetimes are probably not necessary for the 1.0 timeframe. While we
currently have a few traits that are parameterized by lifetimes, most of these
can go away once DST lands.</p>
<p>On the other hand, associated lifetimes are probably trivial to implement once
associated types have been implemented.</p>
<h1 id="other-interactions"><a class="header" href="#other-interactions">Other interactions</a></h1>
<h2 id="interaction-with-implied-bounds"><a class="header" href="#interaction-with-implied-bounds">Interaction with implied bounds</a></h2>
<p>As part of the
<a href="http://smallcultfollowing.com/babysteps/blog/2014/07/06/implied-bounds/">implied bounds</a>
idea, it may be desirable for this:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn pick_node&lt;G&gt;(g: &amp;G) -&gt; &amp;&lt;G as Graph&gt;::N
<span class="boring">}
</span></code></pre></pre>
<p>to be sugar for this:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn pick_node&lt;G: Graph&gt;(g: &amp;G) -&gt; &amp;&lt;G as Graph&gt;::N
<span class="boring">}
</span></code></pre></pre>
<p>But this feature can easily be added later, as part of a general implied bounds RFC.</p>
<h2 id="future-proofing-specialization-of-impls"><a class="header" href="#future-proofing-specialization-of-impls">Future-proofing: specialization of <code>impl</code>s</a></h2>
<p>In the future, we may wish to relax the &quot;overlapping instances&quot; rule so that one
can provide &quot;blanket&quot; trait implementations and then &quot;specialize&quot; them for
particular types. For example:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Sliceable {
    type Slice;
    // note: not using &amp;self here to avoid need for HKT
    fn as_slice(self) -&gt; Slice;
}

impl&lt;'a, T&gt; Sliceable for &amp;'a T {
    type Slice = &amp;'a T;
    fn as_slice(self) -&gt; &amp;'a T { self }
}

impl&lt;'a, T&gt; Sliceable for &amp;'a Vec&lt;T&gt; {
    type Slice = &amp;'a [T];
    fn as_slice(self) -&gt; &amp;'a [T] { self.as_slice() }
}
<span class="boring">}
</span></code></pre></pre>
<p>But then there's a difficult question:</p>
<pre><code>fn dice&lt;A&gt;(a: &amp;A) -&gt; &amp;A::Slice where &amp;A: Slicable {
    a // is this allowed?
}
</code></pre>
<p>Here, the blanket and specialized implementations provide incompatible
associated types. When working with the trait generically, what can we assume
about the associated type? If we assume it is the blanket one, the type may
change during monomorphization (when specialization takes effect)!</p>
<p>The RFC <em>does</em> allow generic code to &quot;see&quot; associated types provided by blanket
implementations, so this is a potential problem.</p>
<p>Our suggested strategy is the following. If at some later point we wish to add
specialization, traits would have to <em>opt in</em> explicitly. For such traits, we
would <em>not</em> allow generic code to &quot;see&quot; associated types for blanket
implementations; instead, output types would only be visible when all input
types were concretely known. This approach is backwards-compatible with the RFC,
and is probably a good idea in any case.</p>
<h1 id="alternatives"><a class="header" href="#alternatives">Alternatives</a></h1>
<h2 id="multidispatch-through-tuple-types"><a class="header" href="#multidispatch-through-tuple-types">Multidispatch through tuple types</a></h2>
<p>This RFC clarifies trait matching by making trait type parameters inputs to
matching, and associated types outputs.</p>
<p>A more radical alternative would be to <em>remove type parameters from traits</em>, and
instead support multiple input types through a separate multidispatch mechanism.</p>
<p>In this design, the <code>Add</code> trait would be written and implemented as follows:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Lhs and Rhs are *inputs*
trait Add for (Lhs, Rhs) {
    type Sum; // Sum is an *output*
    fn add(&amp;Lhs, &amp;Rhs) -&gt; Sum;
}

impl Add for (int, int) {
    type Sum = int;
    fn add(left: &amp;int, right: &amp;int) -&gt; int { ... }
}

impl Add for (int, Complex) {
    type Sum = Complex;
    fn add(left: &amp;int, right: &amp;Complex) -&gt; Complex { ... }
}
<span class="boring">}
</span></code></pre></pre>
<p>The <code>for</code> syntax in the trait definition is used for multidispatch traits, here
saying that <code>impl</code>s must be for pairs of types which are bound to <code>Lhs</code> and
<code>Rhs</code> respectively. The <code>add</code> function can then be invoked in UFCS style by
writing</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>Add::add(some_int, some_complex)
<span class="boring">}
</span></code></pre></pre>
<p><em>Advantages of the tuple approach</em>:</p>
<ul>
<li>
<p>It does not force a distinction between <code>Self</code> and other input types, which in
some cases (including binary operators like <code>Add</code>) can be artificial.</p>
</li>
<li>
<p>Makes it possible to specify input types without specifying the trait:
<code>&lt;(A, B)&gt;::Sum</code> rather than <code>&lt;A as Add&lt;B&gt;&gt;::Sum</code>.</p>
</li>
</ul>
<p><em>Disadvantages of the tuple approach</em>:</p>
<ul>
<li>
<p>It's more painful when you <em>do</em> want a method rather than a function.</p>
</li>
<li>
<p>Requires <code>where</code> clauses when used in bounds: <code>where (A, B): Trait</code> rather
than <code>A: Trait&lt;B&gt;</code>.</p>
</li>
<li>
<p>It gives two ways to write single dispatch: either without <code>for</code>, or using
<code>for</code> with a single-element tuple.</p>
</li>
<li>
<p>There's a somewhat jarring distinction between single/multiple dispatch
traits, making the latter feel &quot;bolted on&quot;.</p>
</li>
<li>
<p>The tuple syntax is unusual in acting as a binder of its types, as opposed to
the <code>Trait&lt;A, B&gt;</code> syntax.</p>
</li>
<li>
<p>Relatedly, the generics syntax for traits is immediately understandable (a
family of traits) based on other uses of generics in the language, while the
tuple notation stands alone.</p>
</li>
<li>
<p>Less clear story for trait objects (although the fact that <code>Self</code> is the only
erased input type in this RFC may seem somewhat arbitrary).</p>
</li>
</ul>
<p>On balance, the generics-based approach seems like a better fit for the language
design, especially in its interaction with methods and the object system.</p>
<h2 id="a-backwards-compatible-version"><a class="header" href="#a-backwards-compatible-version">A backwards-compatible version</a></h2>
<p>Yet another alternative would be to allow trait type parameters to be either
inputs or outputs, marking the inputs with a keyword <code>in</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Add&lt;in Rhs, Sum&gt; {
    fn add(&amp;Lhs, &amp;Rhs) -&gt; Sum;
}
<span class="boring">}
</span></code></pre></pre>
<p>This would provide a way of adding multidispatch now, and then adding associated
items later on without breakage. If, in addition, output types had to come after
all input types, it might even be possible to migrate output type parameters
like <code>Sum</code> above into associated types later.</p>
<p>This is perhaps a reasonable fallback, but it seems better to introduce a clean
design with both multidispatch and associated items together.</p>
<h1 id="unresolved-questions"><a class="header" href="#unresolved-questions">Unresolved questions</a></h1>
<h2 id="super-traits"><a class="header" href="#super-traits">Super traits</a></h2>
<p>This RFC largely ignores super traits.</p>
<p>Currently, the implementation of super traits treats them identically to a
<code>where</code> clause that bounds <code>Self</code>, and this RFC does not propose to change
that. However, a follow-up RFC should clarify that this is the intended
semantics for super traits.</p>
<p>Note that this treatment of super traits is, in particular, consistent with the
proposed scoping rules, which do not bring items from super traits into scope in
the body of a subtrait; they must be accessed via <code>Self::item_name</code>.</p>
<h2 id="equality-constraints-in-where-clauses"><a class="header" href="#equality-constraints-in-where-clauses">Equality constraints in <code>where</code> clauses</a></h2>
<p>This RFC allows equality constraints on types for associated types, but does not
propose a similar feature for <code>where</code> clauses. That will be the subject of a
follow-up RFC.</p>
<h2 id="multiple-trait-object-bounds-for-the-same-trait"><a class="header" href="#multiple-trait-object-bounds-for-the-same-trait">Multiple trait object bounds for the same trait</a></h2>
<p>The design here makes it possible to write bounds or trait objects that mention
the same trait, multiple times, with different inputs:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn mulit_add&lt;T: Add&lt;int&gt; + Add&lt;Complex&gt;&gt;(t: T) -&gt; T { ... }
fn mulit_add_obj(t: Box&lt;Add&lt;int&gt; + Add&lt;Complex&gt;&gt;) -&gt; Box&lt;Add&lt;int&gt; + Add&lt;Complex&gt;&gt; { ... }
<span class="boring">}
</span></code></pre></pre>
<p>This seems like a potentially useful feature, and should be unproblematic for
bounds, but may have implications for vtables that make it problematic for trait
objects. Whether or not such trait combinations are allowed will likely depend
on implementation concerns, which are not yet clear.</p>
<h2 id="generic-associated-consts-in-match-patterns"><a class="header" href="#generic-associated-consts-in-match-patterns">Generic associated consts in match patterns</a></h2>
<p>It seems desirable to allow constants that depend on type parameters in match
patterns, but it's not clear how to do so while still checking exhaustiveness
and reachability of the match arms. Most likely this requires new forms of
where clause, to constrain associated constant values.</p>
<p>For now, we simply defer the question.</p>
<h2 id="generic-associated-consts-in-array-sizes"><a class="header" href="#generic-associated-consts-in-array-sizes">Generic associated consts in array sizes</a></h2>
<p>It would be useful to be able to use trait-associated constants in generic code.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Shouldn't this be OK?
const ALIAS_N: usize = &lt;T&gt;::N;
let x: [u8; &lt;T&gt;::N] = [0u8; ALIAS_N];
// Or...
let x: [u8; T::N + 1] = [0u8; T::N + 1];
<span class="boring">}
</span></code></pre></pre>
<p>However, this causes some problems. What should we do with the following case in
type checking, where we need to prove that a generic is valid for any <code>T</code>?</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x: [u8; T::N + T::N] = [0u8; 2 * T::N];
<span class="boring">}
</span></code></pre></pre>
<p>We would like to handle at least some obvious cases (e.g. proving that
<code>T::N == T::N</code>), but without trying to prove arbitrary statements about
arithmetic. The question of how to do this is deferred.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="summary-1"><a class="header" href="#summary-1">Summary</a></h2>
<p>允许将一般函数和 继承过来的函数 标记为 const,使它们能够在常量上下文中调用，并带有常量参数</p>
<h2 id="motivation-1"><a class="header" href="#motivation-1">Motivation</a></h2>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span>
<span class="boring">fn main() {
</span>#[lang=&quot;unsafe_cell&quot;]
struct UnsafeCell&lt;T&gt; { pub value: T }
struct AtomicUsize { v: UnsafeCell&lt;usize&gt; }
const ATOMIC_USIZE_INIT: AtomicUsize = AtomicUsize {
    v: UnsafeCell { value: 0 }
};

<span class="boring">}
</span></code></pre></pre>
<ul>
<li>为了能在 const 字段中 直接初始化结构体，上述例子只能 将 字段 设置为 pub</li>
<li>有了const函数后，可以避免上述的情况</li>
</ul>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub mod unsafe_cell {
    pub struct UnsafeCell&lt;T&gt; {  value: T }
    pub struct AtomicUsize {  v: UnsafeCell&lt;usize&gt; }
    pub const  fn new(a:usize)-&gt;AtomicUsize{
        AtomicUsize {
            v:UnsafeCell{
                value:a
            }
        }
    }
}
use unsafe_cell::*;
const ATOMIC_USIZE_INIT: AtomicUsize = unsafe_cell::new(0);
<span class="boring">}
</span></code></pre></pre>
<h2 id="detailed-design-1"><a class="header" href="#detailed-design-1">Detailed design</a></h2>
<ul>
<li>函数和继承方法可以标记为 const：</li>
<li>只允许 简单的 参数 按值传递</li>
<li>const 函数体会当做 一个 const 代码块</li>
</ul>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>const FOO: Foo = {
    // Currently, only item &quot;statements&quot; are allowed here.
    stmts;
    // The function's arguments and constant expressions can be freely combined.
    expr
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="const规则"><a class="header" href="#const规则">const规则</a></h2>
<ul>
<li>当前支持的 <code>expr</code>是</li>
</ul>
<h3 id="expr"><a class="header" href="#expr">expr</a></h3>
<ul>
<li>基础类型字面量</li>
<li>ADTS（tuples、arrays、structs、enum variants</li>
<li>基础类型的一元操作、二元操作。unary/binary </li>
<li>强制转换、字段访问、索引</li>
<li>无捕获闭包</li>
<li>引用和块（只 item statmts,和 tail expression）</li>
</ul>
<h3 id="no-side-effects"><a class="header" href="#no-side-effects">no side-effects</a></h3>
<ul>
<li>赋值语句</li>
<li>non-const function  调用</li>
<li>inline assembly)</li>
</ul>
<h3 id="structenum-values-not-allowded-for-copy-trait"><a class="header" href="#structenum-values-not-allowded-for-copy-trait">struct/enum values not allowded for copy trait</a></h3>
<p>struct/enum values are not allowed if their type implements Drop, but this is not transitive, allowing the (perfectly harmless) creation of, e.g. <code>None::&lt;Vec&lt;T&gt;&gt; </code>(as an aside, this rule could be used to allow [x; N] even for non-Copy types of x, but that is out of the scope of this RFC)</p>
<h3 id="references-are-truly-immutable"><a class="header" href="#references-are-truly-immutable">references are truly immutable,</a></h3>
<ul>
<li>no value with interior mutability can be placed behind a reference,</li>
<li>mutable references can only be created from zero-sized values (e.g. &amp;mut || {}) -  this allows a reference to be represented just by its value, with no guarantees for the actual address in memory</li>
</ul>
<h3 id="raw-pointer"><a class="header" href="#raw-pointer">raw pointer</a></h3>
<ul>
<li>raw pointers can only be created from an integer, a reference or another raw pointer</li>
<li>cannot be dereferenced or cast back to an integer, which means any constant raw pointer can be represented by either a constant integer or references</li>
</ul>
<h3 id="loops"><a class="header" href="#loops">loops</a></h3>
<ul>
<li>as a result of not having any side-effects, loops would only affect termination, which has no practical value, thus remaining unimplemented</li>
</ul>
<h3 id="conditional-control-flow"><a class="header" href="#conditional-control-flow">conditional control flow</a></h3>
<ul>
<li>although more useful than loops, conditional control flow (if/else and match) also remains unimplemented and only match would pose a challenge</li>
</ul>
<h3 id="immutable-let-bindings"><a class="header" href="#immutable-let-bindings">immutable let bindings</a></h3>
<ul>
<li>immutable let bindings in blocks have the same status and implementation difficulty as if/else and they both suffer from a lack of demand (blocks were originally introduced to const/static for scoping items used only in the initializer of a global).</li>
</ul>
<h3 id="可以从任何常量表达式调用-const-函数和方法"><a class="header" href="#可以从任何常量表达式调用-const-函数和方法">可以从任何常量表达式调用 const 函数和方法：</a></h3>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span>
<span class="boring">fn main() {
</span>// Standalone example.
struct Point { x: i32, y: i32 }

impl Point {
    const fn new(x: i32, y: i32) -&gt; Point {
        Point { x: x, y: y }
    }

    const fn add(self, other: Point) -&gt; Point {
        Point::new(self.x + other.x, self.y + other.y)
    }
}

const ORIGIN: Point = Point::new(0, 0);

const fn sum_test(xs: [Point; 3]) -&gt; Point {
    xs[0].add(xs[1]).add(xs[2])
}

const A: Point = Point::new(1, 0);
const B: Point = Point::new(0, 1);
const C: Point = A.add(B);
const D: Point = sum_test([A, B, C]);

// Assuming the Foo::new methods used here are const.
static FLAG: AtomicBool = AtomicBool::new(true);
static COUNTDOWN: AtomicUsize = AtomicUsize::new(10);
#[thread_local]
static TLS_COUNTER: Cell&lt;u32&gt; = Cell::new(1);

<span class="boring">}
</span></code></pre></pre>
<p>Type parameters and their bounds are not restricted, though trait methods cannot be called, as they are never const in this design. Accessing trait methods can still be useful - for example, they can be turned into function pointers:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>const fn arithmetic_ops&lt;T: Int&gt;() -&gt; [fn(T, T) -&gt; T; 4] {
    [Add::add, Sub::sub, Mul::mul, Div::div]
}
<span class="boring">}
</span></code></pre></pre>
<p>const functions can also be unsafe, allowing construction of types that require invariants to be maintained (e.g. std::ptr::Unique requires a non-null pointer)</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct OptionalInt(u32);
impl OptionalInt {
    /// Value must be non-zero
    const unsafe fn new(val: u32) -&gt; OptionalInt {
        OptionalInt(val)
    }
}
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="runtime-and-compile-time-metaprogramming"><a class="header" href="#runtime-and-compile-time-metaprogramming">Runtime and compile-time metaprogramming</a></h2>
<blockquote>
<p>运行时和编译时的元编程</p>
</blockquote>
<p>Groovy支持两种编程模型：运行时、编译时</p>
<h3 id="runtime-metaprogramming"><a class="header" href="#runtime-metaprogramming">Runtime metaprogramming</a></h3>
<p>运行时、元编程可以将 拦截、注入、甚至类与接口得合成推迟到运行时</p>
<p>为了深入理解 Groovy 的元对象协议 (MOP)，我们需要了解 Groovy 对象和 Groovy 的方法处理。</p>
<p>在 Groovy 中，我们使用三种对象</p>
<ul>
<li>POJO</li>
<li>POGO</li>
<li>Groovy Interceptors</li>
</ul>
<p>Groovy 允许对所有类型的对象进行元编程，但方式不同。</p>
<ul>
<li>POJO - 常规 Java 对象，其类可以用 Java 或任何其他 JVM 语言编写</li>
<li>POGO - 一个 Groovy 对象，其类是用 Groovy 编写的。继承了 <em>Object</em> 实现了 <em>groovy.lang.GroovyObject</em></li>
<li>Groovy Interceptor - 一个 Groovy 对象 实现了 <em>groovy.lang.GroovyInterceptable</em> </li>
</ul>
<p>对于每个方法调用 Groovy 检查对象是 POJO 还是 POGO</p>
<ul>
<li>对于POJO，Groovy  从  <em>groovy.lang.MetaClassRegistry</em> 获取 <em>MetaClass</em> ，将方法调用委托给它。</li>
<li>对于POGO，Groovy 有更多的步骤</li>
</ul>
<p><img src="4.groovy/../images/GroovyInterceptions.png" alt="" /></p>
<h3 id="groovyobject-interface"><a class="header" href="#groovyobject-interface">GroovyObject interface</a></h3>
<div style="break-before: page; page-break-before: always;"></div><h1 id="注释-2"><a class="header" href="#注释-2">注释</a></h1>
<h2 id="单行注释"><a class="header" href="#单行注释">单行注释</a></h2>
<pre><code class="language-groovy">// a standalone single line comment
</code></pre>
<h2 id="多行注释"><a class="header" href="#多行注释">多行注释</a></h2>
<pre><code class="language-groovy">/* a standalone multiline comment
   spanning two lines */
</code></pre>
<h2 id="文档注释"><a class="header" href="#文档注释">文档注释</a></h2>
<pre><code class="language-groovy">/**
 * A Class description
 */
</code></pre>
<p>Groovydoc 遵循与 Java 自己的 Javadoc 相同的约定。因此，您将能够使用与 Javadoc 相同的标签。</p>
<h2 id="运行时文档保留"><a class="header" href="#运行时文档保留">运行时文档保留</a></h2>
<p>另外，Groovy 从 3.0.0 开始支持 Runtime Groovydoc，即可以在运行时保留 Groovydoc。</p>
<p>默认情况下禁用运行时 Groovydoc。可以通过添加 JVM 选项 -Dgroovy.attach.runtime.groovydoc=true 来启用它</p>
<p>Runtime Groovydoc 以 /**@ 开头并以 */ 结尾，例如：</p>
<pre><code class="language-groovy">/**@
 * Some class groovydoc for Foo
 */
class Foo {
    /**@
     * Some method groovydoc for bar
     */
    void bar() {
    }
}
</code></pre>
<pre><code class="language-groovy">assert Foo.class.groovydoc.content.contains('Some class groovydoc for Foo') 
assert Foo.class.getMethod('bar', new Class[0]).groovydoc.content.contains('Some method groovydoc for bar') 
</code></pre>
<h2 id="shebang-line"><a class="header" href="#shebang-line">Shebang line</a></h2>
<p>除了单行注释之外，还有一个特殊的行注释，通常被称为 UNIX 系统理解的 shebang 行，它允许直接从命令行运行脚本，前提是您已经安装了 Groovy 发行版并且 groovy 命令可用于路径。</p>
<pre><code class="language-groovy">#!/usr/bin/env groovy
println &quot;Hello from the shebang line&quot;
</code></pre>
<p>The <code>#</code> character must be the first character of the file. Any indentation would yield a compilation error.</p>
<h1 id="keywords"><a class="header" href="#keywords">Keywords</a></h1>
<p>The following list represents all the keywords of the Groovy language:</p>
<table><thead><tr><th></th><th></th><th></th><th></th></tr></thead><tbody>
<tr><td>as</td><td>assert</td><td>break</td><td>case</td></tr>
<tr><td>catch</td><td>class</td><td>const</td><td>continue</td></tr>
<tr><td>def</td><td>default</td><td>do</td><td>else</td></tr>
<tr><td>enum</td><td>extends</td><td>false</td><td>finally</td></tr>
<tr><td>for</td><td>goto</td><td>if</td><td>implements</td></tr>
<tr><td>import</td><td>in</td><td>instanceof</td><td>interface</td></tr>
<tr><td>new</td><td>null</td><td>package</td><td>return</td></tr>
<tr><td>super</td><td>switch</td><td>this</td><td>throw</td></tr>
<tr><td>throws</td><td>trait</td><td>true</td><td>try</td></tr>
<tr><td>var</td><td>while</td><td></td><td></td></tr>
</tbody></table>
<h1 id="标识符-1"><a class="header" href="#标识符-1">标识符</a></h1>
<h2 id="普通标识符"><a class="header" href="#普通标识符">普通标识符</a></h2>
<p>标识符以字母、美元或下划线开头。它们不能以数字开头。</p>
<p>字母可以在以下范围内： 'a' 到 'z'（小写 ascii 字母） 'A' 到 'Z'（大写 ascii 字母） '\u00C0' 到 '\u00D6' '\u00D8' 到 '\u00F6 </p>
<p>' '\u00F8' 到 '\u00FF' '\u0100' 到 '\uFFFE'</p>
<h2 id="带引号的标识符"><a class="header" href="#带引号的标识符">带引号的标识符</a></h2>
<p>带引号的标识符出现在带点表达式的点之后。</p>
<p>例如，person.name 表达式的 name 部分可以用 person.&quot;name&quot; 或 person.'name' 引用。</p>
<p>当某些标识符包含 Java 语言规范禁止的非法字符时，但在引用时 Groovy 允许这些字符。</p>
<p>例如，破折号、空格、感叹号等字符。</p>
<pre><code class="language-groovy">def firstname = &quot;Homer&quot;
map.&quot;Simpson-${firstname}&quot; = &quot;Homer Simpson&quot;

assert map.'Simpson-Homer' == &quot;Homer Simpson&quot;
</code></pre>
<h1 id="strings"><a class="header" href="#strings">Strings</a></h1>
<p>文本文字以称为字符串的字符链的形式表示。 Groovy 允许您实例化 java.lang.String 对象以及 GStrings (groovy.lang.GString)，它们在其他编程语言中也称为内插字符串。</p>
<h2 id="single-quoted-string"><a class="header" href="#single-quoted-string">Single-quoted string</a></h2>
<p>单引号字符串是纯 java.lang.String 并且不支持插值。</p>
<h2 id="字符串连接"><a class="header" href="#字符串连接">字符串连接</a></h2>
<pre><code class="language-groovy">assert 'ab' == 'a' + 'b'
</code></pre>
<h2 id="triple-single-quoted-string"><a class="header" href="#triple-single-quoted-string">Triple-single-quoted string</a></h2>
<pre><code class="language-groovy">'''a triple-single-quoted string'''
</code></pre>
<p>三重单引号字符串是纯 java.lang.String 并且不支持插值。</p>
<p>三重单引号字符串可以跨越多行。</p>
<p>字符串的内容可以跨越行边界，无需将字符串分成几部分，也无需连接或换行转义字符：</p>
<pre><code class="language-groovy">def aMultilineString = '''line one
line two
line three'''
</code></pre>
<p><strong>反斜杠去除开头的换行符</strong></p>
<pre><code class="language-groovy">def strippedFirstNewline = '''\
line one
line two
line three
'''

assert !strippedFirstNewline.startsWith('\n')
</code></pre>
<h2 id="escaping-special-characters"><a class="header" href="#escaping-special-characters">Escaping special characters</a></h2>
<pre><code class="language-groovy">'an escaped single quote: \' needs a backslash'
</code></pre>
<pre><code class="language-groovy">'an escaped escape character: \\ needs a double backslash'
</code></pre>
<p>Some special characters also use the backslash as escape character:</p>
<table><thead><tr><th style="text-align: left">Escape sequence</th><th style="text-align: left">Character</th></tr></thead><tbody>
<tr><td style="text-align: left">\b</td><td style="text-align: left">backspace</td></tr>
<tr><td style="text-align: left">\f</td><td style="text-align: left">formfeed</td></tr>
<tr><td style="text-align: left">\n</td><td style="text-align: left">newline</td></tr>
<tr><td style="text-align: left">\r</td><td style="text-align: left">carriage return</td></tr>
<tr><td style="text-align: left">\s</td><td style="text-align: left">single space</td></tr>
<tr><td style="text-align: left">\t</td><td style="text-align: left">tabulation</td></tr>
<tr><td style="text-align: left">\</td><td style="text-align: left">backslash</td></tr>
<tr><td style="text-align: left">'</td><td style="text-align: left">single quote within a single-quoted string (and optional for triple-single-quoted and double-quoted strings)</td></tr>
<tr><td style="text-align: left">&quot;</td><td style="text-align: left">double quote within a double-quoted string (and optional for triple-double-quoted and single-quoted strings)</td></tr>
</tbody></table>
<p>您可以使用 unicode 转义序列：反斜杠，后跟“u”，然后是 4 个十六进制数字。</p>
<pre><code class="language-groovy">'The Euro currency symbol: \u20AC'
</code></pre>
<h2 id="double-quoted-string"><a class="header" href="#double-quoted-string">Double-quoted string</a></h2>
<p>如果没有插值表达式，双引号字符串就是普通的 java.lang.String，如果存在插值，则是 groovy.lang.GString 实例。</p>
<h4 id="string-interpolation"><a class="header" href="#string-interpolation">String interpolation</a></h4>
<p>除了单引号和三重单引号字符串外，任何 Groovy 表达式都可以插入到所有字符串文字中。</p>
<p>占位符使用 <code>${}</code></p>
<p><strong>使用本地变量</strong></p>
<pre><code class="language-groovy">def name = 'Guillaume' // a plain string
def greeting = &quot;Hello ${name}&quot;

assert greeting.toString() == 'Hello Guillaume'
</code></pre>
<p><strong>表达式</strong></p>
<pre><code class="language-groovy">def sum = &quot;The sum of 2 and 3 equals ${2 + 3}&quot;
assert sum.toString() == 'The sum of 2 and 3 equals 5'
</code></pre>
<p>不仅在 ${} 占位符之间允许表达式，而且语句也是如此。</p>
<p>但是，语句的值只是 null。</p>
<p>因此，如果在该占位符中插入了多个语句，插入的表达式最终应该返回 值</p>
<pre><code class="language-groovy">&quot;The sum of 1 and 2 is equal to ${def a = 1; def b = 2; a + b}&quot;
</code></pre>
<p>除了 ${} 占位符之外，我们还可以使用单独的 $ 符号作为 点表达式的前缀</p>
<p>但是只能是 属性访问</p>
<pre><code class="language-groovy">def person = [name: 'Guillaume', age: 36]
assert &quot;$person.name is $person.age years old&quot; == 'Guillaume is 36 years old'
</code></pre>
<h3 id="插入闭包表达式的特例"><a class="header" href="#插入闭包表达式的特例">插入闭包表达式的特例</a></h3>
<p>到目前为止，我们已经看到我们可以在 ${} 占位符中插入任意表达式，但是闭包表达式有一个特殊的情况和符号。</p>
<p>当占位符包含一个箭头 ${→} 时，表达式实际上是一个闭包表达式 — 你可以把它想象成一个前面加了一个美元的闭包：</p>
<pre><code class="language-groovy">//无参闭包
def sParameterLessClosure = &quot;1 + 2 == ${-&gt; 3}&quot; 
assert sParameterLessClosure == '1 + 2 == 3'

//单参数闭包，w 为stringWriter
def sOneParamClosure = &quot;1 + 2 == ${ w -&gt; w &lt;&lt; 3}&quot; 
assert sOneParamClosure == '1 + 2 == 3'
</code></pre>
<p><strong>闭包的好处：惰性求值</strong></p>
<pre><code class="language-groovy">def number = 1 
def eagerGString = &quot;value == ${number}&quot;
def lazyGString = &quot;value == ${ -&gt; number }&quot;

assert eagerGString == &quot;value == 1&quot; 
assert lazyGString ==  &quot;value == 1&quot; 

number = 2 
assert eagerGString == &quot;value == 1&quot; 
assert lazyGString ==  &quot;value == 2&quot; 
</code></pre>
<h3 id="interoperability-with-java"><a class="header" href="#interoperability-with-java">Interoperability with Java</a></h3>
<pre><code class="language-groovy">String takeString(String message) {         
    assert message instanceof String        
    return message

}

//定义 GString
def message = &quot;The message is ${'hello'}&quot;   
assert message instanceof GString           

//调用 申明为String的方法，会隐式的调用 GString的 toString
def result = takeString(message)     
assert result instanceof String
assert result == 'The message is hello'
</code></pre>
<h3 id="gstring-and-string-hashcodes"><a class="header" href="#gstring-and-string-hashcodes">GString and String hashCodes</a></h3>
<p>尽管可以使用内插字符串代替纯 Java 字符串，但它们与字符串的不同之处在于：它们的哈希码不同。</p>
<p>纯 Java 字符串是不可变的，而 GString 的结果字符串表示形式可能会有所不同，具体取决于其内插值。</p>
<p>即使对于相同的结果字符串，GStrings 和 Strings 也没有相同的 hashCode。</p>
<pre><code class="language-groovy">assert &quot;one: ${1}&quot;.hashCode() != &quot;one: 1&quot;.hashCode()
</code></pre>
<p>GString 和具有不同 hashCode 值的字符串，应避免使用 GString 作为 Map 键，尤其是当我们尝试使用 String 而不是 GString 检索关联值时。</p>
<pre><code class="language-groovy">def key = &quot;a&quot;
def m = [&quot;${key}&quot;: &quot;letter ${key}&quot;]     

assert m[&quot;a&quot;] == null                   
</code></pre>
<h2 id="triple-double-quoted-string"><a class="header" href="#triple-double-quoted-string">Triple-double-quoted string</a></h2>
<p>三重双引号字符串的行为类似于双引号字符串，另外还有它们是多行的，就像三重单引号字符串一样。</p>
<p>双引号和单引号都不需要在三重双引号字符串中转义。</p>
<pre><code class="language-groovy">def name = 'Groovy'
def template = &quot;&quot;&quot;
    Dear Mr ${name},

    You're the winner of the lottery!

    Yours sincerly,

    Dave
&quot;&quot;&quot;

assert template.toString().contains('Groovy')
</code></pre>
<h2 id="slashy-string"><a class="header" href="#slashy-string">Slashy string</a></h2>
<p>除了通常的带引号的字符串之外，Groovy 还提供斜线字符串，它使用 / 作为开始和结束分隔符。</p>
<p>斜线字符串对于定义正则表达式和模式特别有用，因为不需要转义反斜线。</p>
<pre><code class="language-groovy">def fooPattern = /.*foo.*/
assert fooPattern == '.*foo.*'
</code></pre>
<pre><code class="language-groovy">def escapeSlash = /The character \/ is a forward slash/
assert escapeSlash == 'The character / is a forward slash'
</code></pre>
<p>Slashy strings are multiline:</p>
<pre><code class="language-groovy">def multilineSlashy = /one
    two
    three/

assert multilineSlashy.contains('\n')
</code></pre>
<p>Slashy 字符串可以被认为是定义 GString 的另一种方式，但具有不同的转义规则。</p>
<p>因此，它们支持插值：</p>
<pre><code class="language-groovy">def color = 'blue'
def interpolatedSlashy = /a ${color} car/

assert interpolatedSlashy == 'a blue car'
</code></pre>
<h3 id="special-cases"><a class="header" href="#special-cases">Special cases</a></h3>
<p>空斜杠字符串不能用双正斜杠表示，因为 Groovy 解析器将其理解为行注释。</p>
<p>这就是为什么以下断言实际上不会通过编译的原因，因为它看起来像一个未终止的语句：</p>
<pre><code class="language-groovy">assert '' == //
</code></pre>
<h2 id="dollar-slashy-string"><a class="header" href="#dollar-slashy-string">Dollar slashy string</a></h2>
<p>Dollar 斜线字符串是多行 GString，以开头的 $/ 和结尾的 /$ 分隔。</p>
<p>转义字符是美元符号，它可以转义另一个美元或正斜杠。</p>
<p>但是美元和正斜杠都不需要转义，除非要转义以 GString 占位符序列开头的字符串子序列的美元，或者如果您需要转义以结束美元斜杠字符串分隔符开头的序列</p>
<pre><code class="language-groovy">def name = &quot;Guillaume&quot;
def date = &quot;April, 1st&quot;

def dollarSlashy = $/
    Hello $name,
    today we're ${date}.

    $ dollar sign
    $$ escaped dollar sign
    \ backslash
    / forward slash
    $/ escaped forward slash
    $$$/ escaped opening dollar slashy
    $/$$ escaped closing dollar slashy
/$

assert [
    'Guillaume',
    'April, 1st',
    '$ dollar sign',
    '$ escaped dollar sign',
    '\\ backslash',
    '/ forward slash',
    '/ escaped forward slash',
    '$/ escaped opening dollar slashy',
    '/$ escaped closing dollar slashy'
].every { dollarSlashy.contains(it) }
</code></pre>
<p>它的创建是为了克服斜线字符串转义规则的一些限制。</p>
<p>当它的转义规则适合你的字符串内容时使用它（通常如果它有一些你不想转义的斜线）。</p>
<h2 id="字符串汇总表"><a class="header" href="#字符串汇总表">字符串汇总表</a></h2>
<table><thead><tr><th>String name</th><th>String syntax</th><th>Interpolated</th><th>Multiline</th><th>Escape character</th></tr></thead><tbody>
<tr><td>Single-quoted</td><td><code>'…'</code></td><td></td><td></td><td><code>\</code></td></tr>
<tr><td>Triple-single-quoted</td><td><code>'''…'''</code></td><td></td><td>1</td><td><code>\</code></td></tr>
<tr><td>Double-quoted</td><td><code>&quot;…&quot;</code></td><td>1</td><td></td><td><code>\</code></td></tr>
<tr><td>Triple-double-quoted</td><td><code>&quot;&quot;&quot;…&quot;&quot;&quot;</code></td><td>1</td><td>1</td><td><code>\</code></td></tr>
<tr><td>Slashy</td><td><code>/…/</code></td><td>1</td><td>1</td><td><code>\</code></td></tr>
<tr><td>Dollar slashy</td><td><code>$/…/$</code></td><td>1</td><td>1</td><td><code>$</code></td></tr>
</tbody></table>
<h2 id="characters"><a class="header" href="#characters">Characters</a></h2>
<p>与 Java 不同，Groovy 没有明确的字符字面量。</p>
<p>但是，您可以通过三种不同的方式明确地将 Groovy 字符串设为实际字符：</p>
<pre><code class="language-groovy">char c1 = 'A' 
assert c1 instanceof Character

def c2 = 'B' as char 
assert c2 instanceof Character

def c3 = (char)'C' 
assert c3 instanceof Character
</code></pre>
<h1 id="numbers"><a class="header" href="#numbers">Numbers</a></h1>
<p>Groovy 支持不同类型的整数文字和十进制文字，由 Java 的常用 Number 类型支持。</p>
<h2 id="integral-literals"><a class="header" href="#integral-literals">Integral literals</a></h2>
<p>The integral literal types are the same as in Java:</p>
<ul>
<li><code>byte</code></li>
<li><code>char</code></li>
<li><code>short</code></li>
<li><code>int</code></li>
<li><code>long</code></li>
<li><code>java.lang.BigInteger</code></li>
</ul>
<pre><code class="language-groovy">// primitive types
byte  b = 1
char  c = 2
short s = 3
int   i = 4
long  l = 5

// infinite precision
BigInteger bi =  6
</code></pre>
<p>如果您使用 def 关键字使用可选类型，则整数的类型会有所不同：它将适应可以容纳该数字的类型的容量。</p>
<p><strong>对于正数：</strong></p>
<pre><code class="language-groovy">def a = 1
assert a instanceof Integer

// Integer.MAX_VALUE
def b = 2147483647
assert b instanceof Integer

// Integer.MAX_VALUE + 1
def c = 2147483648
assert c instanceof Long

// Long.MAX_VALUE
def d = 9223372036854775807
assert d instanceof Long

// Long.MAX_VALUE + 1
def e = 9223372036854775808
assert e instanceof BigInteger
</code></pre>
<p><strong>对于负数</strong></p>
<pre><code class="language-groovy">def na = -1
assert na instanceof Integer

// Integer.MIN_VALUE
def nb = -2147483648
assert nb instanceof Integer

// Integer.MIN_VALUE - 1
def nc = -2147483649
assert nc instanceof Long

// Long.MIN_VALUE
def nd = -9223372036854775808
assert nd instanceof Long

// Long.MIN_VALUE - 1
def ne = -9223372036854775809
assert ne instanceof BigInteger
</code></pre>
<p><strong>几种非十进制</strong></p>
<h3 id="binary-literal"><a class="header" href="#binary-literal">Binary literal</a></h3>
<p>二进制数字以 0b 前缀开头：</p>
<pre><code class="language-groovy">int xInt = 0b10101111
assert xInt == 175

short xShort = 0b11001001
assert xShort == 201 as short

byte xByte = 0b11
assert xByte == 3 as byte

long xLong = 0b101101101101
assert xLong == 2925l

BigInteger xBigInteger = 0b111100100001
assert xBigInteger == 3873g

int xNegativeInt = -0b10101111
assert xNegativeInt == -175
</code></pre>
<h3 id="octal-literal"><a class="header" href="#octal-literal">Octal literal</a></h3>
<p>八进制数以“0”后跟八进制数字的典型格式指定。</p>
<pre><code class="language-groovy">int xInt = 077
assert xInt == 63

short xShort = 011
assert xShort == 9 as short

byte xByte = 032
assert xByte == 26 as byte

long xLong = 0246
assert xLong == 166l

BigInteger xBigInteger = 01111
assert xBigInteger == 585g

int xNegativeInt = -077
assert xNegativeInt == -63
</code></pre>
<h3 id="hexadecimal-literal"><a class="header" href="#hexadecimal-literal">Hexadecimal literal</a></h3>
<p>十六进制数字以 0x 后跟十六进制数字的典型格式指定。</p>
<pre><code class="language-groovy">nt xInt = 0x77
assert xInt == 119

short xShort = 0xaa
assert xShort == 170 as short

byte xByte = 0x3a
assert xByte == 58 as byte

long xLong = 0xffff
assert xLong == 65535l

BigInteger xBigInteger = 0xaaaa
assert xBigInteger == 43690g

Double xDouble = new Double('0x1.0p0')
assert xDouble == 1.0d

int xNegativeInt = -0x77
assert xNegativeInt == -119
</code></pre>
<h2 id="decimal-literals"><a class="header" href="#decimal-literals">Decimal literals</a></h2>
<p><strong>小数类型</strong></p>
<ul>
<li><code>float</code></li>
<li><code>double</code></li>
<li><code>java.lang.BigDecimal</code></li>
</ul>
<pre><code class="language-groovy">// primitive types
float  f = 1.234
double d = 2.345

// infinite precision
BigDecimal bd =  3.456
</code></pre>
<p>小数可以使用指数，用 e 或 E 指数字母，后跟可选符号，以及表示指数的整数：</p>
<pre><code class="language-groovy">assert 1e3  ==  1_000.0
assert 2E4  == 20_000.0
assert 3e+1 ==     30.0
assert 4E-2 ==      0.04
assert 5e-1 ==      0.5
</code></pre>
<p>为了方便地计算精确的十进制数，<strong>Groovy 选择 java.lang.BigDecimal 作为其十进制数类型。</strong></p>
<p>此外，支持 float 和 double，但需要明确的类型声明、类型强制或后缀。</p>
<p>即使 BigDecimal 是十进制数的默认值，在以 float 或 double 作为参数类型的方法或闭包中也接受此类文字。</p>
<p>十进制数不能用二进制、八进制或十六进制表示。</p>
<h2 id="underscore-in-literals"><a class="header" href="#underscore-in-literals">Underscore in literals</a></h2>
<p>写长的文字数字时，眼睛很难弄清楚一些数字是如何组合在一起的，例如千组、单词等。通过允许您在数字文字中放置下划线，更容易发现这些组：</p>
<pre><code class="language-groovy">long creditCardNumber = 1234_5678_9012_3456L
long socialSecurityNumbers = 999_99_9999L
double monetaryAmount = 12_345_132.12
long hexBytes = 0xFF_EC_DE_5E
long hexWords = 0xFFEC_DE5E
long maxLong = 0x7fff_ffff_ffff_ffffL
long alsoMaxLong = 9_223_372_036_854_775_807L
long bytes = 0b11010010_01101001_10010100_10010010
</code></pre>
<h2 id="number-type-suffixes"><a class="header" href="#number-type-suffixes">Number type suffixes</a></h2>
<p>我们可以通过给一个大写或小写的后缀（见下表）来强制一个数字（包括二进制、八进制和十六进制）具有特定的类型。</p>
<table><thead><tr><th style="text-align: left">Type</th><th style="text-align: left">Suffix</th></tr></thead><tbody>
<tr><td style="text-align: left">BigInteger</td><td style="text-align: left"><code>G</code> or <code>g</code></td></tr>
<tr><td style="text-align: left">Long</td><td style="text-align: left"><code>L</code> or <code>l</code></td></tr>
<tr><td style="text-align: left">Integer</td><td style="text-align: left"><code>I</code> or <code>i</code></td></tr>
<tr><td style="text-align: left">BigDecimal</td><td style="text-align: left"><code>G</code> or <code>g</code></td></tr>
<tr><td style="text-align: left">Double</td><td style="text-align: left"><code>D</code> or <code>d</code></td></tr>
<tr><td style="text-align: left">Float</td><td style="text-align: left"><code>F</code> or <code>f</code></td></tr>
</tbody></table>
<pre><code class="language-groovy">assert 42I == new Integer('42')
assert 42i == new Integer('42') // lowercase i more readable
assert 123L == new Long(&quot;123&quot;) // uppercase L more readable
assert 2147483648 == new Long('2147483648') // Long type used, value too large for an Integer
assert 456G == new BigInteger('456')
assert 456g == new BigInteger('456')
assert 123.45 == new BigDecimal('123.45') // default BigDecimal type used
assert 1.200065D == new Double('1.200065')
assert 1.234F == new Float('1.234')
assert 1.23E23D == new Double('1.23E23')
assert 0b1111L.class == Long // binary
assert 0xFFi.class == Integer // hexadecimal
assert 034G.class == BigInteger // octal
</code></pre>
<h2 id="math-operations"><a class="header" href="#math-operations">Math operations</a></h2>
<ul>
<li>binary operations between <code>byte</code>, <code>char</code>, <code>short</code> and <code>int</code> result in <code>int</code></li>
<li>binary operations involving <code>long</code> with <code>byte</code>, <code>char</code>, <code>short</code> and <code>int</code> result in <code>long</code></li>
<li>binary operations involving <code>BigInteger</code> and any other integral type result in <code>BigInteger</code></li>
<li>binary operations involving <code>BigDecimal</code> with <code>byte</code>, <code>char</code>, <code>short</code>, <code>int</code> and <code>BigInteger</code> result in <code>BigDecimal</code></li>
<li>binary operations between <code>float</code>, <code>double</code> and <code>BigDecimal</code> result in <code>double</code></li>
<li>binary operations between two <code>BigDecimal</code> result in <code>BigDecimal</code></li>
</ul>
<h3 id="table-summarizes-those-rules"><a class="header" href="#table-summarizes-those-rules">table summarizes those rules:</a></h3>
<table><thead><tr><th style="text-align: left"></th><th style="text-align: left">byte</th><th style="text-align: left">char</th><th style="text-align: left">short</th><th style="text-align: left">int</th><th style="text-align: left">long</th><th style="text-align: left">BigInteger</th><th style="text-align: left">float</th><th style="text-align: left">double</th><th style="text-align: left">BigDecimal</th></tr></thead><tbody>
<tr><td style="text-align: left"><strong>byte</strong></td><td style="text-align: left">int</td><td style="text-align: left">int</td><td style="text-align: left">int</td><td style="text-align: left">int</td><td style="text-align: left">long</td><td style="text-align: left">BigInteger</td><td style="text-align: left">double</td><td style="text-align: left">double</td><td style="text-align: left">BigDecimal</td></tr>
<tr><td style="text-align: left"><strong>char</strong></td><td style="text-align: left"></td><td style="text-align: left">int</td><td style="text-align: left">int</td><td style="text-align: left">int</td><td style="text-align: left">long</td><td style="text-align: left">BigInteger</td><td style="text-align: left">double</td><td style="text-align: left">double</td><td style="text-align: left">BigDecimal</td></tr>
<tr><td style="text-align: left"><strong>short</strong></td><td style="text-align: left"></td><td style="text-align: left"></td><td style="text-align: left">int</td><td style="text-align: left">int</td><td style="text-align: left">long</td><td style="text-align: left">BigInteger</td><td style="text-align: left">double</td><td style="text-align: left">double</td><td style="text-align: left">BigDecimal</td></tr>
<tr><td style="text-align: left"><strong>int</strong></td><td style="text-align: left"></td><td style="text-align: left"></td><td style="text-align: left"></td><td style="text-align: left">int</td><td style="text-align: left">long</td><td style="text-align: left">BigInteger</td><td style="text-align: left">double</td><td style="text-align: left">double</td><td style="text-align: left">BigDecimal</td></tr>
<tr><td style="text-align: left"><strong>long</strong></td><td style="text-align: left"></td><td style="text-align: left"></td><td style="text-align: left"></td><td style="text-align: left"></td><td style="text-align: left">long</td><td style="text-align: left">BigInteger</td><td style="text-align: left">double</td><td style="text-align: left">double</td><td style="text-align: left">BigDecimal</td></tr>
<tr><td style="text-align: left"><strong>BigInteger</strong></td><td style="text-align: left"></td><td style="text-align: left"></td><td style="text-align: left"></td><td style="text-align: left"></td><td style="text-align: left"></td><td style="text-align: left">BigInteger</td><td style="text-align: left">double</td><td style="text-align: left">double</td><td style="text-align: left">BigDecimal</td></tr>
<tr><td style="text-align: left"><strong>float</strong></td><td style="text-align: left"></td><td style="text-align: left"></td><td style="text-align: left"></td><td style="text-align: left"></td><td style="text-align: left"></td><td style="text-align: left"></td><td style="text-align: left">double</td><td style="text-align: left">double</td><td style="text-align: left">double</td></tr>
<tr><td style="text-align: left"><strong>double</strong></td><td style="text-align: left"></td><td style="text-align: left"></td><td style="text-align: left"></td><td style="text-align: left"></td><td style="text-align: left"></td><td style="text-align: left"></td><td style="text-align: left"></td><td style="text-align: left">double</td><td style="text-align: left">double</td></tr>
<tr><td style="text-align: left"><strong>BigDecimal</strong></td><td style="text-align: left"></td><td style="text-align: left"></td><td style="text-align: left"></td><td style="text-align: left"></td><td style="text-align: left"></td><td style="text-align: left"></td><td style="text-align: left"></td><td style="text-align: left"></td><td style="text-align: left">BigDecimal</td></tr>
</tbody></table>
<p>由于 Groovy 的运算符重载，通常的算术运算符可以与 BigInteger 和 BigDecimal 一起使用，这与在 Java 中必须使用显式方法对这些数字进行运算不同。</p>
<h3 id="除法运算符的情况"><a class="header" href="#除法运算符的情况">除法运算符的情况</a></h3>
<p>除法运算符 /（和 /= 用于除法和赋值）如果操作数是浮点数或双精度数，则产生双精度结果，否则产生 BigDecimal 结果（当两个操作数都是整数类型 short、char、byte、int、 </p>
<p>long、BigInteger 或 BigDecimal）。</p>
<p><code>BigDecimal</code> division is performed with the <code>divide()</code> method if the division is exact (i.e. yielding a result that can be represented within the bounds of the same precision and scale), or using a <code>MathContext</code> with a <a href="http://docs.oracle.com/javase/7/docs/api/java/math/BigDecimal.html#precision()">precision</a> of the maximum of the two operands' precision plus an extra precision of 10, and a <a href="http://docs.oracle.com/javase/7/docs/api/java/math/BigDecimal.html#scale()">scale</a> of the maximum of 10 and the maximum of the operands' scale.</p>
<h3 id="幂运算符"><a class="header" href="#幂运算符">幂运算符</a></h3>
<p>幂运算由 **  运算符表示，有两个参数：基数和指数。</p>
<p>幂运算的结果取决于其操作数和运算结果（特别是如果结果可以表示为整数值）。</p>
<p>Groovy 的幂运算使用以下规则来确定结果类型：</p>
<ul>
<li>如果指数是 小数
<ul>
<li>如果结果可以表示为整数，则返回整数</li>
<li>否则 如果结果可以表示为 Long，则返回 Long</li>
<li>otherwise return a <code>Double</code></li>
</ul>
</li>
<li>如果指数是 整数
<ul>
<li>如果指数严格为负，则如果结果值适合该类型，则返回 Integer、Long 或 Double</li>
<li>如果指数为正数或零
<ul>
<li>如果基数是 BigDecimal，则返回 BigDecimal 结果值</li>
<li>如果基数是 BigInteger，则返回 BigInteger 结果值</li>
<li>如果基数是一个 Integer，则如果结果值 装得下它，则返回一个Integer，否则返回一个 BigInteger</li>
<li>如果基数是 Long，则如果结果值适合，则返回 Long，否则返回 BigInteger</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>我们可以用几个例子来说明这些规则：</p>
<pre><code class="language-groovy">// base and exponent are ints and the result can be represented by an Integer
assert    2    **   3    instanceof Integer    //  8
assert   10    **   9    instanceof Integer    //  1_000_000_000

// the base is a long, so fit the result in a Long
// (although it could have fit in an Integer)
assert    5L   **   2    instanceof Long       //  25

// the result can't be represented as an Integer or Long, so return a BigInteger
assert  100    **  10    instanceof BigInteger //  10e20
assert 1234    ** 123    instanceof BigInteger //  170515806212727042875...

// the base is a BigDecimal and the exponent a negative int
// but the result can be represented as an Integer
assert    0.5  **  -2    instanceof Integer    //  4

// the base is an int, and the exponent a negative float
// but again, the result can be represented as an Integer
assert    1    **  -0.3f instanceof Integer    //  1

// the base is an int, and the exponent a negative int
// but the result will be calculated as a Double
// (both base and exponent are actually converted to doubles)
assert   10    **  -1    instanceof Double     //  0.1

// the base is a BigDecimal, and the exponent is an int, so return a BigDecimal
assert    1.2  **  10    instanceof BigDecimal //  6.1917364224

// the base is a float or double, and the exponent is an int
// but the result can only be represented as a Double value
assert    3.4f **   5    instanceof Double     //  454.35430372146965
assert    5.6d **   2    instanceof Double     //  31.359999999999996

// the exponent is a decimal value
// and the result can only be represented as a Double value
assert    7.8  **   1.9  instanceof Double     //  49.542708423868476
assert    2    **   0.1f instanceof Double     //  1.0717734636432956
</code></pre>
<h1 id="booleans"><a class="header" href="#booleans">Booleans</a></h1>
<p>Boolean 是一种特殊的数据类型，用于表示真值：true 和 false。</p>
<p>将此数据类型用于跟踪真/假条件的简单标志。</p>
<pre><code class="language-groovy">def myBooleanVariable = true
boolean untypedBooleanVar = false
booleanField = true
</code></pre>
<p>其他集合类详见 <a href="4.groovy/%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95.html">基础语法</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="io"><a class="header" href="#io">IO</a></h1>
<h2 id="读文件"><a class="header" href="#读文件">读文件</a></h2>
<p><strong>读文件</strong></p>
<pre><code class="language-groovy">new File(baseDir, 'haiku.txt').eachLine { line -&gt;
    println line
}
</code></pre>
<p><strong>行号与line</strong></p>
<pre><code class="language-groovy">new File(baseDir, 'haiku.txt').eachLine { line, nb -&gt;
    println &quot;Line $nb: $line&quot;
}
</code></pre>
<p><strong>自定义reader</strong></p>
<blockquote>
<p>会自动关闭流</p>
</blockquote>
<pre><code class="language-groovy">def count = 0, MAXSIZE = 3
new File(baseDir,&quot;haiku.txt&quot;).withReader { reader -&gt;
    while (reader.readLine()) {
        if (++count &gt; MAXSIZE) {
            throw new RuntimeException('Haiku should only have 3 verses')
        }
    }
}
</code></pre>
<p><strong>转list</strong></p>
<pre><code class="language-sh">def list = new File(baseDir, 'haiku.txt').collect {it}
</code></pre>
<p>或者您甚至可以利用 as 运算符将文件的内容放入行数组：</p>
<pre><code class="language-groovy">def array = new File(baseDir, 'haiku.txt') as String[]
</code></pre>
<p><strong>转换字节数组</strong></p>
<pre><code class="language-groovy">byte[] contents = file.bytes
</code></pre>
<p><strong>获取输入流</strong></p>
<pre><code class="language-groovy">def is = new File(baseDir,'haiku.txt').newInputStream()
// do something ...
is.close()
</code></pre>
<p><strong>自动关闭流</strong></p>
<pre><code class="language-groovy">new File(baseDir,'haiku.txt').withInputStream { stream -&gt;
    // do something ...
}
</code></pre>
<h2 id="写文件"><a class="header" href="#写文件">写文件</a></h2>
<p><strong>闭包写文件</strong></p>
<pre><code class="language-groovy">new File(baseDir,'haiku.txt').withWriter('utf-8') { writer -&gt;
    writer.writeLine 'Into the ancient pond'
    writer.writeLine 'A frog jumps'
    writer.writeLine 'Water’s sound!'
}
</code></pre>
<p><strong>重定向符写文件</strong></p>
<pre><code class="language-groovy">new File(baseDir,'haiku.txt') &lt;&lt; '''Into the ancient pond
A frog jumps
Water’s sound!'''
</code></pre>
<p><strong>直接写字节数组</strong></p>
<pre><code class="language-sh">file.bytes = [66,22,11]
</code></pre>
<p>直接使用 <strong>outputstream</strong></p>
<pre><code class="language-groovy">def os = new File(baseDir,'data.bin').newOutputStream()
// do something ...
os.close()
</code></pre>
<p>闭包使用<strong>outputstream</strong></p>
<pre><code class="language-sh">new File(baseDir,'data.bin').withOutputStream { stream -&gt;
    // do something ...
}
</code></pre>
<h2 id="遍历文件树"><a class="header" href="#遍历文件树">遍历文件树</a></h2>
<pre><code class="language-groovy">dir.eachFile { file -&gt;                      
    println file.name
}
dir.eachFileMatch(~/.*\.txt/) { file -&gt;     
    println file.name
}
//递归
dir.eachFileRecurse { file -&gt;                      
    println file.name
}

dir.eachFileRecurse(FileType.FILES) { file -&gt;      
    println file.name
}
</code></pre>
<p><strong>手动控制递归</strong></p>
<pre><code class="language-groovy">dir.traverse { file -&gt;
    if (file.directory &amp;&amp; file.name=='bin') {
        FileVisitResult.TERMINATE                   
    } else {
        println file.name
        FileVisitResult.CONTINUE                    
    }

}
</code></pre>
<h2 id="数据和对象"><a class="header" href="#数据和对象">数据和对象</a></h2>
<p>在Java中很少使用 java.io.DataOutputStream<code>and</code>java.io.DataInputStream</p>
<pre><code class="language-groovy">boolean b = true
String message = 'Hello from Groovy'
// Serialize data into a file
file.withDataOutputStream { out -&gt;
    out.writeBoolean(b)
    out.writeUTF(message)
}
// ...
// Then read it back
file.withDataInputStream { input -&gt;
    assert input.readBoolean() == b
    assert input.readUTF() == message
}
</code></pre>
<p>同样，如果要序列化的数据实现了 Serializable 接口，则可以继续使用对象输出流，</p>
<pre><code class="language-groovy">Person p = new Person(name:'Bob', age:76)
// Serialize data into a file
file.withObjectOutputStream { out -&gt;
    out.writeObject(p)
}
// ...
// Then read it back
file.withObjectInputStream { input -&gt;
    def p2 = input.readObject()
    assert p2.name == p.name
    assert p2.age == p.age
}
</code></pre>
<p><strong>执行外部程序</strong></p>
<pre><code class="language-groovy">// 执行外部命令
def process = &quot;ls -l&quot;.execute()             
// 获取外部命令的输出，返回值类型 java.lang.Process
println &quot;Found text ${process.text}&quot;        
</code></pre>
<p><strong>处理 输入流</strong></p>
<pre><code class="language-groovy">def process = &quot;ls -l&quot;.execute()             
process.in.eachLine { line -&gt;               
    println line                            
}
</code></pre>
<p><strong>windows命令</strong></p>
<pre><code class="language-groovy">//这会直接报错，因为 dir是 windows shell自带命令，不能使用可执行路径执行，
def process = &quot;dir&quot;.execute()
println &quot;${process.text}&quot;

def process = &quot;cmd /c dir&quot;.execute()
println &quot;${process.text}&quot;
</code></pre>
<p>由于一些原生平台只为标准的输入输出流提供有限的缓冲区大小，未能及时写入输入流或读取子进程的输出流可能会导致子进程阻塞，甚至死锁</p>
<p>因此，Groovy 提供了一些额外的辅助方法，使流程的流处理更容易。</p>
<p>以下是如何从您的过程中 获取所有输出（包括错误流输出）：</p>
<pre><code class="language-groovy">def p = &quot;rm -f foo.tmp&quot;.execute([], tmpDir)
p.consumeProcessOutput()
p.waitFor()
</code></pre>
<p>也有使用 StringBuffer、InputStream、OutputStream 等的消耗进程输出的变体......有关完整列表，请阅读 java.lang.Process 的 GDK API</p>
<p>此外，这是一个 pipeTo 命令（映射到 | 以允许重载），它允许一个进程的输出流被馈送到另一个进程的输入流中。</p>
<pre><code class="language-groovy">proc1 = 'ls'.execute()
proc2 = 'tr -d o'.execute()
proc3 = 'tr -d e'.execute()
proc4 = 'tr -d i'.execute()
proc1 | proc2 | proc3 | proc4
proc4.waitFor()
if (proc4.exitValue()) {
    println proc4.err.text
} else {
    println proc4.text
}
</code></pre>
<pre><code class="language-groovy">def sout = new StringBuilder()
def serr = new StringBuilder()
proc2 = 'tr -d o'.execute()
proc3 = 'tr -d e'.execute()
proc4 = 'tr -d i'.execute()
proc4.consumeProcessOutput(sout, serr)
proc2 | proc3 | proc4
[proc2, proc3].each { it.consumeProcessErrorStream(serr) }
proc2.withWriter { writer -&gt;
    writer &lt;&lt; 'testfile.groovy'
}
proc4.waitForOrKill(1000)
println &quot;Standard output: $sout&quot;
println &quot;Standard error: $serr&quot;
</code></pre>
<h1 id="集合"><a class="header" href="#集合">集合</a></h1>
<h2 id="lists"><a class="header" href="#lists">Lists</a></h2>
<h3 id="定义与取值"><a class="header" href="#定义与取值"><strong>定义与取值</strong></a></h3>
<pre><code class="language-groovy">#定义
def list = [5, 6, 7, 8]
# 取值
assert list.get(2) == 7
# 取值
assert list[2] == 7
# 类型比较
assert list instanceof java.util.List
# 空集合
def emptyList = []
# 集合大小
assert emptyList.size() == 0
# 添加集合
emptyList.add(5)
assert emptyList.size() == 1
</code></pre>
<h3 id="arraylist构造"><a class="header" href="#arraylist构造"><strong>ArrayList构造</strong></a></h3>
<pre><code class="language-groovy">def list1 = ['a', 'b', 'c']
//construct a new list, seeded with the same items as in list1
def list2 = new ArrayList&lt;String&gt;(list1)

assert list2 == list1 // == checks that each corresponding element is the same

// clone() can also be called
def list3 = list1.clone()
assert list3 == list1
</code></pre>
<h3 id="getat-putat"><a class="header" href="#getat-putat"><strong>getAt putAt</strong></a></h3>
<pre><code class="language-groovy">def list = [5, 6, 7, 8]
assert list.size() == 4
assert list.getClass() == ArrayList     // the specific kind of list being used

assert list[2] == 7                     // indexing starts at 0
assert list.getAt(2) == 7               // equivalent method to subscript operator []
assert list.get(2) == 7                 // alternative method

list[2] = 9
assert list == [5, 6, 9, 8,]           // trailing comma OK

list.putAt(2, 10)                       // equivalent method to [] when value being changed
assert list == [5, 6, 10, 8]
assert list.set(2, 11) == 10            // alternative method that returns old value
assert list == [5, 6, 11, 8]

assert ['a', 1, 'a', 'a', 2.5, 2.5f, 2.5d, 'hello', 7g, null, 9 as byte]
//objects can be of different types; duplicates allowed

assert [1, 2, 3, 4, 5][-1] == 5             // use negative indices to count from the end
assert [1, 2, 3, 4, 5][-2] == 4
assert [1, 2, 3, 4, 5].getAt(-2) == 4       // getAt() available with negative index...
try {
    [1, 2, 3, 4, 5].get(-2)                 // but negative index not allowed with get()
    assert false
} catch (e) {
    assert e instanceof IndexOutOfBoundsException
}
</code></pre>
<p><strong>迭代</strong></p>
<pre><code class="language-groovy">[1, 2, 3].each {
    println &quot;Item: $it&quot; // `it` is an implicit parameter corresponding to the current element
}
['a', 'b', 'c'].eachWithIndex { it, i -&gt; // `it` is the current element, while `i` is the index
    println &quot;$i: $it&quot;
}
</code></pre>
<h3 id="转换"><a class="header" href="#转换"><strong>转换</strong></a></h3>
<pre><code class="language-groovy">assert [1, 2, 3].collect { it * 2 } == [2, 4, 6]

// shortcut syntax instead of collect
assert [1, 2, 3]*.multiply(2) == [1, 2, 3].collect { it.multiply(2) }

def list = [0]
// it is possible to give `collect` the list which collects the elements
assert [1, 2, 3].collect(list) { it * 2 } == [0, 2, 4, 6]
assert list == [0, 2, 4, 6]
</code></pre>
<h3 id="修改集合-搜索过滤"><a class="header" href="#修改集合-搜索过滤"><strong>修改集合-搜索过滤</strong></a></h3>
<pre><code class="language-groovy">assert [1, 2, 3].find { it &gt; 1 } == 2           // find 1st element matching criteria
assert [1, 2, 3].findAll { it &gt; 1 } == [2, 3]   // find all elements matching critieria
assert ['a', 'b', 'c', 'd', 'e'].findIndexOf {      // find index of 1st element matching criteria
    it in ['c', 'e', 'g']
} == 2

assert ['a', 'b', 'c', 'd', 'c'].indexOf('c') == 2  // index returned
assert ['a', 'b', 'c', 'd', 'c'].indexOf('z') == -1 // index -1 means value not in list
assert ['a', 'b', 'c', 'd', 'c'].lastIndexOf('c') == 4

assert [1, 2, 3].every { it &lt; 5 }               // returns true if all elements match the predicate
assert ![1, 2, 3].every { it &lt; 3 }
assert [1, 2, 3].any { it &gt; 2 }                 // returns true if any element matches the predicate
assert ![1, 2, 3].any { it &gt; 3 }

assert [1, 2, 3, 4, 5, 6].sum() == 21                // sum anything with a plus() method
assert ['a', 'b', 'c', 'd', 'e'].sum {
    it == 'a' ? 1 : it == 'b' ? 2 : it == 'c' ? 3 : it == 'd' ? 4 : it == 'e' ? 5 : 0
    // custom value to use in sum
} == 15
assert ['a', 'b', 'c', 'd', 'e'].sum { ((char) it) - ((char) 'a') } == 10
assert ['a', 'b', 'c', 'd', 'e'].sum() == 'abcde'
assert [['a', 'b'], ['c', 'd']].sum() == ['a', 'b', 'c', 'd']

// an initial value can be provided
assert [].sum(1000) == 1000
assert [1, 2, 3].sum(1000) == 1006

assert [1, 2, 3].join('-') == '1-2-3'           // String joining
assert [1, 2, 3].inject('counting: ') {
    str, item -&gt; str + item                     // reduce operation
} == 'counting: 123'
assert [1, 2, 3].inject(0) { count, item -&gt;
    count + item
} == 6
</code></pre>
<h3 id="最大值最小值"><a class="header" href="#最大值最小值"><strong>最大值最小值</strong></a></h3>
<pre><code class="language-groovy">def list = [9, 4, 2, 10, 5]
assert list.max() == 10
assert list.min() == 2

// we can also compare single characters, as anything comparable
assert ['x', 'y', 'a', 'z'].min() == 'a'

// we can use a closure to specify the sorting behaviour
def list2 = ['abc', 'z', 'xyzuvw', 'Hello', '321']
assert list2.max { it.size() } == 'xyzuvw'
assert list2.min { it.size() } == 'z'
</code></pre>
<h3 id="定义排序器"><a class="header" href="#定义排序器"><strong>定义排序器</strong></a></h3>
<pre><code class="language-groovy">Comparator mc = { a, b -&gt; a == b ? 0 : (a &lt; b ? -1 : 1) }

def list = [7, 4, 9, -6, -1, 11, 2, 3, -9, 5, -13]
assert list.max(mc) == 11
assert list.min(mc) == -13

Comparator mc2 = { a, b -&gt; a == b ? 0 : (Math.abs(a) &lt; Math.abs(b)) ? -1 : 1 }


assert list.max(mc2) == -13
assert list.min(mc2) == -1

assert list.max { a, b -&gt; a.equals(b) ? 0 : Math.abs(a) &lt; Math.abs(b) ? -1 : 1 } == -13
assert list.min { a, b -&gt; a.equals(b) ? 0 : Math.abs(a) &lt; Math.abs(b) ? -1 : 1 } == -1
</code></pre>
<h3 id="移除元素"><a class="header" href="#移除元素"><strong>移除元素</strong></a></h3>
<pre><code class="language-groovy">def list = []
assert list.empty

list &lt;&lt; 5
assert list.size() == 1

list &lt;&lt; 7 &lt;&lt; 'i' &lt;&lt; 11
assert list == [5, 7, 'i', 11]

list &lt;&lt; ['m', 'o']
assert list == [5, 7, 'i', 11, ['m', 'o']]

//first item in chain of &lt;&lt; is target list
assert ([1, 2] &lt;&lt; 3 &lt;&lt; [4, 5] &lt;&lt; 6) == [1, 2, 3, [4, 5], 6]

//using leftShift is equivalent to using &lt;&lt;
assert ([1, 2, 3] &lt;&lt; 4) == ([1, 2, 3].leftShift(4))
</code></pre>
<h3 id="集合加减与展开"><a class="header" href="#集合加减与展开"><strong>集合加减与展开</strong></a></h3>
<pre><code class="language-groovy"># 连加
assert [1, 2] + 3 + [4, 5] + 6 == [1, 2, 3, 4, 5, 6]

//API连＋ equivalent to calling the `plus` method
assert [1, 2].plus(3).plus([4, 5]).plus(6) == [1, 2, 3, 4, 5, 6]
# +=，每次都会建一个新的集合
def a = [1, 2, 3]
a += 4      // creates a new list and assigns it to `a`
a += [5, 6]
assert a == [1, 2, 3, 4, 5, 6]

# 平铺符
assert [1, *[222, 333], 456] == [1, 222, 333, 456]
assert [*[1, 2, 3]] == [1, 2, 3]
# 展开符
assert [1, [2, 3, [4, 5], 6], 7, [8, 9]].flatten() == [1, 2, 3, 4, 5, 6, 7, 8, 9]

def list = [1, 2]
list.add(3)
list.addAll([5, 4])
assert list == [1, 2, 3, 5, 4]

list = [1, 2]
list.add(1, 3) // add 3 just before index 1
assert list == [1, 3, 2]

list.addAll(2, [5, 4]) //add [5,4] just before index 2
assert list == [1, 3, 5, 4, 2]

list = ['a', 'b', 'z', 'e', 'u', 'v', 'g']
list[8] = 'x' // the [] operator is growing the list as needed
// nulls inserted if required
assert list == ['a', 'b', 'z', 'e', 'u', 'v', 'g', null, 'x']
</code></pre>
<pre><code class="language-groovy">assert ['a','b','c','b','b'] - 'c' == ['a','b','b','b']
assert ['a','b','c','b','b'] - 'b' == ['a','c']
assert ['a','b','c','b','b'] - ['b','c'] == ['a']

def list = [1,2,3,4,3,2,1]
list -= 3           // creates a new list by removing `3` from the original one
assert list == [1,2,4,2,1]
assert ( list -= [2,4] ) == [1,1]
</code></pre>
<pre><code class="language-groovy">def list = ['a','b','c','d','e','f','b','b','a']
assert list.remove(2) == 'c'        // remove the third element, and return it
assert list == ['a','b','d','e','f','b','b','a']
</code></pre>
<h3 id="set-操作"><a class="header" href="#set-操作"><strong>set 操作</strong></a></h3>
<pre><code class="language-groovy">assert 'a' in ['a','b','c']             // returns true if an element belongs to the list
assert ['a','b','c'].contains('a')      // equivalent to the `contains` method in Java
assert [1,3,4].containsAll([1,4])       // `containsAll` will check that all elements are found

assert [1,2,3,3,3,3,4,5].count(3) == 4  // count the number of elements which have some value
assert [1,2,3,3,3,3,4,5].count {
    it%2==0                             // count the number of elements which match the predicate
} == 2

assert [1,2,4,6,8,10,12].intersect([1,3,6,9,12]) == [1,6,12]

assert [1,2,3].disjoint( [4,6,9] )
assert ![1,2,3].disjoint( [2,4,6] )
</code></pre>
<h3 id="排序"><a class="header" href="#排序"><strong>排序</strong></a></h3>
<pre><code class="language-groovy">assert [6, 3, 9, 2, 7, 1, 5].sort() == [1, 2, 3, 5, 6, 7, 9]

def list = ['abc', 'z', 'xyzuvw', 'Hello', '321']
assert list.sort {
    it.size()
} == ['z', 'abc', '321', 'Hello', 'xyzuvw']

def list2 = [7, 4, -6, -1, 11, 2, 3, -9, 5, -13]
assert list2.sort { a, b -&gt; a == b ? 0 : Math.abs(a) &lt; Math.abs(b) ? -1 : 1 } ==
        [-1, 2, 3, 4, 5, -6, 7, -9, 11, -13]

Comparator mc = { a, b -&gt; a == b ? 0 : Math.abs(a) &lt; Math.abs(b) ? -1 : 1 }

// JDK 8+ only
// list2.sort(mc)
// assert list2 == [-1, 2, 3, 4, 5, -6, 7, -9, 11, -13]

def list3 = [6, -3, 9, 2, -7, 1, 5]

Collections.sort(list3)
assert list3 == [-7, -3, 1, 2, 5, 6, 9]

Collections.sort(list3, mc)
assert list3 == [1, 2, -3, 5, 6, -7, 9]
</code></pre>
<p><strong>复制元素</strong></p>
<pre><code class="language-groovy">assert [1, 2, 3] * 3 == [1, 2, 3, 1, 2, 3, 1, 2, 3]
assert [1, 2, 3].multiply(2) == [1, 2, 3, 1, 2, 3]
assert Collections.nCopies(3, 'b') == ['b', 'b', 'b']

// nCopies from the JDK has different semantics than multiply for lists
assert Collections.nCopies(2, [1, 2]) == [[1, 2], [1, 2]] //not [1,2,1,2]
</code></pre>
<h2 id="maps"><a class="header" href="#maps">Maps</a></h2>
<h3 id="字面量map"><a class="header" href="#字面量map"><strong>字面量Map</strong></a></h3>
<pre><code class="language-groovy">//定义
def map = [name: 'Gromit', likes: 'cheese', id: 1234]
#取值
assert map.get('name') == 'Gromit'
assert map.get('id') == 1234
assert map['name'] == 'Gromit'
assert map['id'] == 1234
# 判断类型
assert map instanceof java.util.Map
# 空Map
def emptyMap = [:]

assert emptyMap.size() == 0
emptyMap.put(&quot;foo&quot;, 5)
assert emptyMap.size() == 1
assert emptyMap.get(&quot;foo&quot;) == 5
</code></pre>
<blockquote>
<p>Map keys are strings by default: <code>[a:1]</code> is equivalent to <code>['a':1]</code></p>
</blockquote>
<h3 id="浅拷贝"><a class="header" href="#浅拷贝"><strong>浅拷贝</strong></a></h3>
<pre><code class="language-groovy">def map = [
        simple : 123,
        complex: [a: 1, b: 2]
]
def map2 = map.clone()
assert map2.get('simple') == map.get('simple')
assert map2.get('complex') == map.get('complex')
map2.get('complex').put('c', 3)
assert map.get('complex').get('c') == 3
</code></pre>
<h3 id="属性符号"><a class="header" href="#属性符号">属性符号</a></h3>
<blockquote>
<p>Maps 也像 bean 一样，所以你可以使用属性符号来获取/设置 Map 内的项目，只要键是有效的 Groovy 标识符的字符串</p>
</blockquote>
<pre><code class="language-groovy">def map = [name: 'Gromit', likes: 'cheese', id: 1234]
assert map.name == 'Gromit'     // can be used instead of map.get('name')
assert map.id == 1234

def emptyMap = [:]
assert emptyMap.size() == 0
emptyMap.foo = 5
assert emptyMap.size() == 1
assert emptyMap.foo == 5
</code></pre>
<p><strong>字符串不能 与保留字相同</strong></p>
<pre><code class="language-groovy">def map = [name: 'Gromit', likes: 'cheese', id: 1234]
assert map.class == null
assert map.get('class') == null
assert map.getClass() == LinkedHashMap // this is probably what you want

map = [1      : 'a',
       (true) : 'p',
       (false): 'q',
       (null) : 'x',
       'null' : 'z']
assert map.containsKey(1) // 1 is not an identifier so used as is
assert map.true == null
assert map.false == null
assert map.get(true) == 'p'
assert map.get(false) == 'q'
assert map.null == 'z'
assert map.get(null) == 'x'
</code></pre>
<h3 id="迭代-1"><a class="header" href="#迭代-1">迭代</a></h3>
<pre><code class="language-groovy">def map = [
        Bob  : 42,
        Alice: 54,
        Max  : 33
]

// `entry` is a map entry
map.each { entry -&gt;
    println &quot;Name: $entry.key Age: $entry.value&quot;
}

// `entry` is a map entry, `i` the index in the map
map.eachWithIndex { entry, i -&gt;
    println &quot;$i - Name: $entry.key Age: $entry.value&quot;
}

// Alternatively you can use key and value directly
map.each { key, value -&gt;
    println &quot;Name: $key Age: $value&quot;
}

// Key, value and i as the index in the map
map.eachWithIndex { key, value, i -&gt;
    println &quot;$i - Name: $key Age: $value&quot;
}
</code></pre>
<h3 id="修改map"><a class="header" href="#修改map">修改Map</a></h3>
<pre><code class="language-groovy">def defaults = [1: 'a', 2: 'b', 3: 'c', 4: 'd']
def overrides = [2: 'z', 5: 'x', 13: 'x']

def result = new LinkedHashMap(defaults)
result.put(15, 't')
result[17] = 'u'
result.putAll(overrides)
assert result == [1: 'a', 2: 'z', 3: 'c', 4: 'd', 5: 'x', 13: 'x', 15: 't', 17: 'u']
</code></pre>
<p><strong>清空</strong></p>
<pre><code class="language-groovy">def m = [1:'a', 2:'b']
assert m.get(1) == 'a'
m.clear()
assert m == [:]
</code></pre>
<p><strong>注意：GString 的hashCode与String的HashCode值不一样</strong></p>
<pre><code class="language-groovy">def key = 'some key'
def map = [:]
def gstringKey = &quot;${key.toUpperCase()}&quot;
map.put(gstringKey,'value')
assert map.get('SOME KEY') == null
</code></pre>
<p><strong>key视图，value视图</strong></p>
<pre><code class="language-groovy">def map = [1:'a', 2:'b', 3:'c']

def entries = map.entrySet()
entries.each { entry -&gt;
  assert entry.key in [1,2,3]
  assert entry.value in ['a','b','c']
}

def keys = map.keySet()
assert keys == [1,2,3] as Set
</code></pre>
<h3 id="过滤和排序"><a class="header" href="#过滤和排序">过滤和排序</a></h3>
<pre><code class="language-groovy">def people = [
    1: [name:'Bob', age: 32, gender: 'M'],
    2: [name:'Johnny', age: 36, gender: 'M'],
    3: [name:'Claire', age: 21, gender: 'F'],
    4: [name:'Amy', age: 54, gender:'F']
]

def bob = people.find { it.value.name == 'Bob' } // find a single entry
def females = people.findAll { it.value.gender == 'F' }

// both return entries, but you can use collect to retrieve the ages for example
def ageOfBob = bob.value.age
def agesOfFemales = females.collect {
    it.value.age
}

assert ageOfBob == 32
assert agesOfFemales == [21,54]

// but you could also use a key/pair value as the parameters of the closures
def agesOfMales = people.findAll { id, person -&gt;
    person.gender == 'M'
}.collect { id, person -&gt;
    person.age
}
assert agesOfMales == [32, 36]

// `every` returns true if all entries match the predicate
assert people.every { id, person -&gt;
    person.age &gt; 18
}

// `any` returns true if any entry matches the predicate

assert people.any { id, person -&gt;
    person.age == 54
}
</code></pre>
<p><strong>分组</strong></p>
<pre><code class="language-groovy">assert ['a', 7, 'b', [2, 3]].groupBy {
    it.class
} == [(String)   : ['a', 'b'],
      (Integer)  : [7],
      (ArrayList): [[2, 3]]
]

assert [
        [name: 'Clark', city: 'London'], [name: 'Sharma', city: 'London'],
        [name: 'Maradona', city: 'LA'], [name: 'Zhang', city: 'HK'],
        [name: 'Ali', city: 'HK'], [name: 'Liu', city: 'HK'],
].groupBy { it.city } == [
        London: [[name: 'Clark', city: 'London'],
                 [name: 'Sharma', city: 'London']],
        LA    : [[name: 'Maradona', city: 'LA']],
        HK    : [[name: 'Zhang', city: 'HK'],
                 [name: 'Ali', city: 'HK'],
                 [name: 'Liu', city: 'HK']],
]
</code></pre>
<h2 id="序列"><a class="header" href="#序列">序列</a></h2>
<h3 id="定义序列"><a class="header" href="#定义序列">定义序列</a></h3>
<blockquote>
<p>用 <code>..</code> 符号定义的范围是包含的（即列表包含 from 和 to 值）。</p>
<p>用 ..&lt; 符号定义的范围是半开的，它们包括第一个值但不包括最后一个值。</p>
</blockquote>
<pre><code class="language-groovy">// an inclusive range
def range = 5..8
assert range.size() == 4
assert range.get(2) == 7
assert range[2] == 7
assert range instanceof java.util.List
assert range.contains(5)
assert range.contains(8)

// lets use a half-open range
range = 5..&lt;8
assert range.size() == 3
assert range.get(2) == 7
assert range[2] == 7
assert range instanceof java.util.List
assert range.contains(5)
assert !range.contains(8)

//get the end points of the range without using indexes
range = 1..10
assert range.from == 1
assert range.to == 10
</code></pre>
<p><strong>自定义序列</strong></p>
<p>只要实现 <em>Comparable</em> <em>next()</em> <em>previoust()</em> 就能创建序列</p>
<pre><code class="language-groovy">// an inclusive range
def range = 'a'..'d'
assert range.size() == 4
assert range.get(2) == 'c'
assert range[2] == 'c'
assert range instanceof java.util.List
assert range.contains('a')
assert range.contains('d')
assert !range.contains('e')
</code></pre>
<h3 id="迭代-2"><a class="header" href="#迭代-2"><strong>迭代</strong></a></h3>
<p><strong>for循环</strong></p>
<pre><code class="language-groovy">for (i in 1..10) {
    println &quot;Hello ${i}&quot;
}
</code></pre>
<pre><code class="language-groovy">(1..10).each { i -&gt;
    println &quot;Hello ${i}&quot;
}
</code></pre>
<pre><code class="language-groovy">switch (years) {
    case 1..10: interestRate = 0.076; break;
    case 11..25: interestRate = 0.052; break;
    default: interestRate = 0.037;
}
</code></pre>
<h2 id="集合语法增强"><a class="header" href="#集合语法增强">集合语法增强</a></h2>
<h3 id="gpath支持"><a class="header" href="#gpath支持">GPath支持</a></h3>
<ul>
<li>dot 从集合中的每个元素上取 属性为a的对象，如果取不到则过滤</li>
<li>*dot  从集合中的每个元素上取 属性为a的对象，如果取不到则赋值为空</li>
</ul>
<p>由于对 list 和 map 的属性表示法的支持，Groovy 提供了语法糖，使得处理嵌套集合非常容易</p>
<pre><code class="language-groovy">def listOfMaps = [['a': 11, 'b': 12], ['a': 21, 'b': 22]]
assert listOfMaps.a == [11, 21] //GPath notation
assert listOfMaps*.a == [11, 21] //spread dot notation

listOfMaps = [['a': 11, 'b': 12], ['a': 21, 'b': 22], null]
assert listOfMaps*.a == [11, 21, null] // caters for null values
assert listOfMaps*.a == listOfMaps.collect { it?.a } //equivalent notation
// But this will only collect non-null values
assert listOfMaps.a == [11,21]
</code></pre>
<h3 id="集合展开"><a class="header" href="#集合展开">集合展开</a></h3>
<pre><code class="language-groovy"># 类似于 调用   putAll,但是已有的同名key不会更新
assert [ 'z': 900,
         *: ['a': 100, 'b': 200], 'a': 300] == ['a': 300, 'b': 200, 'z': 900]
//spread map notation in map definition
assert [*: [3: 3, *: [5: 5]], 7: 7] == [3: 3, 5: 5, 7: 7]
//定义闭包返回Map
def f = { [1: 'u', 2: 'v', 3: 'w'] }
assert [*: f(), 10: 'zz'] == [1: 'u', 10: 'zz', 2: 'v', 3: 'w']
//spread map notation in function arguments
f = { map -&gt; map.c }
assert f(*: ['a': 10, 'b': 20, 'c': 30], 'e': 50) == 30

f = { m, i, j, k -&gt; [m, i, j, k] }
//using spread map notation with mixed unnamed and named arguments
assert f('e': 100, *[4, 5], *: ['a': 10, 'b': 20, 'c': 30], 6) ==
        [[&quot;e&quot;: 100, &quot;b&quot;: 20, &quot;c&quot;: 30, &quot;a&quot;: 10], 4, 5, 6]
</code></pre>
<h3 id="点运算符"><a class="header" href="#点运算符">*点运算符</a></h3>
<p>“星点”运算符是一个快捷运算符，允许您调用集合中所有元素的方法或属性：</p>
<pre><code class="language-groovy">assert [1, 3, 5] == ['a', 'few', 'words']*.size()

class Person {
    String name
    int age
}
def persons = [new Person(name:'Hugo', age:17), new Person(name:'Sandra',age:19)]
assert [17, 19] == persons*.age
</code></pre>
<h3 id="使用下标运算符切片"><a class="header" href="#使用下标运算符切片">使用下标运算符切片</a></h3>
<p>您可以使用下标表达式对列表、数组、映射进行索引。有趣的是，在这种情况下，字符串被视为特殊类型的集合：</p>
<pre><code class="language-groovy">def text = 'nice cheese gromit!'
def x = text[2]

assert x == 'c'
assert x.class == String

def sub = text[5..10]
assert sub == 'cheese'

def list = [10, 11, 12, 13]
def answer = list[2,3]
assert answer == [12,13]
</code></pre>
<p><strong>断点切片</strong></p>
<pre><code class="language-groovy">list = 100..200
sub = list[1, 3, 20..25, 33]
assert sub == [101, 103, 120, 121, 122, 123, 124, 125, 133]
</code></pre>
<p><strong>下标运算符可用于更新现有集合（对于可变的集合类型）：</strong></p>
<pre><code class="language-groovy">list = ['a','x','x','d']
list[1..2] = ['b','c']
assert list == ['a','b','c','d']
</code></pre>
<p>值得注意的是，允许使用负索引，以便更轻松地从集合的末尾提取：</p>
<pre><code class="language-groovy">text = &quot;nice cheese gromit!&quot;
x = text[-1]
assert x == &quot;!&quot;
</code></pre>
<p>您可以使用负索引从列表、数组、字符串等的末尾开始计数。</p>
<pre><code class="language-groovy">def name = text[-7..-2]
assert name == &quot;gromit&quot;
</code></pre>
<p>如果您使用反向索引（起始索引大于结束索引），则答案相反。</p>
<pre><code class="language-groovy">text = &quot;nice cheese gromit!&quot;
name = text[3..1]
assert name == &quot;eci&quot;
</code></pre>
<h1 id="java18日期类"><a class="header" href="#java18日期类">java1.8日期类</a></h1>
<p>groovy-datetime 模块支持许多扩展以使用 Java 8 中引入的日期/时间 API。本文档将此 API 定义的数据类型称为“JSR 310 类型”。</p>
<h2 id="formatting-and-parsing"><a class="header" href="#formatting-and-parsing">Formatting and parsing</a></h2>
<table><thead><tr><th style="text-align: left">Method</th><th style="text-align: left">Description</th><th style="text-align: left">Example</th></tr></thead><tbody>
<tr><td style="text-align: left"><code>getDateString()</code></td><td style="text-align: left">针对于 LocalDate LocalDateTime 日期或时间类型转 string,</td><td style="text-align: left"><code>2018-03-10</code></td></tr>
<tr><td style="text-align: left"></td><td style="text-align: left"><code>OffsetDateTime</code>, <code>DateTimeFormatter.ISO_OFFSET_DATE</code></td><td style="text-align: left"><code>2018-03-10+04:00</code></td></tr>
<tr><td style="text-align: left"></td><td style="text-align: left">For <code>ZonedDateTime</code>, formats with DateTimeFormatter.ISO_LOCAL_DAT  and appends the <code>ZoneId</code> short name</td><td style="text-align: left"><code>2018-03-10EST</code></td></tr>
<tr><td style="text-align: left"><code>getDateTimeString()</code></td><td style="text-align: left">For <code>LocalDateTime</code>, formats with DateTimeFormatter.ISO_LOCAL_DATE_TIME</td><td style="text-align: left"><code>2018-03-10T20:30:45</code></td></tr>
<tr><td style="text-align: left"></td><td style="text-align: left">For <code>OffsetDateTime</code>, formats with DateTimeFormatter.ISO_OFFSET_DATE_TIME</td><td style="text-align: left"><code>2018-03-10T20:30:45+04:00</code></td></tr>
<tr><td style="text-align: left"></td><td style="text-align: left">For <code>ZonedDateTime</code>, formats with DateTimeFormatter.ISO_LOCAL_DATE_TIME and appends the <code>ZoneId</code> short name</td><td style="text-align: left"><code>2018-03-10T20:30:45EST</code></td></tr>
<tr><td style="text-align: left"><code>getTimeString()</code></td><td style="text-align: left">For <code>LocalTime</code> and <code>LocalDateTime</code>, formats with DateTimeFormatter.ISO_LOCAL_TIME</td><td style="text-align: left"><code>20:30:45</code></td></tr>
<tr><td style="text-align: left"></td><td style="text-align: left">For <code>OffsetTime</code> and <code>OffsetDateTime</code>, formats with DateTimeFormatter.ISO_OFFSET_TIME formatter</td><td style="text-align: left"><code>20:30:45+04:00</code></td></tr>
<tr><td style="text-align: left"></td><td style="text-align: left">For <code>ZonedDateTime</code>, formats with DateTimeFormatter.ISO_LOCAL_TIME and appends the <code>ZoneId</code> short name</td><td style="text-align: left"><code>20:30:45EST</code></td></tr>
<tr><td style="text-align: left"><code>format(FormatStyle style)</code></td><td style="text-align: left">For <code>LocalTime</code> and <code>OffsetTime</code>, formats with DateTimeFormatter.ofLocalizedTime(style)</td><td style="text-align: left"><code>4:30 AM</code> (with style <code>FormatStyle.SHORT</code>, e.g.)</td></tr>
<tr><td style="text-align: left"></td><td style="text-align: left">For <code>LocalDate</code>, formats with DateTimeFormatter.ofLocalizedDate(style)</td><td style="text-align: left"><code>Saturday, March 10, 2018</code> (with style <code>FormatStyle.FULL</code>, e.g.)</td></tr>
<tr><td style="text-align: left"></td><td style="text-align: left">For <code>LocalDateTime</code>, <code>OffsetDateTime</code>, and <code>ZonedDateTime</code> formats with DateTimeFormatter.ofLocalizedDateTime(style)</td><td style="text-align: left"><code>Mar 10, 2019 4:30:45 AM</code> (with style <code>FormatStyle.MEDIUM</code>, e.g.)</td></tr>
<tr><td style="text-align: left"><code>format(String pattern)</code></td><td style="text-align: left">Formats with DateTimeFormatter.ofPattern(pattern)</td><td style="text-align: left"><code>03/10/2018</code> (with pattern ’MM/dd/yyyy', e.g.)</td></tr>
</tbody></table>
<h2 id="修改时间"><a class="header" href="#修改时间">修改时间</a></h2>
<h3 id="加减"><a class="header" href="#加减">加减</a></h3>
<pre><code class="language-groovy">def aprilFools = LocalDate.of(2018, Month.APRIL, 1)

def nextAprilFools = aprilFools + Period.ofDays(365) // add 365 days
assert nextAprilFools.year == 2019

def idesOfMarch = aprilFools - Period.ofDays(17) // subtract 17 days
assert idesOfMarch.dayOfMonth == 15
assert idesOfMarch.month == Month.MARCH
</code></pre>
<pre><code class="language-groovy">def nextAprilFools = aprilFools + 365 // add 365 days
def idesOfMarch = aprilFools - 17 // subtract 17 days
</code></pre>
<p>这些整数的单位取决于 JSR 310 类型操作数</p>
<pre><code class="language-groovy">//整形以秒为单位
def mars = LocalTime.of(12, 34, 56) // 12:34:56 pm

def thirtySecondsToMars = mars - 30 // go back 30 seconds
assert thirtySecondsToMars.second == 26
</code></pre>
<h3 id="乘除"><a class="header" href="#乘除">乘除</a></h3>
<p>乘法运算符可用于将 Period 和 Duration 实例乘以整数值； </p>
<p>除法运算符可用于将 Duration 实例除以整数值。</p>
<pre><code class="language-groovy">def period = Period.ofMonths(1) * 2 // a 1-month period times 2
assert period.months == 2

def duration = Duration.ofSeconds(10) / 5// a 10-second duration divided by 5
assert duration.seconds == 2
</code></pre>
<p><strong>递增递减</strong></p>
<pre><code class="language-groovy">def year = Year.of(2000)
--year // decrement by one year
assert year.value == 1999

def offsetTime = OffsetTime.of(0, 0, 0, 0, ZoneOffset.UTC) // 00:00:00.000 UTC
offsetTime++ // increment by one second
assert offsetTime.second == 1
</code></pre>
<h3 id="negation"><a class="header" href="#negation">Negation</a></h3>
<pre><code class="language-groovy">def duration = Duration.ofSeconds(-15)
def negated = -duration
assert negated.seconds == 15
</code></pre>
<h2 id="与日期时间值交互"><a class="header" href="#与日期时间值交互">与日期/时间值交互</a></h2>
<h3 id="直接属性访问"><a class="header" href="#直接属性访问"><strong>直接属性访问</strong></a></h3>
<pre><code class="language-groovy">def date = LocalDate.of(2018, Month.MARCH, 12)
assert date[ChronoField.YEAR] == 2018
assert date[ChronoField.MONTH_OF_YEAR] == Month.MARCH.value
assert date[ChronoField.DAY_OF_MONTH] == 12
assert date[ChronoField.DAY_OF_WEEK] == DayOfWeek.MONDAY.value

def period = Period.ofYears(2).withMonths(4).withDays(6)
assert period[ChronoUnit.YEARS] == 2
assert period[ChronoUnit.MONTHS] == 4
assert period[ChronoUnit.DAYS] == 6
</code></pre>
<h3 id="ranges-upto-and-downto"><a class="header" href="#ranges-upto-and-downto">Ranges, <code>upto</code>, and <code>downto</code></a></h3>
<p><strong>时间范围迭代</strong></p>
<pre><code class="language-groovy">def start = LocalDate.now()
def end = start + 6 // 6 days later
(start..end).each { date -&gt;
    println date.dayOfWeek
}
</code></pre>
<p><strong>同上述</strong></p>
<pre><code class="language-groovy">def start = LocalDate.now()
def end = start + 6 // 6 days later
start.upto(end) { next -&gt;
    println next.dayOfWeek
}
</code></pre>
<p>upto、downto、ranges 的迭代单位与加减法的单位相同：LocalDate 一次迭代一天，YearMonth 迭代一个月，Year 迭代一年，其他时间迭代一秒。</p>
<p>这两种方法还支持可选的 TemporalUnit 参数来更改迭代单位。</p>
<pre><code class="language-groovy">//按月迭代
def start = LocalDate.of(2018, Month.MARCH, 1)
def end = start + 1 // 1 day later

int iterationCount = 0
start.upto(end, ChronoUnit.MONTHS) { next -&gt;
    println next
    ++iterationCount
}

assert iterationCount == 1
</code></pre>
<h3 id="combining-datetime-values"><a class="header" href="#combining-datetime-values">Combining date/time values</a></h3>
<p>左移运算符 (&lt;&lt;) 可用于将两个 JSR 310 类型组合成一个聚合类型。</p>
<p>例如，可以将 LocalDate 左移到 LocalTime 以生成复合 LocalDateTime 实例。</p>
<pre><code class="language-groovy">MonthDay monthDay = Month.JUNE &lt;&lt; 3 // June 3rd
LocalDate date = monthDay &lt;&lt; Year.of(2015) // 3-Jun-2015
LocalDateTime dateTime = date &lt;&lt; LocalTime.NOON // 3-Jun-2015 @ 12pm
OffsetDateTime offsetDateTime = dateTime &lt;&lt; ZoneOffset.ofHours(-5) // 3-Jun-2015 @ 12pm UTC-5
</code></pre>
<p>左移运算符是自反的；</p>
<p>操作数的顺序无关紧要。</p>
<pre><code class="language-groovy">def year = Year.of(2000)
def month = Month.DECEMBER

YearMonth a = year &lt;&lt; month
YearMonth b = month &lt;&lt; year
assert a == b
</code></pre>
<h3 id="创建时间段和持续时间"><a class="header" href="#创建时间段和持续时间">创建时间段和持续时间</a></h3>
<p>右移运算符 (&gt;&gt;) 生成一个值，表示操作数之间的周期或持续时间。</p>
<p>对于 ChronoLocalDate、YearMonth 和 Year，该运算符生成一个 Period 实例：</p>
<pre><code class="language-groovy">def newYears = LocalDate.of(2018, Month.JANUARY, 1)
def aprilFools = LocalDate.of(2018, Month.APRIL, 1)

def period = newYears &gt;&gt; aprilFools
assert period instanceof Period
assert period.months == 3
</code></pre>
<p>The operator produces a <code>Duration</code> for the time-aware JSR types:</p>
<pre><code class="language-groovy">def duration = LocalTime.NOON &gt;&gt; (LocalTime.NOON + 30)
assert duration instanceof Duration
assert duration.seconds == 30
</code></pre>
<p>如果运算符左侧的值早于右侧的值，则结果为正。</p>
<p>如果左侧晚于右侧，则结果为负：</p>
<h3 id="在传统和-jsr-310-类型之间转换"><a class="header" href="#在传统和-jsr-310-类型之间转换">在传统和 JSR 310 类型之间转换</a></h3>
<p>尽管 java.util 包中的 Date、Calendar 和 TimeZone 类型存在缺陷，但它们在 Java API 中非常常见（至少在 Java 8 之前的 API 中）。</p>
<p>为了适应此类 API 的使用，Groovy 提供了在 JSR 310 类型和遗留类型之间进行转换的方法。</p>
<p>大多数 JSR 类型都配备了 toDate() 和 toCalendar() 方法，用于转换为相对等效的 java.util.Date 和 java.util.Calendar 值。 </p>
<p>ZoneId 和 ZoneOffset 都被赋予了一个 toTimeZone() 方法来转换为 java.util.TimeZone。</p>
<pre><code class="language-groovy">/ LocalDate to java.util.Date
def valentines = LocalDate.of(2018, Month.FEBRUARY, 14)
assert valentines.toDate().format('MMMM dd, yyyy') == 'February 14, 2018'

// LocalTime to java.util.Date
def noon = LocalTime.of(12, 0, 0)
assert noon.toDate().format('HH:mm:ss') == '12:00:00'

// ZoneId to java.util.TimeZone
def newYork = ZoneId.of('America/New_York')
assert newYork.toTimeZone() == TimeZone.getTimeZone('America/New_York')

// ZonedDateTime to java.util.Calendar
def valAtNoonInNY = ZonedDateTime.of(valentines, noon, newYork)
assert valAtNoonInNY.toCalendar().getTimeZone().toZoneId() == newYork
</code></pre>
<p>请注意，在转换为旧类型时：</p>
<ul>
<li>
<p><strong>纳秒值被截断为毫秒。</strong></p>
<p>例如，一个 LocalTime 的 ChronoUnit.NANOS 值为 999,999,999 纳秒转换为 999 毫秒。</p>
</li>
<li>
<p>转换“本地”类型（LocalDate、LocalTime 和 LocalDateTime）时，返回的 Date 或 Calendar 的时区将是系统默认值</p>
</li>
<li>
<p>转换仅时间类型（LocalTime 或 OffsetTime）时，Date 或 Calendar 的年/月/日设置为当前日期。</p>
</li>
<li>
<p>转换仅日期类型（LocalDate）时，Date 或 Calendar 的时间值将被清除，即 00:00:00.000。</p>
</li>
<li>
<p>将 OffsetDateTime 转换为 Calendar 时，只有 ZoneOffset 的小时和分钟传送到相应的 TimeZone。</p>
<p>幸运的是，非零秒的区域偏移很少见。</p>
</li>
</ul>
<p>Groovy 向 Date 和 Calendar 添加了许多方法，用于转换为各种 JSR 310 类型：</p>
<pre><code class="language-groovy">Date legacy = Date.parse('yyyy-MM-dd HH:mm:ss.SSS', '2010-04-03 10:30:58.999')

assert legacy.toLocalDate() == LocalDate.of(2010, 4, 3)
assert legacy.toLocalTime() == LocalTime.of(10, 30, 58, 999_000_000) // 999M ns = 999ms
assert legacy.toOffsetTime().hour == 10
assert legacy.toYear() == Year.of(2010)
assert legacy.toMonth() == Month.APRIL
assert legacy.toDayOfWeek() == DayOfWeek.SATURDAY
assert legacy.toMonthDay() == MonthDay.of(Month.APRIL, 3)
assert legacy.toYearMonth() == YearMonth.of(2010, Month.APRIL)
assert legacy.toLocalDateTime().year == 2010
assert legacy.toOffsetDateTime().dayOfMonth == 3
assert legacy.toZonedDateTime().zone == ZoneId.systemDefault()
</code></pre>
<h1 id="有用的工具类"><a class="header" href="#有用的工具类">有用的工具类</a></h1>
<h2 id="configslurper"><a class="header" href="#configslurper">ConfigSlurper</a></h2>
<p>ConfigSlurper 是一个实用程序类，用于读取以 Groovy 脚本形式定义的配置文件。</p>
<p>就像 Java *.properties 文件的情况一样，ConfigSlurper 允许使用点符号。</p>
<p>但此外，它允许闭包范围的配置值和任意对象类型。</p>
<pre><code class="language-groovy">def config = new ConfigSlurper().parse('''
//点表示
app.date = new Date()  
    app.age  = 42
    //使用闭包作用域替代点表示法
    app {                  
        name = &quot;Test${42}&quot;
    }
''')

assert config.app.date instanceof Date
assert config.app.age == 42
assert config.app.name == 'Test42'
</code></pre>
<p>从上面的例子中可以看出，parse 方法可用于检索 groovy.util.ConfigObject 实例。 </p>
<p>ConfigObject 是一个专门的 java.util.Map 实现，它要么返回配置的值，要么返回一个新的 ConfigObject 实例，但永远不会为空。</p>
<pre><code class="language-groovy">def config = new ConfigSlurper().parse('''
    app.date = new Date()
    app.age  = 42
    app.name = &quot;Test${42}&quot;
''')

assert config.test != null   
</code></pre>
<p>如果点是配置变量名称的一部分，则可以使用单引号或双引号对其进行转义</p>
<pre><code class="language-groovy">def config = new ConfigSlurper().parse('''
    app.&quot;person.age&quot;  = 42
''')

assert config.app.&quot;person.age&quot; == 42
</code></pre>
<p><strong>环境变量</strong></p>
<pre><code class="language-groovy">def config = new ConfigSlurper('development').parse('''
  environments {
       development {
           app.port = 8080
       }

       test {
           app.port = 8082
       }

       production {
           app.port = 80
       }
  }
''')

assert config.app.port == 8080
</code></pre>
<p>环境方法是内置的，但 registerConditionalBlock 方法可用于注册除环境名称之外的其他方法名称。</p>
<pre><code class="language-groovy">def slurper = new ConfigSlurper()
slurper.registerConditionalBlock('myProject', 'developers')   

def config = slurper.parse('''
  sendMail = true

  myProject {
       developers {
           sendMail = false
       }
  }
''')

assert !config.sendMail
</code></pre>
<p>出于 Java 集成的目的，可以使用 toProperties 方法将 ConfigObject 转换为 java.util.Properties 对象，该对象可能存储到 *.properties 文本文件中。</p>
<p>请注意，在将配置值添加到新创建的 Properties 实例期间，它们会转换为 String 实例。</p>
<pre><code class="language-groovy">def config = new ConfigSlurper().parse('''
    app.date = new Date()
    app.age  = 42
    app {
        name = &quot;Test${42}&quot;
    }
''')

def properties = config.toProperties()

assert properties.&quot;app.date&quot; instanceof String
assert properties.&quot;app.age&quot; == '42'
assert properties.&quot;app.name&quot; == 'Test42'
</code></pre>
<h2 id="expando"><a class="header" href="#expando">Expando</a></h2>
<p>Expando 类可用于创建动态可扩展对象。每个 Expando 对象都代表一个独立的、动态制作的实例，可以在运行时使用属性（或方法）进行扩展。</p>
<pre><code class="language-groovy">def expando = new Expando()
expando.name = 'John'

assert expando.name == 'John'
</code></pre>
<p>当动态属性注册一个闭包代码块时会发生一种特殊情况。</p>
<p>一旦注册，就可以像调用方法一样调用它。</p>
<pre><code class="language-groovy">def expando = new Expando()
expando.toString = { -&gt; 'John' }
expando.say = { String s -&gt; &quot;John says: ${s}&quot; }

assert expando as String == 'John'
assert expando.say('Hi') == 'John says: Hi'
</code></pre>
<h2 id="observable-list-map-and-set"><a class="header" href="#observable-list-map-and-set">Observable list, map and set</a></h2>
<p>当添加、删除或更改元素时，这些集合中的每一个都会触发 java.beans.PropertyChangeEvent 事件。</p>
<p>请注意，PropertyChangeEvent 不仅表示某个事件已发生，而且还保存有关属性名称和某个属性已更改为的旧/新值的信息。</p>
<pre><code class="language-groovy">def event                                       
def listener = {
    if (it instanceof ObservableList.ElementEvent)  {  
        event = it
    }
} as PropertyChangeListener


def observable = [1, 2, 3] as ObservableList    
observable.addPropertyChangeListener(listener)  

observable.add 42                               

assert event instanceof ObservableList.ElementAddedEvent

def elementAddedEvent = event as ObservableList.ElementAddedEvent
assert elementAddedEvent.changeType == ObservableList.ChangeType.ADDED
assert elementAddedEvent.index == 3
assert elementAddedEvent.oldValue == null
assert elementAddedEvent.newValue == 42
</code></pre>
<pre><code class="language-groovy">def event
def listener = {
    if (it instanceof ObservableList.ElementEvent)  {
        event = it
    }
} as PropertyChangeListener


def observable = [1, 2, 3] as ObservableList
observable.addPropertyChangeListener(listener)

observable.clear()

assert event instanceof ObservableList.ElementClearedEvent

def elementClearedEvent = event as ObservableList.ElementClearedEvent
assert elementClearedEvent.values == [1, 2, 3]
assert observable.size() == 0
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="arithmetic-operators"><a class="header" href="#arithmetic-operators">Arithmetic operators</a></h1>
<h2 id="normal-arithmetic-operators"><a class="header" href="#normal-arithmetic-operators">Normal arithmetic operators</a></h2>
<p>The following binary arithmetic operators are available in Groovy:</p>
<table><thead><tr><th style="text-align: left">Operator</th><th style="text-align: left">Purpose</th><th style="text-align: left">Remarks</th></tr></thead><tbody>
<tr><td style="text-align: left"><code>+</code></td><td style="text-align: left">addition</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left"><code>-</code></td><td style="text-align: left">subtraction</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left"><code>*</code></td><td style="text-align: left">multiplication</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left"><code>/</code></td><td style="text-align: left">division</td><td style="text-align: left">Use <code>intdiv()</code> for integer division, and see the section about <a href="https://docs.groovy-lang.org/latest/html/documentation/core-syntax.html#integer_division">integer division</a> for more information on the return type of the division.</td></tr>
<tr><td style="text-align: left"><code>%</code></td><td style="text-align: left">remainder</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left"><code>**</code></td><td style="text-align: left">power</td><td style="text-align: left">See the section about <a href="https://docs.groovy-lang.org/latest/html/documentation/core-syntax.html#power_operator">the power operation</a> for more information on the return type of the operation.</td></tr>
</tbody></table>
<h2 id="unary-operators"><a class="header" href="#unary-operators">Unary operators</a></h2>
<p>一元运算符</p>
<pre><code class="language-.groovy">assert +3 == 3
assert -4 == 0 - 4

assert -(-1) == 1  
</code></pre>
<p>请注意使用括号包围表达式以将一元减号应用于该被包围的表达式。</p>
<p>就一元算术运算符而言，可用前缀和后缀表示法的 ++（增量）和 --（减量）运算符：</p>
<pre><code class="language-groovy">def a = 2
def b = a++ * 3             

assert a == 3 &amp;&amp; b == 6

def c = 3
def d = c-- * 2             

assert c == 2 &amp;&amp; d == 6

def e = 1
def f = ++e + 3             

assert e == 2 &amp;&amp; f == 5

def g = 4
def h = --g + 1             

assert g == 3 &amp;&amp; h == 4
</code></pre>
<h2 id="assignment-arithmetic-operators"><a class="header" href="#assignment-arithmetic-operators">Assignment arithmetic operators</a></h2>
<p>赋值算术运算符</p>
<p>我们上面看到的二元算术运算符也有赋值形式：-<code>+=</code></p>
<ul>
<li><code>-=</code></li>
<li><code>*=</code></li>
<li><code>/=</code></li>
<li><code>%=</code></li>
<li><code>**=</code></li>
</ul>
<pre><code class="language-groovy">def a = 4
a += 3

assert a == 7

def b = 5
b -= 3

assert b == 2

def c = 5
c *= 3

assert c == 15

def d = 10
d /= 2

assert d == 5

def e = 10
e %= 3

assert e == 1

def f = 3
f **= 2

assert f == 9
</code></pre>
<h1 id="relational-operators"><a class="header" href="#relational-operators">Relational operators</a></h1>
<p>关系运算符允许在对象之间进行比较，以了解两个对象是否相同或不同，或者一个对象是否大于、小于或等于另一个。</p>
<p>The following operators are available:</p>
<table><thead><tr><th style="text-align: left">Operator</th><th style="text-align: left">Purpose</th></tr></thead><tbody>
<tr><td style="text-align: left"><code>==</code></td><td style="text-align: left">equal</td></tr>
<tr><td style="text-align: left"><code>!=</code></td><td style="text-align: left">different</td></tr>
<tr><td style="text-align: left"><code>&lt;</code></td><td style="text-align: left">less than</td></tr>
<tr><td style="text-align: left"><code>&lt;=</code></td><td style="text-align: left">less than or equal</td></tr>
<tr><td style="text-align: left"><code>&gt;</code></td><td style="text-align: left">greater than</td></tr>
<tr><td style="text-align: left"><code>&gt;=</code></td><td style="text-align: left">greater than or equal</td></tr>
<tr><td style="text-align: left"><code>===</code></td><td style="text-align: left">identical (Since Groovy 3.0.0)</td></tr>
<tr><td style="text-align: left"><code>!==</code></td><td style="text-align: left">not identical (Since Groovy 3.0.0)</td></tr>
</tbody></table>
<p>===<code>和</code>!==<code>都被支持，它们分别与调用</code>is()<code>方法和否定调用</code>is()` 方法相同。</p>
<h1 id="logical-operators"><a class="header" href="#logical-operators">Logical operators</a></h1>
<ul>
<li><code>&amp;&amp;</code>: logical &quot;and&quot;</li>
<li><code>||</code>: logical &quot;or&quot;</li>
<li><code>!</code>: logical &quot;not&quot;</li>
</ul>
<pre><code class="language-groovy">assert !false           
assert true &amp;&amp; true     
assert true || false    
</code></pre>
<h2 id="precedence"><a class="header" href="#precedence">Precedence</a></h2>
<p>逻辑“非”比逻辑“与”具有更高的优先级。</p>
<pre><code class="language-groovy">assert (!false &amp;&amp; false) == false   
</code></pre>
<p>逻辑“与”比逻辑“或”具有更高的优先级。</p>
<pre><code class="language-groovy">assert true || true &amp;&amp; false        
</code></pre>
<h2 id="short-circuiting"><a class="header" href="#short-circuiting">Short-circuiting</a></h2>
<pre><code class="language-groovy">boolean checkIfCalled() {   
    called = true
}

called = false
true || checkIfCalled()
assert !called              

called = false
false || checkIfCalled()
assert called               

called = false
false &amp;&amp; checkIfCalled()
assert !called              

called = false
true &amp;&amp; checkIfCalled()
assert called               
</code></pre>
<h1 id="bitwise-and-bit-shift-operators"><a class="header" href="#bitwise-and-bit-shift-operators">Bitwise and bit shift operators</a></h1>
<h2 id="bitwise-operators"><a class="header" href="#bitwise-operators">Bitwise operators</a></h2>
<blockquote>
<p>位运算</p>
</blockquote>
<p>按位和位移运算符</p>
<ul>
<li><code>&amp;</code>: bitwise &quot;and&quot;</li>
<li><code>|</code>: bitwise &quot;or&quot;</li>
<li><code>^</code>: bitwise &quot;xor&quot; (exclusive &quot;or&quot;)</li>
<li><code>~</code>: bitwise negation</li>
</ul>
<p>位运算符可应用于字节、短整型、整型、长整型或大整数类型的参数。</p>
<p>如果参数之一是 BigInteger，则结果将是 BigInteger 类型；</p>
<p>否则，如果其中一个参数是 long，则结果将是 long 类型；</p>
<h2 id="bit-shift-operators"><a class="header" href="#bit-shift-operators">Bit shift operators</a></h2>
<p>移位运算</p>
<ul>
<li><code>&lt;&lt;</code>: left shift</li>
<li><code>&gt;&gt;</code>: right shift</li>
<li><code>&gt;&gt;&gt;</code>: right shift unsigned</li>
</ul>
<pre><code class="language-groovy">assert 12.equals(3 &lt;&lt; 2)           
assert 24L.equals(3L &lt;&lt; 3)         
assert 48G.equals(3G &lt;&lt; 4)         

assert 4095 == -200 &gt;&gt;&gt; 20
assert -1 == -200 &gt;&gt; 20
assert 2G == 5G &gt;&gt; 1
assert -3G == -5G &gt;&gt; 1
</code></pre>
<p>在 Groovy 中，位移运算符是可重载的，这意味着您可以为任何类型的对象定义这些运算符的行为。</p>
<h1 id="conditional-operators"><a class="header" href="#conditional-operators">Conditional operators</a></h1>
<h2 id="not-operator"><a class="header" href="#not-operator">Not operator</a></h2>
<p>“not”运算符用感叹号 (!) 表示，并反转底层布尔表达式的结果。特别是，可以将 not 运算符与 Groovy  truth 结合起来：</p>
<pre><code class="language-groovy">assert (!true)    == false                      
assert (!'foo')   == false                      
assert (!'')      == true                       
</code></pre>
<h2 id="ternary-operator"><a class="header" href="#ternary-operator">Ternary operator</a></h2>
<p>三元运算符</p>
<pre><code class="language-groovy">result = (string!=null &amp;&amp; string.length()&gt;0) ? 'Found' : 'Not found'
</code></pre>
<h2 id="elvis-operator"><a class="header" href="#elvis-operator">Elvis operator</a></h2>
<p>是三元运算符得缩写形式</p>
<pre><code class="language-groovy">displayName = user.name ? user.name : 'Anonymous'   
displayName = user.name ?: 'Anonymous'     
</code></pre>
<p>Elvis 运算符的使用减少了代码的冗长性，并降低了重构时出错的风险，因为无需复制在条件和正返回值中都测试过的表达式。</p>
<h2 id="elvis-assignment-operator"><a class="header" href="#elvis-assignment-operator">Elvis assignment operator</a></h2>
<pre><code class="language-groovy">import groovy.transform.ToString

@ToString
class Element {
    String name
    int atomicNumber
}

def he = new Element(name: 'Helium')
he.with {
    name = name ?: 'Hydrogen'   // existing Elvis operator
    atomicNumber ?= 2           // new Elvis assignment shorthand
}
assert he.toString() == 'Element(Helium, 2)'
</code></pre>
<h1 id="object-operators"><a class="header" href="#object-operators">Object operators</a></h1>
<h2 id="safe-navigation-operator"><a class="header" href="#safe-navigation-operator">Safe navigation operator</a></h2>
<p><strong>安全导航运算符</strong>用于避免 NullPointerException。</p>
<p>通常，当您有一个对象的引用时，您可能需要在访问该对象的方法或属性之前验证它是否为空。</p>
<p>为了避免这种情况，安全导航运算符将简单地返回 null 而不是抛出异常，如下所示：</p>
<pre><code class="language-groovy">def person = Person.find { it.id == 123 }    
def name = person?.name                      
assert name == null                          
</code></pre>
<h3 id="direct-field-access-operator"><a class="header" href="#direct-field-access-operator">Direct field access operator</a></h3>
<blockquote>
<p>直接字段访问操作符.</p>
</blockquote>
<p><strong>普通访问会调用Get方法</strong></p>
<pre><code class="language-groovy">class User {
    public final String name                 
    User(String name) { this.name = name}
    String getName() { &quot;Name: $name&quot; }       
}
def user = new User('Bob')
assert user.name == 'Name: Bob'              
</code></pre>
<p>如果要检索字段而不是调用 getter，可以使用直接字段访问运算符：</p>
<pre><code class="language-groovy">assert user.@name == 'Bob'                   
</code></pre>
<p>使用 .@ 强制使用字段而不是 getter</p>
<h2 id="method-pointer-operator"><a class="header" href="#method-pointer-operator">Method pointer operator</a></h2>
<p>方法指针运算符 (.&amp;) 可用于在变量中存储对方法的引用，以便稍后调用：</p>
<pre><code class="language-groovy">def str = 'example of method reference'            
def fun = str.&amp;toUpperCase                         
def upper = fun()                                  
assert upper == str.toUpperCase()                  
</code></pre>
<p>使用方法指针有很多优点。</p>
<p>首先，这种方法指针的类型是 groovy.lang.Closure，所以它可以用在任何需要使用闭包的地方。</p>
<p>特别适合将现有的方法转换为策略模式的需要：</p>
<pre><code class="language-groovy">def transform(List elements, Closure action) {                    
    def result = []
    elements.each {
        result &lt;&lt; action(it)
    }
    result
}
String describe(Person p) {                                       
    &quot;$p.name is $p.age&quot;
}
def action = this.&amp;describe                                       
def list = [
    new Person(name: 'Bob',   age: 42),
    new Person(name: 'Julia', age: 35)]                           
assert transform(list, action) == ['Bob is 42', 'Julia is 35']    
</code></pre>
<p><strong>方法指针由接收者和方法名绑定。</strong></p>
<p>参数是在运行时解析的，这意味着如果您有多个同名的方法，语法没有不同，只会在运行时解析要调用的适当方法：</p>
<pre><code class="language-groovy">def doSomething(String str) { str.toUpperCase() }    
def doSomething(Integer x) { 2*x }                   
def reference = this.&amp;doSomething                    
assert reference('foo') == 'FOO'                     
assert reference(123)   == 246                       
</code></pre>
<p>为了符合 Java 8 方法引用期望，在 Groovy 3 及更高版本中，您可以使用 new 作为方法名称来获取指向构造函数的方法指针：</p>
<pre><code class="language-groovy">def foo  = BigInteger.&amp;new
def fortyTwo = foo('42')
assert fortyTwo == 42G
</code></pre>
<p>同样在 Groovy 3 及更高版本中，您可以获得指向类的实例方法的方法指针。</p>
<p>此方法指针采用一个附加参数作为接收器实例来调用该方法：</p>
<pre><code class="language-groovy">def instanceMethod = String.&amp;toUpperCase
assert instanceMethod('foo') == 'FOO'
</code></pre>
<p>为了向后兼容，在这种情况下，任何碰巧具有正确调用参数的静态方法都将优先于实例方法</p>
<h2 id="method-reference-operator"><a class="header" href="#method-reference-operator">Method reference operator</a></h2>
<p>Groovy 3+ 中的 Parrot 解析器支持 Java 8+ 方法引用运算符。</p>
<p>方法引用运算符 (::) 可用于在需要函数式接口的上下文中引用方法或构造函数。</p>
<p>这与 Groovy 的方法指针运算符提供的功能有些重叠。</p>
<pre><code class="language-groovy">import groovy.transform.CompileStatic
import static java.util.stream.Collectors.toList

@CompileStatic
void methodRefs() {
    assert 6G == [1G, 2G, 3G].stream().reduce(0G, BigInteger::add)                           

    assert [4G, 5G, 6G] == [1G, 2G, 3G].stream().map(3G::add).collect(toList())              

    assert [1G, 2G, 3G] == [1L, 2L, 3L].stream().map(BigInteger::valueOf).collect(toList())  

    assert [1G, 2G, 3G] == [1L, 2L, 3L].stream().map(3G::valueOf).collect(toList())          
}

methodRefs()
</code></pre>
<p>以下脚本显示了一些突出显示各种受支持的构造函数参考案例的示例：</p>
<pre><code class="language-groovy">@CompileStatic
void constructorRefs() {
    assert [1, 2, 3] == ['1', '2', '3'].stream().map(Integer::new).collect(toList())  

    def result = [1, 2, 3].stream().toArray(Integer[]::new)                           
    assert result instanceof Integer[]
    assert result.toString() == '[1, 2, 3]'
}

constructorRefs()
</code></pre>
<h1 id="regular-expression-operators"><a class="header" href="#regular-expression-operators">Regular expression operators</a></h1>
<h2 id="pattern-operator"><a class="header" href="#pattern-operator">Pattern operator</a></h2>
<p>模式运算符 (~) 提供了一种创建 java.util.regex.Pattern 实例的简单方法：</p>
<pre><code class="language-groovy">def p = ~/foo/
assert p instanceof Pattern
</code></pre>
<p>通常，您会在斜线字符串中找到带有表达式的模式运算符，但它可以与 Groovy 中的任何类型的字符串一起使用：</p>
<pre><code class="language-groovy">p = ~'foo'                                                        
p = ~&quot;foo&quot;                                                        
p = ~$/dollar/slashy $ string/$                                   
p = ~&quot;${pattern}&quot;     
</code></pre>
<p>虽然您可以将大多数字符串形式与 Pattern、Find 和 Match 运算符一起使用，但我们建议在大多数情况下使用斜线字符串，以便不必记住其他需要的转义要求。</p>
<h2 id="find-operator"><a class="header" href="#find-operator">Find operator</a></h2>
<p>作为构建模式的替代方法，您可以使用 find 运算符 =~ 直接创建一个 java.util.regex.Matcher 实例：</p>
<pre><code class="language-groovy">def text = &quot;some text to match&quot;
def m = text =~ /match/                                           
assert m instanceof Matcher                                       
//equivalent to calling if (!m.find(0))
if (!m) {                                                         
    throw new RuntimeException(&quot;Oops, text not found!&quot;)
}
</code></pre>
<h2 id="match-operator"><a class="header" href="#match-operator">Match operator</a></h2>
<p>匹配运算符 (==~) 是查找运算符的轻微变体，它不返回匹配器而是返回布尔值，并且需要输入字符串的严格匹配：</p>
<pre><code class="language-groovy">m = text ==~ /match/                                              
assert m instanceof Boolean                                       
if (m) {                                                          
    throw new RuntimeException(&quot;Should not reach that point!&quot;)
}
</code></pre>
<h2 id="comparing-find-vs-match-operators"><a class="header" href="#comparing-find-vs-match-operators">Comparing Find vs Match operators</a></h2>
<p>通常，当模式涉及单个完全匹配时使用匹配运算符，否则查找运算符可能更有用。</p>
<pre><code class="language-groovy">assert 'two words' ==~ /\S+\s+\S+/
assert 'two words' ==~ /^\S+\s+\S+$/         
assert !(' leading space' ==~ /\S+\s+\S+/)   

def m1 = 'two words' =~ /^\S+\s+\S+$/
assert m1.size() == 1                          
def m2 = 'now three words' =~ /^\S+\s+\S+$/    
assert m2.size() == 0                          
def m3 = 'now three words' =~ /\S+\s+\S+/
assert m3.size() == 1                          
assert m3[0] == 'now three'
def m4 = ' leading space' =~ /\S+\s+\S+/
assert m4.size() == 1                          
assert m4[0] == 'leading space'
def m5 = 'and with four words' =~ /\S+\s+\S+/
assert m5.size() == 2                          
assert m5[0] == 'and with'
assert m5[1] == 'four words'
</code></pre>
<h1 id="other-operators"><a class="header" href="#other-operators">Other operators</a></h1>
<h2 id="spread-operator"><a class="header" href="#spread-operator">Spread operator</a></h2>
<p>扩展点运算符 (*.)，通常缩写为扩展运算符，用于对聚合对象的所有 item 调用操作。</p>
<p>相当于在每一项上调用action，将结果收集到一个列表中：</p>
<pre><code class="language-groovy">class Car {
    String make
    String model
}
def cars = [
       new Car(make: 'Peugeot', model: '508'),
       new Car(make: 'Renault', model: 'Clio')]       
def makes = cars*.make                                
assert makes == ['Peugeot', 'Renault']                
</code></pre>
<p>展开运算符是空安全的，这意味着如果集合的元素为空，它将返回空而不是抛出 NullPointerException：</p>
<pre><code class="language-groovy">cars = [
   new Car(make: 'Peugeot', model: '508'),
   null,                                              
   new Car(make: 'Renault', model: 'Clio')]
assert cars*.make == ['Peugeot', null, 'Renault']     
assert null*.make == null       
</code></pre>
<p>展开运算符可用于任何实现 Iterable 接口的类：</p>
<pre><code class="language-groovy">class Component {
    Long id
    String name
}
class CompositeObject implements Iterable&lt;Component&gt; {
    def components = [
        new Component(id: 1, name: 'Foo'),
        new Component(id: 2, name: 'Bar')]

    @Override
    Iterator&lt;Component&gt; iterator() {
        components.iterator()
    }
}
def composite = new CompositeObject()
assert composite*.id == [1,2]
assert composite*.name == ['Foo','Bar']
</code></pre>
<p>在处理本身包含聚合的数据结构聚合时，使用扩展点运算符的多次调用（此处为cars*.models*.name）：</p>
<pre><code class="language-groovy">class Make {
    String name
    List&lt;Model&gt; models
}

@Canonical
class Model {
    String name
}

def cars = [
    new Make(name: 'Peugeot',
             models: [new Model('408'), new Model('508')]),
    new Make(name: 'Renault',
             models: [new Model('Clio'), new Model('Captur')])
]

def makes = cars*.name
assert makes == ['Peugeot', 'Renault']

def models = cars*.models*.name
assert models == [['408', '508'], ['Clio', 'Captur']]
assert models.sum() == ['408', '508', 'Clio', 'Captur'] // flatten one level
assert models.flatten() == ['408', '508', 'Clio', 'Captur'] // flatten all levels (one in this case)
</code></pre>
<pre><code class="language-groovy">class Car {
    String make
    String model
}
def cars = [
   [
       new Car(make: 'Peugeot', model: '408'),
       new Car(make: 'Peugeot', model: '508')
   ], [
       new Car(make: 'Renault', model: 'Clio'),
       new Car(make: 'Renault', model: 'Captur')
   ]
]
def models = cars.collectNested{ it.model }
assert models == [['408', '508'], ['Clio', 'Captur']]
</code></pre>
<p><strong>Spreading method arguments</strong></p>
<p>在某些情况下，可以在列表中找到方法调用的参数，您需要适应方法参数。</p>
<p>在这种情况下，您可以使用扩展运算符来调用该方法。</p>
<pre><code class="language-groovy">int function(int x, int y, int z) {
    x*y+z
}

def args = [4,5,6]
assert function(*args) == 26

args = [4]
assert function(*args,5,6) == 26
</code></pre>
<p><strong>Spread list elements</strong></p>
<pre><code class="language-groovy">def items = [4,5]                      
def list = [1,2,3,*items,6]            
assert list == [1,2,3,4,5,6]           
</code></pre>
<p><strong>Spread map elements</strong></p>
<pre><code class="language-groovy">def m1 = [c:3, d:4]                   
def map = [a:1, b:2, *:m1]            
assert map == [a:1, b:2, c:3, d:4]    
</code></pre>
<h2 id="range-operator"><a class="header" href="#range-operator">Range operator</a></h2>
<pre><code class="language-groovy">def range = 0..5                                    
assert (0..5).collect() == [0, 1, 2, 3, 4, 5]       
assert (0..&lt;5).collect() == [0, 1, 2, 3, 4]         
assert (0..5) instanceof List                       
assert (0..5).size() == 6                           
</code></pre>
<h2 id="spaceship-operator"><a class="header" href="#spaceship-operator">Spaceship operator</a></h2>
<p>飞船运算符 (&lt;=&gt;) 委托给 compareTo 方法：</p>
<pre><code class="language-groovy">assert (1 &lt;=&gt; 1) == 0
assert (1 &lt;=&gt; 2) == -1
assert (2 &lt;=&gt; 1) == 1
assert ('a' &lt;=&gt; 'z') == -1
</code></pre>
<h2 id="subscript-operator"><a class="header" href="#subscript-operator">Subscript operator</a></h2>
<p>下标运算符是 getAt 或 putAt 的简写符号，具体取决于您是在赋值的左侧还是右侧找到它：</p>
<pre><code class="language-groovy">def list = [0,1,2,3,4]
assert list[2] == 2                         
list[2] = 4                                 
assert list[0..2] == [0,1,4]                
list[0..2] = [6,6,6]                        
assert list == [6,6,6,3,4]                  
</code></pre>
<p>下标运算符与 getAt/putAt 的自定义实现相结合是解构对象的便捷方法：</p>
<pre><code class="language-groovy">class User {
    Long id
    String name
    def getAt(int i) {                                             
        switch (i) {
            case 0: return id
            case 1: return name
        }
        throw new IllegalArgumentException(&quot;No such element $i&quot;)
    }
    void putAt(int i, def value) {                                 
        switch (i) {
            case 0: id = value; return
            case 1: name = value; return
        }
        throw new IllegalArgumentException(&quot;No such element $i&quot;)
    }
}
def user = new User(id: 1, name: 'Alex')                           
assert user[0] == 1                                                
assert user[1] == 'Alex'                                           
user[1] = 'Bob'                                                    
assert user.name == 'Bob'   
</code></pre>
<h2 id="safe-index-operator"><a class="header" href="#safe-index-operator">Safe index operator</a></h2>
<p>Groovy 3.0.0 引入了安全索引操作符，即 ?[]，类似于 ?.. 例如：</p>
<pre><code class="language-groovy">String[] array = ['a', 'b']
assert 'b' == array?[1]      // get using normal array index
array?[1] = 'c'              // set using normal array index
assert 'c' == array?[1]

array = null
assert null == array?[1]     // return null for all index values
array?[1] = 'c'              // quietly ignore attempt to set value
assert null == array?[1]

def personInfo = [name: 'Daniel.Sun', location: 'Shanghai']
assert 'Daniel.Sun' == personInfo?['name']      // get using normal map index
personInfo?['name'] = 'sunlan'                  // set using normal map index
assert 'sunlan' == personInfo?['name']

personInfo = null
assert null == personInfo?['name']              // return null for all map values
personInfo?['name'] = 'sunlan'                  // quietly ignore attempt to set value
assert null == personInfo?['name']
</code></pre>
<h2 id="membership-operator"><a class="header" href="#membership-operator">Membership operator</a></h2>
<p>成员资格运算符 (in) 等效于调用 isCase 方法。在 List 的上下文中，它相当于调用 contains，如下例所示</p>
<pre><code class="language-groovy">def list = ['Grace','Rob','Emmy']
assert ('Emmy' in list) 
</code></pre>
<p>equivalent to calling <code>list.contains('Emmy')</code> or <code>list.isCase('Emmy')</code></p>
<h2 id="identity-operator"><a class="header" href="#identity-operator">Identity operator</a></h2>
<p>在 Groovy 中，使用 == 来测试相等性与在 Java 中使用相同的运算符不同。</p>
<p>在 Groovy 中，它调用的是 equals。</p>
<p>如果你想比较引用相等，你应该像下面的例子一样使用：</p>
<pre><code class="language-groovy">def list1 = ['Groovy 1.8','Groovy 2.0','Groovy 2.3']        
def list2 = ['Groovy 1.8','Groovy 2.0','Groovy 2.3']        
assert list1 == list2                                       
assert !list1.is(list2)  
</code></pre>
<h2 id="coercion-operator"><a class="header" href="#coercion-operator">Coercion operator</a></h2>
<p>强制操作符</p>
<p>强制运算符 (as) 是强制转换的变体。</p>
<p>强制将对象从一种类型转换为另一种类型，而它们不兼容赋值。</p>
<pre><code class="language-groovy">Integer x = 123
String s = (String) x      
</code></pre>
<p>Integer 不能分配给 String，所以它会在运行时产生 ClassCastException,这可以通过使用强制来解决：</p>
<pre><code class="language-groovy">Integer x = 123
//整数不可分配给字符串，但使用 as 会将其强制为字符串
String s = x as String      
</code></pre>
<p>当一个对象被强制转换为另一个对象时，除非目标类型与源类型相同，否则强制将返回一个新对象。</p>
<p>转换规则因源和目标类型而异，如果找不到转换规则，则转换可能会失败。</p>
<p>由于 asType 方法，可以实现自定义转换规则：</p>
<pre><code class="language-groovy">class Identifiable {
    String name
}
class User {
    Long id
    String name
    def asType(Class target) {                                              
        if (target == Identifiable) {
            return new Identifiable(name: name)
        }
        throw new ClassCastException(&quot;User cannot be coerced into $target&quot;)
    }
}
def u = new User(name: 'Xavier')                                            
def p = u as Identifiable                                                   
assert p instanceof Identifiable                                            
assert !(p instanceof User)             
</code></pre>
<h2 id="diamond-operator"><a class="header" href="#diamond-operator">Diamond operator</a></h2>
<p>菱形运算符 (&lt;&gt;) 是一种语法糖运算符，用于支持与 Java 7 中同名运算符的兼容性。它用于指示应从声明中推断出泛型类型：</p>
<pre><code class="language-groovy">List&lt;String&gt; strings = new LinkedList&lt;&gt;()
</code></pre>
<p>在动态 Groovy 中，这是完全未使用的。</p>
<p>在静态类型检查的 Groovy 中，它也是可选的，因为无论该运算符是否存在，Groovy 类型检查器都会执行类型推断。</p>
<h2 id="call-operator"><a class="header" href="#call-operator">Call operator</a></h2>
<p>调用运算符 () 用于隐式调用名为 call 的方法。</p>
<p>对于定义调用方法的任何对象，您可以省略 .call 部分并使用调用运算符代替：</p>
<pre><code class="language-groovy">class MyCallable {
    int call(int x) {           
        2*x
    }
}

def mc = new MyCallable()
assert mc.call(2) == 4          
assert mc(2) == 4               
</code></pre>
<h1 id="operator-precedence"><a class="header" href="#operator-precedence">Operator precedence</a></h1>
<p>he table below lists all groovy operators in order of precedence.</p>
<table><thead><tr><th style="text-align: left">Level</th><th style="text-align: left">Operator(s)</th><th style="text-align: left">Name(s)</th></tr></thead><tbody>
<tr><td style="text-align: left">1</td><td style="text-align: left"><code>new</code>  <code>()</code></td><td style="text-align: left">object creation, explicit parentheses</td></tr>
<tr><td style="text-align: left"></td><td style="text-align: left"><code>()</code>  <code>{}</code>  <code>[]</code></td><td style="text-align: left">method call, closure, literal list/map</td></tr>
<tr><td style="text-align: left"></td><td style="text-align: left"><code>.</code>  <code>.&amp;</code>  <code>.@</code></td><td style="text-align: left">member access, method closure, field/attribute access</td></tr>
<tr><td style="text-align: left"></td><td style="text-align: left"><code>?.</code>  <code>*</code>  <code>*.</code>  <code>*:</code></td><td style="text-align: left">safe dereferencing, spread, spread-dot, spread-map</td></tr>
<tr><td style="text-align: left"></td><td style="text-align: left"><code>~</code>  <code>!</code>  <code>(type)</code></td><td style="text-align: left">bitwise negate/pattern, not, typecast</td></tr>
<tr><td style="text-align: left"></td><td style="text-align: left"><code>[]</code>  <code>?[]</code>  <code>++</code>  <code>--</code></td><td style="text-align: left">list/map/array (safe) index, post inc/decrement</td></tr>
<tr><td style="text-align: left">2</td><td style="text-align: left"><code>**</code></td><td style="text-align: left">power</td></tr>
<tr><td style="text-align: left">3</td><td style="text-align: left"><code>++</code>  <code>--</code>  <code>+</code>  <code>-</code></td><td style="text-align: left">pre inc/decrement, unary plus, unary minus</td></tr>
<tr><td style="text-align: left">4</td><td style="text-align: left"><code>*</code>  <code>/</code>  <code>%</code></td><td style="text-align: left">multiply, div, remainder</td></tr>
<tr><td style="text-align: left">5</td><td style="text-align: left"><code>+</code>  <code>-</code></td><td style="text-align: left">addition, subtraction</td></tr>
<tr><td style="text-align: left">6</td><td style="text-align: left"><code>&lt;&lt;</code>  <code>&gt;&gt;</code>  <code>&gt;&gt;&gt;</code>  <code>..</code>  <code>..&lt;</code></td><td style="text-align: left">left/right (unsigned) shift, inclusive/exclusive range</td></tr>
<tr><td style="text-align: left">7</td><td style="text-align: left"><code>&lt;</code>  <code>&lt;=</code>  <code>&gt;</code>  <code>&gt;=</code>  <code>in</code>  <code>!in</code>  <code>instanceof</code>  <code>!instanceof</code>  <code>as</code></td><td style="text-align: left">less/greater than/or equal, in, not in, instanceof, not instanceof, type coercion</td></tr>
<tr><td style="text-align: left">8</td><td style="text-align: left"><code>==</code>  <code>!=</code>  <code>&lt;=&gt;</code>  <code>===</code>  <code>!==</code></td><td style="text-align: left">equals, not equals, compare to, identical to, not identical to</td></tr>
<tr><td style="text-align: left"></td><td style="text-align: left"><code>=~</code>  <code>==~</code></td><td style="text-align: left">regex find, regex match</td></tr>
<tr><td style="text-align: left">9</td><td style="text-align: left"><code>&amp;</code></td><td style="text-align: left">binary/bitwise and</td></tr>
<tr><td style="text-align: left">10</td><td style="text-align: left"><code>^</code></td><td style="text-align: left">binary/bitwise xor</td></tr>
<tr><td style="text-align: left">11</td><td style="text-align: left">`</td><td style="text-align: left">`</td></tr>
<tr><td style="text-align: left">12</td><td style="text-align: left"><code>&amp;&amp;</code></td><td style="text-align: left">logical and</td></tr>
<tr><td style="text-align: left">13</td><td style="text-align: left">`</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">14</td><td style="text-align: left"><code>? :</code></td><td style="text-align: left">ternary conditional</td></tr>
<tr><td style="text-align: left"></td><td style="text-align: left"><code>?:</code></td><td style="text-align: left">elvis operator</td></tr>
<tr><td style="text-align: left">15</td><td style="text-align: left"><code>=</code>  <code>**=</code>  <code>*=</code>  <code>/=</code>  <code>%=</code>  <code>+=</code>  <code>-=</code>  <code>&lt;&lt;=</code>  <code>&gt;&gt;=</code>  <code>&gt;&gt;&gt;=</code>  <code>&amp;=</code>  <code>^=</code>  `</td><td style="text-align: left">=<code>   </code>?=`</td></tr>
</tbody></table>
<h1 id="operator-overloading"><a class="header" href="#operator-overloading">Operator overloading</a></h1>
<p>Groovy 允许您重载各种运算符，以便它们可以与您自己的类一起使用。</p>
<pre><code class="language-groovy">class Bucket {
    int size

    Bucket(int size) { this.size = size }

    Bucket plus(Bucket other) {                     
        return new Bucket(this.size + other.size)
    }
}
</code></pre>
<p>Just by implementing the <code>plus()</code> method, the <code>Bucket</code> class can now be used with the <code>+</code> operator like so:</p>
<pre><code class="language-groovy">def b1 = new Bucket(4)
def b2 = new Bucket(11)
assert (b1 + b2).size == 15    
</code></pre>
<p>所有（非比较器）Groovy 运算符都有相应的方法，您可以在自己的类中实现该方法。</p>
<p>唯一的要求是您的方法是公共的，具有正确的名称，并且具有正确数量的参数。</p>
<p>参数类型取决于您希望在运算符右侧支持什么类型。</p>
<p>以下是运算符及其相应方法的完整列表： </p>
<table><thead><tr><th style="text-align: left">Operator</th><th style="text-align: left">Method</th><th style="text-align: left">Operator</th><th style="text-align: left">Method</th></tr></thead><tbody>
<tr><td style="text-align: left"><code>+</code></td><td style="text-align: left">a.plus(b)</td><td style="text-align: left"><code>a[b]</code></td><td style="text-align: left">a.getAt(b)</td></tr>
<tr><td style="text-align: left"><code>-</code></td><td style="text-align: left">a.minus(b)</td><td style="text-align: left"><code>a[b] = c</code></td><td style="text-align: left">a.putAt(b, c)</td></tr>
<tr><td style="text-align: left"><code>*</code></td><td style="text-align: left">a.multiply(b)</td><td style="text-align: left"><code>a in b</code></td><td style="text-align: left">b.isCase(a)</td></tr>
<tr><td style="text-align: left"><code>/</code></td><td style="text-align: left">a.div(b)</td><td style="text-align: left"><code>&lt;&lt;</code></td><td style="text-align: left">a.leftShift(b)</td></tr>
<tr><td style="text-align: left"><code>%</code></td><td style="text-align: left">a.mod(b)</td><td style="text-align: left"><code>&gt;&gt;</code></td><td style="text-align: left">a.rightShift(b)</td></tr>
<tr><td style="text-align: left"><code>**</code></td><td style="text-align: left">a.power(b)</td><td style="text-align: left"><code>&gt;&gt;&gt;</code></td><td style="text-align: left">a.rightShiftUnsigned(b)</td></tr>
<tr><td style="text-align: left">`</td><td style="text-align: left">`</td><td style="text-align: left">a.or(b)</td><td style="text-align: left"><code>++</code></td></tr>
<tr><td style="text-align: left"><code>&amp;</code></td><td style="text-align: left">a.and(b)</td><td style="text-align: left"><code>--</code></td><td style="text-align: left">a.previous()</td></tr>
<tr><td style="text-align: left"><code>^</code></td><td style="text-align: left">a.xor(b)</td><td style="text-align: left"><code>+a</code></td><td style="text-align: left">a.positive()</td></tr>
<tr><td style="text-align: left"><code>as</code></td><td style="text-align: left">a.asType(b)</td><td style="text-align: left"><code>-a</code></td><td style="text-align: left">a.negative()</td></tr>
<tr><td style="text-align: left"><code>a()</code></td><td style="text-align: left">a.call()</td><td style="text-align: left"><code>~a</code></td><td style="text-align: left">a.bitwiseNegate()</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h1 id="package-names"><a class="header" href="#package-names">Package names</a></h1>
<p>包名与 Java 中的作用完全相同。</p>
<p>它们允许我们在没有任何冲突的情况下分离代码库。 </p>
<p>Groovy 类必须在类定义之前指定它们的包，否则假定为默认包。</p>
<pre><code class="language-groovy">// defining a package named com.yoursite
package com.yoursite
</code></pre>
<p>要引用 com.yoursite.com 包中的某个类 Foo，您需要使用完全限定名称 com.yoursite.com.Foo，否则您可以使用 import 语句，如下所示。</p>
<h1 id="imports"><a class="header" href="#imports">Imports</a></h1>
<p>为了引用任何类，您需要对其包进行限定引用。 </p>
<p>Groovy 遵循 Java 允许 import 语句解析类引用的概念</p>
<pre><code class="language-groovy">// importing the class MarkupBuilder
import groovy.xml.MarkupBuilder

// using the imported class to create an object
def xml = new MarkupBuilder()

assert xml != null
</code></pre>
<h2 id="default-imports"><a class="header" href="#default-imports">Default imports</a></h2>
<p>默认导入是 Groovy 语言默认提供的导入。</p>
<pre><code class="language-groovy">import java.lang.*
import java.util.*
import java.io.*
import java.net.*
import groovy.lang.*
import groovy.util.*
import java.math.BigInteger
import java.math.BigDecimal
</code></pre>
<p>这样做是因为这些包中的类是最常用的。通过导入这些样板代码减少了。</p>
<h2 id="simple-import"><a class="header" href="#simple-import">Simple import</a></h2>
<p>简单导入</p>
<pre><code class="language-groovy">// importing the class MarkupBuilder
import groovy.xml.MarkupBuilder

// using the imported class to create an object
def xml = new MarkupBuilder()

assert xml != null
</code></pre>
<h2 id="star-import"><a class="header" href="#star-import">Star import</a></h2>
<p>提供了一种使用 * 从包中导入所有类的特殊方法，即所谓的星形导入。</p>
<pre><code class="language-groovy">import groovy.xml.*

def markupBuilder = new MarkupBuilder()

assert markupBuilder != null

assert new StreamingMarkupBuilder() != null
</code></pre>
<h2 id="static-import"><a class="header" href="#static-import">Static import</a></h2>
<p>Groovy 的静态导入功能允许您引用导入的类，就像它们是您自己类中的静态方法一样：</p>
<pre><code class="language-groovy">import static Boolean.FALSE

assert !FALSE //use directly, without Boolean prefix!
</code></pre>
<h2 id="静态导入别名"><a class="header" href="#静态导入别名">静态导入别名</a></h2>
<p>带有 as 关键字的静态导入为命名空间问题提供了一种优雅的解决方案。</p>
<p>假设您想使用其 getInstance() 方法获取 Calendar 实例。</p>
<p>这是一个静态方法，所以我们可以使用静态导入。</p>
<pre><code class="language-groovy">import static Calendar.getInstance as now

assert now().class == Calendar.getInstance().class
</code></pre>
<h2 id="static-star-import"><a class="header" href="#static-star-import">Static star import</a></h2>
<pre><code class="language-groovy">import static java.lang.Math.*

assert sin(0) == 0.0
assert cos(0) == 1.0
</code></pre>
<h2 id="import-aliasing"><a class="header" href="#import-aliasing">Import aliasing</a></h2>
<p>导入别名</p>
<p>使用类型别名，我们可以使用我们选择的名称来引用完全限定的类名。</p>
<p>这可以像以前一样使用 as 关键字来完成。</p>
<p>例如，我们可以将 java.sql.Date 作为 SQLDate 导入并在与 java.util.Date 相同的文件中使用它，而不必使用任一类的完全限定名称：</p>
<pre><code class="language-groovy">import java.util.Date
import java.sql.Date as SQLDate

Date utilDate = new Date(1000L)
SQLDate sqlDate = new SQLDate(1000L)

assert utilDate instanceof java.util.Date
assert sqlDate instanceof java.sql.Date
</code></pre>
<h1 id="scripts-versus-classes"><a class="header" href="#scripts-versus-classes">Scripts versus classes</a></h1>
<p>脚本与类</p>
<h2 id="public-static-void-main-vs-script"><a class="header" href="#public-static-void-main-vs-script">public static void main vs script</a></h2>
<p>Groovy 支持脚本和类。</p>
<pre><code class="language-groovy">class Main {                                    
    static void main(String... args) {          
        println 'Groovy world!'                 
    }
}
</code></pre>
<p>这是您会发现来自 Java 的典型代码，其中代码必须嵌入到一个类中才能执行。 </p>
<pre><code class="language-groovy">println 'Groovy world!'
</code></pre>
<p>一个脚本可以被认为是一个类而不需要声明它，但有一些区别。</p>
<h2 id="script-class"><a class="header" href="#script-class">Script class</a></h2>
<p>脚本总是被编译成一个类。 </p>
<p>Groovy 编译器将为您编译该类，并将脚本主体复制到 run 方法中。</p>
<p>因此，前面的示例被编译为如下所示：</p>
<pre><code class="language-groovy">import org.codehaus.groovy.runtime.InvokerHelper
class Main extends Script {                     
    def run() {                                 
        println 'Groovy world!'                 
    }
    static void main(String[] args) {           
        InvokerHelper.runScript(Main, args)     
    }
}
</code></pre>
<ul>
<li>Main 类扩展了 groovy.lang.Script 类</li>
<li>groovy.lang.Script 需要一个返回值的 run 方法</li>
<li>脚本主体进入 run 方法</li>
<li>main方法是自动生成的</li>
<li>并将脚本的执行委托给 run 方法</li>
</ul>
<p>如果脚本在文件中，则使用文件的基本名称来确定生成的脚本类的名称。</p>
<p>在这个例子中，如果文件名是 Main.groovy，那么脚本类就是 Main。</p>
<h2 id="methods"><a class="header" href="#methods">Methods</a></h2>
<pre><code class="language-groovy">int fib(int n) {
    n &lt; 2 ? 1 : fib(n-1) + fib(n-2)
}
assert fib(10)==89
</code></pre>
<p>您还可以混合使用方法和代码。</p>
<p>生成的脚本类会将所有的方法携带到脚本类中，并将所有的脚本体组装到run方法中：</p>
<pre><code class="language-groovy">println 'Hello'                                 

int power(int n) { 2**n }                       

println &quot;2^6==${power(6)}&quot;                      
</code></pre>
<pre><code class="language-groovy">import org.codehaus.groovy.runtime.InvokerHelper
class Main extends Script {
    int power(int n) { 2** n}                   
    def run() {
        println 'Hello'                         
        println &quot;2^6==${power(6)}&quot;              
    }
    static void main(String[] args) {
        InvokerHelper.runScript(Main, args)
    }
}
</code></pre>
<h2 id="variables"><a class="header" href="#variables">Variables</a></h2>
<p>脚本中的变量不需要类型定义。</p>
<p>这意味着这个脚本：</p>
<pre><code class="language-groovy">int x = 1
int y = 2
assert x+y == 3
</code></pre>
<p>will behave the same as:</p>
<pre><code class="language-groovy">x = 1
y = 2
assert x+y == 3
</code></pre>
<p>但是，两者之间存在语义差异：</p>
<p>如果变量如第一个示例中那样声明，则它是局部变量。</p>
<p>它将在编译器将生成的 run 方法中声明，并且在脚本主体之外不可见。</p>
<p>特别是，这样的变量在脚本的其他方法中是不可见的</p>
<p>如果变量未声明，它会进入脚本绑定。</p>
<p>绑定从方法中可见，如果您使用脚本与应用程序交互并需要在脚本和应用程序之间共享数据，则该绑定尤其重要。</p>
<p>使变量对所有方法可见的另一种方法是使用 @Field 注释。</p>
<p>这样注解的变量会成为生成的脚本类的一个字段，对于局部变量，访问不会涉及到脚本绑定。</p>
<p>虽然不推荐，但如果您有一个与绑定变量同名的局部变量或脚本字段，您可以使用 binding.varName 来访问绑定变量。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="手册指南"><a class="header" href="#手册指南">手册指南</a></h2>
<p>[[基础类型]]
[[变量声明]]
[[模块]]</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="基础类型"><a class="header" href="#基础类型">基础类型</a></h2>
<h3 id="布尔值"><a class="header" href="#布尔值">布尔值：</a></h3>
<p>bool</p>
<h3 id="数字"><a class="header" href="#数字">数字：</a></h3>
<p>number</p>
<h3 id="字符串-1"><a class="header" href="#字符串-1">字符串：</a></h3>
<p>string</p>
<h3 id="数组-1"><a class="header" href="#数组-1">数组：</a></h3>
<p><code>let list: number[] = [1, 2, 3];</code></p>
<h3 id="元组-tuple"><a class="header" href="#元组-tuple">元组 Tuple：</a></h3>
<p><code>let x: [string, number];</code></p>
<h3 id="枚举-1"><a class="header" href="#枚举-1">枚举：</a></h3>
<p><code>enum Color {Red, Green, Blue}</code></p>
<h3 id="any"><a class="header" href="#any">Any：</a></h3>
<p><code>let list: any[] = [1, true, &quot;free&quot;];</code></p>
<h3 id="void"><a class="header" href="#void">Void</a></h3>
<p>没有任何返回值</p>
<h3 id="null-和-undefined"><a class="header" href="#null-和-undefined">Null 和 Undefined</a></h3>
<pre><code class="language-typescript">// Not much else we can assign to these variables! 
let u: undefined = undefined;
let n: null = null;
</code></pre>
<h3 id="never"><a class="header" href="#never">Never</a></h3>
<ul>
<li><code>never</code>类型表示的是那些永不存在的值的类型</li>
<li><code>never</code>类型是那些总是会抛出异常或根本就不会有返回值的函数表达式或箭头函数表达式的返回值类型；</li>
</ul>
<h3 id="object"><a class="header" href="#object">Object</a></h3>
<h2 id="类型断言"><a class="header" href="#类型断言">类型断言</a></h2>
<ul>
<li>有时候你会遇到这样的情况，你会比TypeScript更了解某个值的详细信息</li>
<li>通常这会发生在你清楚地知道一个实体具有比它现有类型更确切的类型</li>
</ul>
<pre><code class="language-ts">let strLength: number = (&lt;string&gt;someValue).length;
let strLength: number = (someValue as string).length;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="let-vsconst"><a class="header" href="#let-vsconst"><code>let</code> vs<code>const</code></a></h2>
<ul>
<li>基本原则就是如果一个变量不需要对它写入，那么其它使用这些代码的人也不能够写入它们，并且要思考为什么会需要对这些变量重新赋值</li>
<li>使用 <code>const</code>也可以让我们更容易的推测数据的流动。</li>
</ul>
<h2 id="解构"><a class="header" href="#解构">解构</a></h2>
<h3 id="解构数组"><a class="header" href="#解构数组">解构数组</a></h3>
<pre><code class="language-typescript">let input = [1, 2];
let [first, second] = input;
</code></pre>
<h3 id="解构作用于已声明的变量"><a class="header" href="#解构作用于已声明的变量">解构作用于已声明的变量</a></h3>
<pre><code class="language-typescript">// swap variables 
[first, second] = [second, first];
</code></pre>
<h3 id="函数参数-3"><a class="header" href="#函数参数-3">函数参数</a></h3>
<pre><code class="language-typescript">
function f([first, second]: [number, number]) { 
	console.log(first); 
	console.log(second); 
} 

f(input);
</code></pre>
<h3 id="使用语法创建剩余变量"><a class="header" href="#使用语法创建剩余变量">使用<code>...</code>语法创建剩余变量</a></h3>
<pre><code class="language-typescript">let [first, ...rest] = [1, 2, 3, 4]; 
console.log(first); // outputs 1 
console.log(rest); // outputs [ 2, 3, 4 ]
</code></pre>
<h3 id="数组-first元素"><a class="header" href="#数组-first元素">数组 first元素</a></h3>
<pre><code class="language-ts">let [first] = [1, 2, 3, 4]; 
console.log(first); // outputs 1
let [, second, , fourth] = [1, 2, 3, 4];
</code></pre>
<h2 id="对象解构"><a class="header" href="#对象解构">对象解构</a></h2>
<pre><code class="language-ts">	let o = { a: &quot;foo&quot;, b: 12, c: &quot;bar&quot; }; 
	let { a, b } = o;
</code></pre>
<h3 id="属性重命名"><a class="header" href="#属性重命名">属性重命名</a></h3>
<pre><code class="language-ts">let newName2 = o.b;
</code></pre>
<h3 id="默认值"><a class="header" href="#默认值">默认值</a></h3>
<p>默认值可以让你在属性为 undefined 时使用缺省值：</p>
<pre><code class="language-ts">function keepWholeObject(wholeObject: { a: string, b?: number }) 
{ 
	let { a, b = 1001 } = wholeObject; 
}
</code></pre>
<h3 id="函数声明-1"><a class="header" href="#函数声明-1">函数声明</a></h3>
<p>解构也能用于函数声明</p>
<pre><code class="language-ts">type C = { a: string, b?: number } 
function f({ a, b }: C): void 
{ 
	// ... 
}
</code></pre>
<pre><code class="language-ts">function f({ a=&quot;&quot;, b=0 } = {}): void { 
	// ... 
} f();
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="接口"><a class="header" href="#接口">接口</a></h2>
<p><strong>介绍</strong></p>
<p>TypeScript的核心原则之一是对值所具有的结构进行类型检查。 它有时被称做“鸭式辨型法”或“结构性子类型化”。 在TypeScript里，接口的作用就是为这些类型命名和为你的代码或第三方代码定义契约。</p>
<h2 id="接口初探"><a class="header" href="#接口初探">接口初探</a></h2>
<p>下面通过一个简单示例来观察接口是如何工作的：</p>
<pre><code class="language-typescript">function printLabel(labelledObj: { label: string }) {
  console.log(labelledObj.label);
}

let myObj = { size: 10, label: &quot;Size 10 Object&quot; };
printLabel(myObj);
</code></pre>
<pre><code class="language-typescript">interface LabelledValue {
  label: string;
}

function printLabel(labelledObj: LabelledValue) {
  console.log(labelledObj.label);
}

let myObj = {size: 10, label: &quot;Size 10 Object&quot;};
printLabel(myObj);
</code></pre>
<h2 id="可选属性"><a class="header" href="#可选属性">可选属性</a></h2>
<p>接口里的属性不全都是必需的。 有些是只在某些条件下存在，或者根本不存在。 可选属性在应用“option bags”模式时很常用，即给函数传入的参数对象中只有部分属性赋值了。</p>
<pre><code class="language-typescript">interface SquareConfig {
  color?: string;
  width?: number;
}

function createSquare(config: SquareConfig): {color: string; area: number} {
  let newSquare = {color: &quot;white&quot;, area: 100};
  if (config.color) {
    newSquare.color = config.color;
  }
  if (config.width) {
    newSquare.area = config.width * config.width;
  }
  return newSquare;
}

let mySquare = createSquare({color: &quot;black&quot;});
</code></pre>
<p>带有可选属性的接口与普通的接口定义差不多**，只是在可选属性名字定义的后面加一个<code>?</code>符号**。</p>
<p>可选属性的</p>
<ul>
<li>
<p>好处之一是可以对可能存在的属性进行预定义，</p>
</li>
<li>
<p>好处之二是可以捕获引用了不存在的属性时的错误。 比如，我们故意将 <code>createSquare</code>里的<code>color</code>属性名拼错，就会得到一个错误提示：</p>
</li>
</ul>
<h2 id="只读属性"><a class="header" href="#只读属性">只读属性</a></h2>
<p>一些对象属性只能在对象刚刚创建的时候修改其值。 你可以在<strong>属性名前用 <code>readonly</code>来指定只读属性:</strong></p>
<pre><code class="language-typescript">interface Point {
    readonly x: number;
    readonly y: number;
}
</code></pre>
<p>你可以通过赋值一个对象字面量来构造一个<code>Point</code>。 赋值后， <code>x</code>和<code>y</code>再也不能被改变了。</p>
<pre><code class="language-ts">let p1: Point = { x: 10, y: 20 };
p1.x = 5; // error!
</code></pre>
<p>TypeScript具有<code>ReadonlyArray&lt;T&gt;</code>类型，它与<code>Array&lt;T&gt;</code>相似，只是把所有可变方法去掉了，因此可以确保数组创建后再也不能被修改：</p>
<pre><code class="language-ts">let a: number[] = [1, 2, 3, 4];
let ro: ReadonlyArray&lt;number&gt; = a;
ro[0] = 12; // error!
ro.push(5); // error!
ro.length = 100; // error!
a = ro; // error!
</code></pre>
<p>上面代码的最后一行，可以看到就算把整个<code>ReadonlyArray</code>赋值到一个普通数组也是不可以的。 但是你可以用类型断言重写：</p>
<pre><code class="language-ts">a = ro as number[];
</code></pre>
<p>最简单判断该用<code>readonly</code>还是<code>const</code>的方法是看要把它做为变量使用还是做为一个属性。 做为变量使用的话用 <code>const</code>，若做为属性则使用<code>readonly</code>。</p>
<h2 id="额外的属性检查"><a class="header" href="#额外的属性检查">额外的属性检查</a></h2>
<p>对于传入 接口中不存在的属性名则 会编译报错</p>
<p>绕开这些检查非常简单。 最简便的方法是使用类型断言：</p>
<pre><code class="language-ts">let mySquare = createSquare({ width: 100, opacity: 0.5 } as SquareConfig);
</code></pre>
<p>然而，最佳的方式是能够添加一个字符串索引签名，前提是你能够确定这个对象可能具有某些做为特殊用途使用的额外属性。 如果 <code>SquareConfig</code>带有上面定义的类型的<code>color</code>和<code>width</code>属性，并且<em>还会</em>带有任意数量的其它属性，那么我们可以这样定义它：</p>
<pre><code class="language-ts">interface SquareConfig {
    color?: string;
    width?: number;
    [propName: string]: any;
}
</code></pre>
<p>还有最后一种跳过这些检查的方式，这可能会让你感到惊讶，它就是将这个对象赋值给一个另一个变量： 因为 <code>squareOptions</code>不会经过额外属性检查，所以编译器不会报错。</p>
<pre><code class="language-ts">let squareOptions = { colour: &quot;red&quot;, width: 100 };
let mySquare = createSquare(squareOptions); //被强制类型转换
</code></pre>
<h2 id="函数类型"><a class="header" href="#函数类型">函数类型</a></h2>
<p>接口能够描述JavaScript中对象拥有的各种各样的外形。 </p>
<p>除了描述带有属性的普通对象外，接口也可以描述函数类型。</p>
<p>为了使用接口表示函数类型，我们需要给接口定义一个调用签名。 它就像是一个只有参数列表和返回值类型的函数定义。参数列表里的每个参数都需要名字和类型。</p>
<pre><code class="language-ts">interface SearchFunc {
  (source: string, subString: string): boolean;
}
</code></pre>
<p>这样定义后，我们可以像使用其它接口一样使用这个函数类型的接口。 下例展示了如何创建一个函数类型的变量，并将一个同类型的函数赋值给这个变量。</p>
<pre><code class="language-ts">let mySearch: SearchFunc;
mySearch = function(source: string, subString: string) {
  let result = source.search(subString);
  return result &gt; -1;
}
</code></pre>
<p>函数的参数会逐个进行检查，要求对应位置上的参数类型是兼容的。 如果你不想指定类型，TypeScript的类型系统会推断出参数类型，因为函数直接赋值给了 <code>SearchFunc</code>类型变量。 函数的返回值类型是通过其返回值推断出来的（此例是 <code>false</code>和<code>true</code>）。 如果让这个函数返回数字或字符串，类型检查器会警告我们函数的返回值类型与 <code>SearchFunc</code>接口中的定义不匹配。</p>
<pre><code class="language-ts">let mySearch: SearchFunc;
mySearch = function(src, sub) {
    let result = src.search(sub);
    return result &gt; -1;
}
</code></pre>
<h1 id="可索引的类型"><a class="header" href="#可索引的类型">可索引的类型</a></h1>
<p>与使用接口描述函数类型差不多，我们也可以描述那些能够“通过索引得到”的类型，比如<code>a[10]</code>或<code>ageMap[&quot;daniel&quot;]</code>。 可索引类型具有一个 <em>索引签名</em>，它描述了对象索引的类型，还有相应的索引返回值类型。 让我们看一个例子：</p>
<pre><code class="language-ts">interface StringArray {
  [index: number]: string;
}

let myArray: StringArray;
myArray = [&quot;Bob&quot;, &quot;Fred&quot;];

let myStr: string = myArray[0];
</code></pre>
<p>上面例子里，我们定义了<code>StringArray</code>接口，它具有索引签名。 这个索引签名表示了当用 <code>number</code>去索引<code>StringArray</code>时会得到<code>string</code>类型的返回值。</p>
<p>TypeScript支持两种索引签名：字符串和数字。 可以同时使用两种类型的索引，但是数字索引的返回值必须是字符串索引返回值类型的子类型。</p>
<p>这是因为当使用 <code>number</code>来索引时，JavaScript会将它转换成<code>string</code>然后再去索引对象。 也就是说用 <code>100</code>（一个<code>number</code>）去索引等同于使用<code>&quot;100&quot;</code>（一个<code>string</code>）去索引，因此两者需要保持一致。</p>
<pre><code class="language-ts">class Animal {
    name: string;
}
class Dog extends Animal {
    breed: string;
}

// 错误：使用数值型的字符串索引，有时会得到完全不同的Animal!
interface NotOkay {
    [x: number]: Animal;
    [x: string]: Dog;
}
</code></pre>
<p>字符串索引签名能够很好的描述<code>dictionary</code>模式，并且它们也会确保所有属性与其返回值类型相匹配。 因为字符串索引声明了 <code>obj.property</code>和<code>obj[&quot;property&quot;]</code>两种形式都可以。 下面的例子里， <code>name</code>的类型与字符串索引类型不匹配，所以类型检查器给出一个错误提示：</p>
<pre><code class="language-ts">interface NumberDictionary {
  [index: string]: number;
  length: number;    // 可以，length是number类型
  name: string       // 错误，`name`的类型与索引类型返回值的类型不匹配
}
</code></pre>
<p>最后，你可以将索引签名设置为只读，这样就防止了给索引赋值：</p>
<pre><code class="language-ts">interface ReadonlyStringArray {
    readonly [index: number]: string;
}
let myArray: ReadonlyStringArray = [&quot;Alice&quot;, &quot;Bob&quot;];
myArray[2] = &quot;Mallory&quot;; // error!
</code></pre>
<h2 id="类类型"><a class="header" href="#类类型">类类型</a></h2>
<h3 id="实现接口"><a class="header" href="#实现接口">实现接口</a></h3>
<p>接口描述了类的公共部分，而不是公共和私有两部分。 它不会帮你检查类是否具有某些私有成员。</p>
<p><strong>类静态部分与实例部分的区别</strong></p>
<p>当你操作类和接口的时候，你要知道类是具有两个类型的：静态部分的类型和实例的类型。 你会注意到，当你用构造器签名去定义一个接口并试图定义一个类去实现这个接口时会得到一个错误：</p>
<pre><code class="language-ts">interface ClockConstructor {
    new (hour: number, minute: number);
}

class Clock implements ClockConstructor {
    currentTime: Date;
    constructor(h: number, m: number) { }
}
</code></pre>
<p>这里因为当一个类实现了一个接口时，只对其实例部分进行类型检查。 constructor存在于类的静态部分，所以不在检查的范围内。</p>
<p>因此，我们应该直接操作类的静态部分。 看下面的例子，我们定义了两个接口， <code>ClockConstructor</code>为构造函数所用和<code>ClockInterface</code>为实例方法所用。 为了方便我们定义一个构造函数 <code>createClock</code>，它用传入的类型创建实例。</p>
<pre><code class="language-ts">interface ClockConstructor {
    new (hour: number, minute: number): ClockInterface;
}
interface ClockInterface {
    tick();
}

function createClock(ctor: ClockConstructor, hour: number, minute: number): ClockInterface {
    return new ctor(hour, minute);
}

class DigitalClock implements ClockInterface {
    constructor(h: number, m: number) { }
    tick() {
        console.log(&quot;beep beep&quot;);
    }
}
class AnalogClock implements ClockInterface {
    constructor(h: number, m: number) { }
    tick() {
        console.log(&quot;tick tock&quot;);
    }
}

let digital = createClock(DigitalClock, 12, 17);
let analog = createClock(AnalogClock, 7, 32);
</code></pre>
<h3 id="继承接口"><a class="header" href="#继承接口">继承接口</a></h3>
<p>和类一样，接口也可以相互继承。 这让我们能够从一个接口里复制成员到另一个接口里，可以更灵活地将接口分割到可重用的模块里。</p>
<pre><code class="language-ts">interface Shape {
    color: string;
}

interface Square extends Shape {
    sideLength: number;
}

let square = &lt;Square&gt;{};
square.color = &quot;blue&quot;;
square.sideLength = 10;
</code></pre>
<p>一个接口可以继承多个接口，创建出多个接口的合成接口。</p>
<pre><code class="language-ts">interface Shape {
    color: string;
}

interface PenStroke {
    penWidth: number;
}

interface Square extends Shape, PenStroke {
    sideLength: number;
}

let square = &lt;Square&gt;{};
square.color = &quot;blue&quot;;
square.sideLength = 10;
square.penWidth = 5.0;
</code></pre>
<h3 id="混合类型"><a class="header" href="#混合类型">混合类型</a></h3>
<p>先前我们提过，接口能够描述JavaScript里丰富的类型。 因为JavaScript其动态灵活的特点，有时你会希望一个对象可以同时具有上面提到的多种类型。</p>
<p>一个例子就是，一个对象可以同时做为函数和对象使用，并带有额外的属性。</p>
<pre><code class="language-ts">interface Counter {
    (start: number): string;
    interval: number;
    reset(): void;
}

function getCounter(): Counter {
    let counter = &lt;Counter&gt;function (start: number) { };
    counter.interval = 123;
    counter.reset = function () { };
    return counter;
}

let c = getCounter();
c(10);
c.reset();
c.interval = 5.0;
</code></pre>
<h3 id="接口继承类"><a class="header" href="#接口继承类">接口继承类</a></h3>
<p>当接口继承了一个类类型时**，它会继承类的成员但不包括其实现**</p>
<p>就好像接口声明了所有类中存在的成员，但并没有提供具体实现一样</p>
<p>接口同样会继承到类的private和protected成员。 这意味着当你创建了一个接口继承了一个拥有私有或受保护的成员的类时，这个接口类型只能被这个类或其子类所实现（implement）。</p>
<pre><code class="language-ts">class Control {
    private state: any;
}

interface SelectableControl extends Control {
    select(): void;
}

class Button extends Control implements SelectableControl {
    select() { }
}

class TextBox extends Control {
    select() { }
}

// 错误：“Image”类型缺少“state”属性。
class Image implements SelectableControl {
    select() { }
}

class Location {

}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="说明"><a class="header" href="#说明">说明</a></h2>
<p>从ES2015开始，JavaScript里增加了 模块的概念，即在模块中申明的变量、函数、类都对外部不可见，除非显示 <em>export</em>  。并且在 需要使用该模块的位置需要显示 <em>import</em>它</p>
<h2 id="how-javascript-modules-are-defined"><a class="header" href="#how-javascript-modules-are-defined">How JavaScript Modules are Defined</a></h2>
<blockquote>
<p>javascipt 模组 是如何定义的</p>
</blockquote>
<p>任何包含 顶层级 <em>import</em> <em>export</em> 的文件会 被认为是一个模块，反之，则其中的声明的作用域为全局作用域
模块在自己的作用域执行，而不是全局作用域</p>
<h2 id="non-modules"><a class="header" href="#non-modules">Non-modules</a></h2>
<p>The JavaScript specification  规则：任何 没有 top-level-export-await 应当被当做一个 script而不是 一个模块</p>
<p>在 一个script file 当中的变量、类型 是声明在全局作用域中的。
要么使用   <a href="https://www.typescriptlang.org/tsconfig#outFile"><code>outFile</code></a> 编译选项将所有文件编译在一起。或者 使用 html script 标签</p>
<h2 id="导出声明"><a class="header" href="#导出声明">导出声明</a></h2>
<p>任何申明都可以通过 export 导出
<strong>导出语法</strong></p>
<pre><code>export Syantax1=export &lt;declation&gt;
delclation=变量声明|函数声明|类声明|类型别名声明|接口声明

export Syantax2=export {
	identifier[,identifier]*
}
identifier=变量|函数|类|类型|接口

//重导出
reexport Syantax==export { Identifier1 as Identifier2 } | * from './path'
</code></pre>
<h2 id="导入声明"><a class="header" href="#导入声明">导入声明</a></h2>
<pre><code>import {identifier+} from 'module-name';

//导入重命名
import { Identifier1 as Identifier2  } from &quot;./path&quot;;


// 具有副作用的导入模块
import &quot;./my-module.js&quot;;
</code></pre>
<h2 id="默认导出导入"><a class="header" href="#默认导出导入">默认导出导入</a></h2>
<p><strong>语法</strong></p>
<pre><code class="language-ts">syntax=export default Identifier;
Identifier=class|types|interfeaces|variables
</code></pre>
<p><strong>example</strong></p>
<pre><code class="language-ts">declare let $: JQuery; 
export default $;
</code></pre>
<h2 id="export--和-import--require"><a class="header" href="#export--和-import--require"><code>export =</code> 和 <code>import = require()</code></a></h2>
<blockquote>
<p>为了支持CommonJS和AMD的<code>exports</code>, TypeScript提供了<code>export =</code>语法。</p>
</blockquote>
<p>若使用<code>export =</code>导出一个模块，则必须使用TypeScript的特定语法<code>import module = require(&quot;module&quot;)</code>来导入此模块。</p>
<p><strong>export</strong></p>
<pre><code class="language-ts">let numberRegexp = /^[0-9]+$/; 
class ZipCodeValidator
{ 
	isAcceptable(s: string)
	{ 
	return s.length === 5 &amp;&amp; numberRegexp.test(s); } 
	} export = ZipCodeValidator;


</code></pre>
<p><strong>import</strong></p>
<pre><code class="language-ts">import zip = require(&quot;./ZipCodeValidator&quot;);

</code></pre>
<h2 id="生成模块代码"><a class="header" href="#生成模块代码">生成模块代码</a></h2>
<p>下面的例子说明了导入导出语句里使用的名字是怎么转换为相应的模块加载器代码的。</p>
<h3 id="amd--requirejs"><a class="header" href="#amd--requirejs">AMD / RequireJS</a></h3>
<pre><code class="language-ts">//SimpleModule.ts
import m = require(&quot;mod&quot;);
export let t = m.something + 1;


//generator code
define([&quot;require&quot;, &quot;exports&quot;, &quot;./mod&quot;], 
   function (require, exports, mod_1) { 
		exports.t = mod_1.something + 1; 
	}
);
</code></pre>
<h3 id="commonjs--node"><a class="header" href="#commonjs--node">CommonJS / Node</a></h3>
<pre><code class="language-ts">let mod_1 = require(&quot;./mod&quot;);
exports.t = mod_1.something + 1;

</code></pre>
<h3 id="umd"><a class="header" href="#umd">UMD</a></h3>
<pre><code class="language-js">//generator code
(function (factory) {

 if (typeof module === &quot;object&quot; &amp;&amp; typeof module.exports === &quot;object&quot;) {

	 let v = factory(require, exports);
	 if (v !== undefined) module.exports = v;

 }

 else if (typeof define === &quot;function&quot; &amp;&amp; define.amd) {

 define([&quot;require&quot;, &quot;exports&quot;, &quot;./mod&quot;], factory);

 }})(function (require, exports) {

 let mod_1 = require(&quot;./mod&quot;);

 exports.t = mod_1.something + 1;

});

</code></pre>
<h3 id="system"><a class="header" href="#system">System</a></h3>
<pre><code class="language-ts">System.register([&quot;./mod&quot;], function(exports_1) {

 let mod_1;

 let t;

 return {

 setters:[

 function (mod_1_1) {

 mod_1 = mod_1_1;

 }],

 execute: function() {

	 exports_1(&quot;t&quot;, t = mod_1.something + 1);

	 }
 }

});
</code></pre>
<h3 id="native-ecmascript-2015-modules"><a class="header" href="#native-ecmascript-2015-modules">Native ECMAScript 2015 modules</a></h3>
<pre><code class="language-ts">import { something } from &quot;./mod&quot;; 
export let t = something + 1;
</code></pre>
<h3 id="外部模块"><a class="header" href="#外部模块">外部模块</a></h3>
<pre><code class="language-ts">declare module &quot;url&quot; {

 export interface Url {

 protocol?: string;

 hostname?: string;

 pathname?: string;

 }


 export function parse(urlStr: string, parseQueryString?, slashesDenoteHost?): Url;

}

declare module &quot;path&quot; {

 export function normalize(p: string): string;

 export function join(...paths: any[]): string;

 export let sep: string;

}

</code></pre>
<p><strong>外部模块简写</strong>
<code>declare module &quot;hot-new-module&quot;;</code></p>
<p>简写模块里所有导出的类型将是<code>any</code></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="installation"><a class="header" href="#installation">Installation</a></h1>
<pre><code class="language-shell">yarn add --dev jest typescript ts-jest @types/jest
</code></pre>
<h3 id="jest-config-file"><a class="header" href="#jest-config-file"><a href="https://kulshekhar.github.io/ts-jest/docs/getting-started/installation#jest-config-file">Jest config file</a></a></h3>
<h4 id="creating"><a class="header" href="#creating">Creating</a></h4>
<p>默认情况下，Jest可以在没有任何配置文件的情况下运行，但不会编译.ts文件。为了使它与ts-jest转换TypeScript，我们将需要创建一个配置文件，该文件将告诉Jest使用ts-jest预设。</p>
<p><code>ts-jest</code> can create the configuration file for you automatically:</p>
<pre><code class="language-sh">yarn ts-jest config:init
</code></pre>
<p>这将创建一个基本的Jest配置文件，该文件将通知Jest如何处理.ts文件正确。</p>
<p>您还可以使用<code>jest -- init</code>命令 (根据您使用的内容，以npx或yarn为前缀) 来提供更多与Jest相关的选项。</p>
<p>但是，对于有关是否启用TypeScript的Jtest问题，请回答 “否”。</p>
<p>相反，在之后的jest.config.js文件中添加一行，预设: <code>ts-jest</code></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="expect"><a class="header" href="#expect">Expect</a></h1>
<p>在编写测试时，通常需要检查值是否满足某些条件。expect使您可以访问许多 “matchers”，使您可以验证不同的内容。</p>
<h2 id="expectvalue"><a class="header" href="#expectvalue">expect(value)</a></h2>
<ol>
<li>
<p>每次要测试值时都会使用expect函数。很少 expect  值 本身</p>
</li>
<li>
<p>相反，您将使用expect和 “matcher” 函数来断言某个值。</p>
</li>
<li>
<p>用一个例子来理解这一点更容易。假设你有一个方法bestroixflavor () 应该返回字符串 'grapefruit'。以下是你将如何测试:</p>
</li>
</ol>
<pre><code class="language-typescript">test('the best flavor is grapefruit', () =&gt; {
  expect(bestLaCroixFlavor()).toBe('grapefruit');
});
</code></pre>
<p>在这种情况下，toBe是matcher function。下面记录了许多不同的匹配器功能，以帮助您测试不同的东西。
期望的参数应该是您的代码产生的值，并且匹配器的任何参数都应该是正确的值。</p>
<h2 id="expectextendmatchers"><a class="header" href="#expectextendmatchers">expect.extend(matchers)</a></h2>
<p>使用<em>expect.extend</em> 扩展自己的matchers到Jest。</p>
<p>例如，假设您正在测试数字实用程序库，并且经常断言数字出现在其他数字的特定范围内。你可以把它抽象成一个toBeWithinRange匹配器:</p>
<pre><code class="language-typescript">expect.extend({
  toBeWithinRange(received, floor, ceiling) {
    const pass = received &gt;= floor &amp;&amp; received &lt;= ceiling;
    if (pass) {
      return {
        message: () =&gt;
          `expected ${received} not to be within range ${floor} - ${ceiling}`,
        pass: true,
      };
    } else {
      return {
        message: () =&gt;
          `expected ${received} to be within range ${floor} - ${ceiling}`,
        pass: false,
      };
    }
  },
});

test('numeric ranges', () =&gt; {
  expect(100).toBeWithinRange(90, 110);
  expect(101).not.toBeWithinRange(0, 100);
  expect({apples: 6, bananas: 3}).toEqual({
    apples: expect.toBeWithinRange(1, 10),
    bananas: expect.not.toBeWithinRange(11, 20),
  });
});
</code></pre>
<p>注意: 在TypeScript中，例如使用 @ types/jest时，您可以在导入的模块中声明新的toBeWithinRange匹配器，如下所示:</p>
<pre><code class="language-typescript">interface CustomMatchers&lt;R = unknown&gt; {
  toBeWithinRange(floor: number, ceiling: number): R;
}

declare global {
  namespace jest {
    interface Expect extends CustomMatchers {}
    interface Matchers&lt;R&gt; extends CustomMatchers&lt;R&gt; {}
    interface InverseAsymmetricMatchers extends CustomMatchers {}
  }
}
</code></pre>
<h2 id="expectanything"><a class="header" href="#expectanything">expect.anything()</a></h2>
<p><code>expect.anything()</code> 除了 null或者 undefine其他都匹配</p>
<p>You can use it inside <code>toEqual</code> or <code>toBeCalledWith</code> instead of a literal value. </p>
<p>一般在  <code>toEqual</code> or <code>toBeCalledWith</code> 内部使用 </p>
<pre><code class="language-typescript">test('map calls its argument with a non-null argument', () =&gt; {
  const mock = jest.fn();
  [1].map(x =&gt; mock(x));
  expect(mock).toBeCalledWith(expect.anything());
});
</code></pre>
<h2 id="expectanyconstructor"><a class="header" href="#expectanyconstructor">expect.any(constructor)</a></h2>
<p><code>expect.any(constructor)</code> matches anything that was created with the given constructor or if it's a primitive that is of the passed type. You can use it inside <code>toEqual</code> or <code>toBeCalledWith</code> instead of a literal value. For example, if you want to check that a mock function is called with a number:</p>
<pre><code class="language-python">class Cat {}
function getCat(fn) {
  return fn(new Cat());
}

test('randocall calls its callback with a class instance', () =&gt; {
  const mock = jest.fn();
  getCat(mock);
  expect(mock).toBeCalledWith(expect.any(Cat));
});

function randocall(fn) {
  return fn(Math.floor(Math.random() * 6 + 1));
}

test('randocall calls its callback with a number', () =&gt; {
  const mock = jest.fn();
  randocall(mock);
  expect(mock).toBeCalledWith(expect.any(Number));
});
</code></pre>
<h2 id="expectarraycontainingarray"><a class="header" href="#expectarraycontainingarray">expect.arrayContaining(array)</a></h2>
<p><code>expect.arrayContaining(array)</code> 匹配数组元素</p>
<p>即 期望的数组必须是 返回数组的子集 </p>
<pre><code class="language-typescript">describe('arrayContaining', () =&gt; {
  const expected = ['Alice', 'Bob'];
  it('matches even if received contains additional elements', () =&gt; {
    expect(['Alice', 'Bob', 'Eve']).toEqual(expect.arrayContaining(expected));
  });
  it('does not match if received does not contain expected elements', () =&gt; {
    expect(['Bob', 'Eve']).not.toEqual(expect.arrayContaining(expected));
  });
});
</code></pre>
<pre><code class="language-typescript">describe('Beware of a misunderstanding! A sequence of dice rolls', () =&gt; {
  const expected = [1, 2, 3, 4, 5, 6];
  it('matches even with an unexpected number 7', () =&gt; {
    expect([4, 1, 6, 7, 3, 5, 2, 5, 4, 6]).toEqual(
      expect.arrayContaining(expected),
    );
  });
  it('does not match without an expected number 2', () =&gt; {
    expect([4, 1, 6, 7, 3, 5, 7, 5, 4, 6]).not.toEqual(
      expect.arrayContaining(expected),
    );
  });
});
</code></pre>
<h2 id="expectassertionsnumber"><a class="header" href="#expectassertionsnumber">expect.assertions(number)</a></h2>
<p><code>expect.assertions(number)</code> </p>
<p>验证在测试过程中调用了一定数量的断言，这在测试异步代码很有用，以确保回调中的断言实际上被调用了</p>
<p>例如， 有两个 异步 函数 callback1 callback2，它将以未知顺序异步调用它们。我们可以用:</p>
<pre><code class="language-js">test('doAsync calls both callbacks', () =&gt; {
  expect.assertions(2);
  function callback1(data) {
    expect(data).toBeTruthy();
  }
  function callback2(data) {
    expect(data).toBeTruthy();
  }

  doAsync(callback1, callback2);
});
</code></pre>
<p>The <code>expect.assertions(2)</code> call ensures that both callbacks actually get called.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="globals"><a class="header" href="#globals">Globals</a></h1>
<p>在您的测试文件中，Jest将这些方法和对象中的每一个都放入全局环境中。您不必要求或导入任何东西即可使用它们。但是，如果您更喜欢显式导入，则可以从 “@ jest/globals” 中  	<code>import {describe, expect, test} from '@jest/globals'</code>。</p>
<h2 id="afterallfn-timeout"><a class="header" href="#afterallfn-timeout"><a href="https://jestjs.io/docs/api#afterallfn-timeout"><code>afterAll(fn, timeout)</code></a></a></h2>
<ul>
<li>
<p>在此文件中的所有测试完成后运行一个函数。如果函数返回 <code>Promise</code> 或是<code>generator</code>，则Jest等待该承诺解决后再继续。</p>
</li>
<li>
<p>您可以提供一个超时时间 (以毫秒为单位)，用于指定在中止之前等待多长时间。注意: 默认超时时间为5秒。
如果要清理跨测试共享的某些全局设置状态，这通常很有用。</p>
</li>
</ul>
<pre><code class="language-typescript">const globalDatabase = makeGlobalDatabase();

function cleanUpDatabase(db) {
  db.cleanUp();
}

afterAll(() =&gt; {
  cleanUpDatabase(globalDatabase);
});

test('can find things', () =&gt; {
  return globalDatabase.find('thing', {}, results =&gt; {
    expect(results.length).toBeGreaterThan(0);
  });
});

test('can insert a thing', () =&gt; {
  return globalDatabase.insert('thing', makeThing(), response =&gt; {
    expect(response.success).toBeTruthy();
  });
});
</code></pre>
<h2 id="aftereachfn-timeout"><a class="header" href="#aftereachfn-timeout"><a href="https://jestjs.io/docs/api#aftereachfn-timeout"><code>afterEach(fn, timeout)</code></a></a></h2>
<p>当每一个test结束时 执行的动作</p>
<pre><code class="language-typescript">const globalDatabase = makeGlobalDatabase();

function cleanUpDatabase(db) {
  db.cleanUp();
}

afterEach(() =&gt; {
  cleanUpDatabase(globalDatabase);
});

test('can find things', () =&gt; {
  return globalDatabase.find('thing', {}, results =&gt; {
    expect(results.length).toBeGreaterThan(0);
  });
});

test('can insert a thing', () =&gt; {
  return globalDatabase.insert('thing', makeThing(), response =&gt; {
    expect(response.success).toBeTruthy();
  });
});
</code></pre>
<h2 id="beforeallfn-timeout"><a class="header" href="#beforeallfn-timeout"><a href="https://jestjs.io/docs/api#beforeallfn-timeout"><code>beforeAll(fn, timeout)</code></a></a></h2>
<p>所有test文件执行前执行</p>
<pre><code class="language-typescript">const globalDatabase = makeGlobalDatabase();

beforeAll(() =&gt; {
  // Clears the database and adds some testing data.
  // Jest will wait for this promise to resolve before running tests.
  return globalDatabase.clear().then(() =&gt; {
    return globalDatabase.insert({testData: 'foo'});
  });
});

// Since we only set up the database once in this example, it's important
// that our tests don't modify it.
test('can find things', () =&gt; {
  return globalDatabase.find('thing', {}, results =&gt; {
    expect(results.length).toBeGreaterThan(0);
  });
});
</code></pre>
<h2 id="beforeeachfn-timeout"><a class="header" href="#beforeeachfn-timeout"><a href="https://jestjs.io/docs/api#beforeeachfn-timeout"><code>beforeEach(fn, timeout)</code></a></a></h2>
<p>在每个测试任务运行前执行</p>
<pre><code class="language-typescript">const globalDatabase = makeGlobalDatabase();

beforeEach(() =&gt; {
  // Clears the database and adds some testing data.
  // Jest will wait for this promise to resolve before running tests.
  return globalDatabase.clear().then(() =&gt; {
    return globalDatabase.insert({testData: 'foo'});
  });
});

test('can find things', () =&gt; {
  return globalDatabase.find('thing', {}, results =&gt; {
    expect(results.length).toBeGreaterThan(0);
  });
});

test('can insert a thing', () =&gt; {
  return globalDatabase.insert('thing', makeThing(), response =&gt; {
    expect(response.success).toBeTruthy();
  });
});
</code></pre>
<h2 id="describename-fn"><a class="header" href="#describename-fn"><a href="https://jestjs.io/docs/api#describename-fn"><code>describe(name, fn)</code></a></a></h2>
<p>创建一个块，该块将几个相关测试分组在一起。</p>
<pre><code class="language-python">const myBeverage = {
  delicious: true,
  sour: false,
};

describe('my beverage', () =&gt; {
  test('is delicious', () =&gt; {
    expect(myBeverage.delicious).toBeTruthy();
  });

  test('is not sour', () =&gt; {
    expect(myBeverage.sour).toBeFalsy();
  });
});
</code></pre>
<p>这不是必需的-您可以直接在顶层编写测试块。但是，如果您希望将测试分为组，这可能会很方便。
如果你有测试的层次结构，你也可以嵌套描述块:</p>
<pre><code class="language-typescript">const binaryStringToNumber = binString =&gt; {
  if (!/^[01]+$/.test(binString)) {
    throw new CustomError('Not a binary number.');
  }

  return parseInt(binString, 2);
};

describe('binaryStringToNumber', () =&gt; {
  describe('given an invalid binary string', () =&gt; {
    test('composed of non-numbers throws CustomError', () =&gt; {
      expect(() =&gt; binaryStringToNumber('abc')).toThrowError(CustomError);
    });

    test('with extra whitespace throws CustomError', () =&gt; {
      expect(() =&gt; binaryStringToNumber('  100')).toThrowError(CustomError);
    });
  });

  describe('given a valid binary string', () =&gt; {
    test('returns the correct number', () =&gt; {
      expect(binaryStringToNumber('100')).toBe(4);
    });
  });
});
</code></pre>
<h2 id="describeeachtablename-fn-timeout"><a class="header" href="#describeeachtablename-fn-timeout"><a href="https://jestjs.io/docs/api#describeeachtablename-fn-timeout"><code>describe.each(table)(name, fn, timeout)</code></a></a></h2>
<ul>
<li>
<p>使用不同的数据执行重复的测试集</p>
</li>
<li>
<p>name: 测试套件的名称</p>
</li>
<li>
<p><code>describe.each(table)(name, fn, timeout)</code></p>
</li>
<li>
<p>通过占位符注入参数生成唯一的测试标题</p>
<p><code>printf</code> formatting</p>
<ul>
<li><code>%p</code> - <a href="https://www.npmjs.com/package/pretty-format">pretty-format</a>.</li>
<li><code>%s</code>- String.</li>
<li><code>%d</code>- Number.</li>
<li><code>%i</code> - Integer.</li>
<li><code>%f</code> - Floating point value.</li>
<li><code>%j</code> - JSON.</li>
<li><code>%o</code> - Object.</li>
<li><code>%#</code> - Index of the test case.</li>
<li><code>%%</code> - single percent sign ('%'). This does not consume an argument.</li>
</ul>
</li>
<li>
<p>或通过使用 $variable注入测试用例对象的属性来生成唯一的测试标题</p>
<ul>
<li>
<p>嵌套对象使用： <code>$variable.path.to.value</code></p>
</li>
<li>
<p>可以使用 <code>$#</code>注入测试用例的索引</p>
</li>
<li>
<p>您不能将 “$ variableable” 与 “printf” format 一起使用，除非 使用 %%</p>
</li>
</ul>
</li>
<li>
<p>fn: 函数要运行的测试套件，这是将接收每行中的参数作为函数参数的函数。</p>
</li>
<li>
<p>您可以提供一个超时时间 (以毫秒为单位)，用于指定在中止之前等待每一行多长时间。注意: 默认超时时间为5秒。</p>
</li>
</ul>
<pre><code class="language-typescript">describe.each([
  [1, 1, 2],
  [1, 2, 3],
  [2, 1, 3],
])('.add(%i, %i)', (a, b, expected) =&gt; {
  test(`returns ${expected}`, () =&gt; {
    expect(a + b).toBe(expected);
  });

  test(`returned value not be greater than ${expected}`, () =&gt; {
    expect(a + b).not.toBeGreaterThan(expected);
  });

  test(`returned value not be less than ${expected}`, () =&gt; {
    expect(a + b).not.toBeLessThan(expected);
  });
});
</code></pre>
<pre><code class="language-typescript">describe.each([
  {a: 1, b: 1, expected: 2},
  {a: 1, b: 2, expected: 3},
  {a: 2, b: 1, expected: 3},
])('.add($a, $b)', ({a, b, expected}) =&gt; {
  test(`returns ${expected}`, () =&gt; {
    expect(a + b).toBe(expected);
  });

  test(`returned value not be greater than ${expected}`, () =&gt; {
    expect(a + b).not.toBeGreaterThan(expected);
  });

  test(`returned value not be less than ${expected}`, () =&gt; {
    expect(a + b).not.toBeLessThan(expected);
  });
});
</code></pre>
<h3 id="describeeachtablename-fn-timeout-1"><a class="header" href="#describeeachtablename-fn-timeout-1">describe.each`table`(name, fn, timeout)</a></h3>
<p><strong>table</strong></p>
<p>标记模板文字</p>
<p><strong>name</strong></p>
<p>测试套件名称</p>
<pre><code class="language-python">describe.each`
  a    | b    | expected
  ${1} | ${1} | ${2}
  ${1} | ${2} | ${3}
  ${2} | ${1} | ${3}
`('$a + $b', ({a, b, expected}) =&gt; {
  test(`returns ${expected}`, () =&gt; {
    expect(a + b).toBe(expected);
  });

  test(`returned value not be greater than ${expected}`, () =&gt; {
    expect(a + b).not.toBeGreaterThan(expected);
  });

  test(`returned value not be less than ${expected}`, () =&gt; {
    expect(a + b).not.toBeLessThan(expected);
  });
});
</code></pre>
<h3 id="describeonlyname-fn"><a class="header" href="#describeonlyname-fn"><a href="https://jestjs.io/docs/api#describeonlyname-fn"><code>describe.only(name, fn)</code></a></a></h3>
<p>同名函数：<code>fdescribe(name, fn)</code></p>
<p>只运行该测试块，而不运行其他测试块</p>
<ul>
<li><code>describe.only.each(table)(name, fn)</code></li>
<li><code>describe.only.each</code>table<code>(name, fn)</code></li>
</ul>
<pre><code class="language-typescript">describe.only('my beverage', () =&gt; {
  test('is delicious', () =&gt; {
    expect(myBeverage.delicious).toBeTruthy();
  });

  test('is not sour', () =&gt; {
    expect(myBeverage.sour).toBeFalsy();
  });
});

describe('my other beverage', () =&gt; {
  // ... will be skipped
});
</code></pre>
<h2 id="describeskipname-fn"><a class="header" href="#describeskipname-fn"><code>describe.skip(name, fn)</code></a></h2>
<ul>
<li>跳过该测试块</li>
<li>同义函数：<code>xdescribe(name, fn)</code></li>
<li>使用<code>describe.skip</code> 一般用来临时取消掉不用的注释。请注意，describe块仍将运行。如果您有一些也应该跳过的设置，请在beforall或beforeach块中进行。</li>
<li><code>describe.skip.each(table)(name, fn)</code></li>
<li>xdescribe.`each`table(name, fn)</li>
<li>describe.skip.each`table`(name, fn)</li>
</ul>
<pre><code class="language-typescript">describe('my beverage', () =&gt; {
  test('is delicious', () =&gt; {
    expect(myBeverage.delicious).toBeTruthy();
  });

  test('is not sour', () =&gt; {
    expect(myBeverage.sour).toBeFalsy();
  });
});

describe.skip('my other beverage', () =&gt; {
  // ... will be skipped
});
</code></pre>
<h2 id="testname-fn-timeout"><a class="header" href="#testname-fn-timeout"><code>test(name, fn, timeout)</code></a></h2>
<ul>
<li>同义函数：<code>it(name, fn, timeout)</code></li>
</ul>
<pre><code class="language-typescript">test('did not rain', () =&gt; {
  expect(inchesOfRain()).toBe(0);
});
</code></pre>
<ul>
<li>
<p>第一个参数是测试名称</p>
</li>
<li>
<p>第二个参数是包含要测试的期望的函数。</p>
</li>
<li>
<p>第三个参数 (可选) 是超时 (以毫秒为单位)，用于指定中止前等待多长时间。注意: 默认超时时间为5秒。</p>
</li>
<li>
<p>如果从test返回promise ，Jest将等待Promis resloved，然后再完成测试。</p>
</li>
<li>
<p>如果您为测试函数提供了一个参数，名字叫做，done，那么Jest也会等待。</p>
</li>
</ul>
<p>当你想测试回调时，这可能很方便。<a href="https://jestjs.io/docs/asynchronous#callbacks">here</a>  看到如何测试异步代码。</p>
<p>例如，假设fetchBeverageList() 返回一个承诺，该承诺应该解析为包含柠檬的列表。您可以使用以下方法进行测试:</p>
<pre><code class="language-typescript">test('has lemon in it', () =&gt; {
  return fetchBeverageList().then(list =&gt; {
    expect(list).toContain('lemon');
  });
});
</code></pre>
<p>即使测试调用将立即返回，测试也要等到promise解决后才能完成。</p>
<h3 id="testconcurrentname-fn-timeout"><a class="header" href="#testconcurrentname-fn-timeout"><a href="https://jestjs.io/docs/api#testconcurrentname-fn-timeout"><code>test.concurrent(name, fn, timeout)</code></a></a></h3>
<ul>
<li>
<p><code>it.concurrent(name, fn, timeout)</code></p>
</li>
<li>
<p><code>test.concurrent.each(table)(name, fn, timeout)</code></p>
</li>
<li>
<p><code>test.concurrent.only.each(table)(name, fn)</code></p>
</li>
<li>
<p><code>test.concurrent.skip.each(table)(name, fn)</code></p>
</li>
<li>
<p><code>test.concurrent.skip.each</code>table<code>(name, fn)</code></p>
</li>
<li>
<p>第一个参数是测试名称; </p>
</li>
<li>
<p>第二个参数是包含要测试的期望的异步函数。</p>
</li>
<li>
<p>第三个参数 (可选) 是超时 (以毫秒为单位)，用于指定中止前等待多长时间。注意: 默认超时时间为5秒。</p>
</li>
</ul>
<pre><code class="language-typescript">test.concurrent('addition of 2 numbers', async () =&gt; {
  expect(5 + 3).toBe(8);
});

test.concurrent('subtraction 2 numbers', async () =&gt; {
  expect(5 - 3).toBe(2);
});
</code></pre>
<h2 id="testeachtablename-fn-timeout"><a class="header" href="#testeachtablename-fn-timeout"><code>test.each(table)(name, fn, timeout)</code></a></h2>
<h2 id="testonlyname-fn-timeout"><a class="header" href="#testonlyname-fn-timeout"><code>test.only(name, fn, timeout)</code></a></h2>
<div style="break-before: page; page-break-before: always;"></div><pre><code class="language-typescript">beforeAll(() =&gt; console.log('1 - beforeAll'));
afterAll(() =&gt; console.log('1 - afterAll'));
beforeEach(() =&gt; console.log('1 - beforeEach'));
afterEach(() =&gt; console.log('1 - afterEach'));
test('', () =&gt; console.log('1 - test'));
describe('Scoped / Nested block', () =&gt; {
  beforeAll(() =&gt; console.log('2 - beforeAll'));
  afterAll(() =&gt; console.log('2 - afterAll'));
  beforeEach(() =&gt; console.log('2 - beforeEach'));
  afterEach(() =&gt; console.log('2 - afterEach'));
  test('', () =&gt; console.log('2 - test'));
});
</code></pre>
<pre><code>// 1 - beforeAll
// 1 - beforeEach
// 1 - test
// 1 - afterEach
// 2 - beforeAll
// 1 - beforeEach
// 2 - beforeEach
// 2 - test
// 2 - afterEach
// 1 - afterEach
// 2 - afterAll
// 1 - afterAll
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script type="text/javascript">
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->

        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </body>
</html>
